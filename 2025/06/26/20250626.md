function sample(a, b, c) {
  printf "a: %s, b: %s, c: %s\n", a, b, c
}

# save binding arguments to global variable BINDING
# key will be used as partial function(default parameter from binding info)
# the form value consists two parts, head and tails separated with first SSEP
# head contains `original function name`
# tail is of form string representation of the list of tuple, which argName SUBSEP value
# each elements is joined with SSEP
function saveArgTemplete(key, fnname, bindings,    argTemplete) {
  argTemplete = fnname SSEP

  if (length(bindings) == 0) {
    BINDING[key] = argTemplete
    return
  }
  argTemplete = argTemplete serializeAssoc(bindings)
  BINDING[key] = argTemplete
}

function serializeAssoc(assoc,    acc) {
  for (key in assoc) {
    acc = acc key SUBSEP assoc[key] SSEP
  }
  return substr(acc, 1, length(acc) - 1)
}

function bindPosition(array,    acc) {
  for (i = 1; i <= length(array); i++) {
    acc = acc i SUBSEP array[i] SSEP
  }
  return substr(acc, 1, length(acc) - 1)
}

function flip(assoc) {
  for (idx in assoc) {
    assoc[assoc[idx]] = idx
  }
}

function printArray(arr, arrName) {
  for (idx in arr) {
    printf "%s[%s]: %s\n", (arrName ? arrName : "arr"), idx, arr[idx]
  }
}

function apply(arr, fn) {
  for (idx in arr) {
    arr[idx] = @fn(arr[idx])
  }
}

function strReprArr2dict(strReprArr, dict,    strRepr) {
  delete dict
  for (i = 1; i <= length(strReprArr); i++) {
    strRepr = strReprArr[i]
    partition(strRepr, SUBSEP, headtail)
    dict[headtail[1]] = headtail[2]
  }
}

function partition(str, sep, headtail) {
  headtail[1] = substr(str, 1, index(str, sep) - length(sep))
  headtail[2] = substr(str, index(str, sep) + length(sep))
}

function call(key, args,    bindings) {
  printf "key: %s, length(args): %d\n", key, length(args)
  if (!BINDING[key]) {
    print "unregistered function call"
    return
  }
  printArray(FUNCSIG, "FUNCSIG")
  printArray(BINDING, "BINDING")
  printArray(args, "args")
}

function saveSignature(fnname, argInfo) {
  posRepr = bindPosition(argInfo)
  FUNCSIG[fnname] = posRepr
}

function zip(arr1, arr2, dict) {
  minlen = (length(arr1) < length(arr2) ? length(arr1) : length(arr2))
  for (i = 1; i <= minlen; i++) {
    dict[arr1[i]] = arr2[i]
  }
}

BEGIN {
  SSEP = "\035"
  split("a b c", arginfo)
  saveSignature("sample", arginfo)
  split("b c", keys)
  split("5678 asdf", vals)
  zip(keys, vals, bindings)
  saveArgTemplete("partial", "sample", bindings)
  printArray(BINDING, "BINDING")
  split("asdf zxcv", args)
  call("partial", args)
}



```awk
function sample(a, b, c) {
  printf "a: %s, b: %s, c: %s\n", a, b, c
}

# save binding arguments to global variable BINDING
# key will be used as partial function(default parameter from binding info)
# the form value consists two parts, head and tails separated with first SSEP
# head contains `original function name`
# tail is of form string representation of the list of tuple, which argName SUBSEP value
# each elements is joined with SSEP
function bind(key, fnname, bindings,    argRepr) {
  argRepr = fnname SSEP

  if (length(bindings) == 0) {
    BINDING[key] = argRepr
    return
  }
  argRepr = argRepr serializeAssoc(bindings)
  BINDING[key] = argRepr
}

function serializeAssoc(assoc,    acc) {
  for (key in assoc) {
    acc = acc key SUBSEP assoc[key] SSEP
  }
  return substr(acc, 1, length(acc) - 1)
}

function bindPosition(array,    acc) {
  for (i = 1; i <= length(array); i++) {
    acc = acc i SUBSEP array[i] SSEP
  }
  return substr(acc, 1, length(acc) - 1)
}

function flip(assoc) {
  for (idx in assoc) {
    assoc[assoc[idx]] = idx
  }
}

function printArray(arr, arrName) {
  for (idx in arr) {
    printf "%s[%s]: %s\n", (arrName ? arrName : "arr"), idx, arr[idx]
  }
}

function apply(arr, fn) {
  for (idx in arr) {
    arr[idx] = @fn(arr[idx])
  }
}

function strReprArr2dict(strReprArr, dict,    strRepr) {
  delete dict
  for (i = 1; i <= length(strReprArr); i++) {
    strRepr = strReprArr[i]
    partition(strRepr, SUBSEP, headtail)
    dict[headtail[1]] = headtail[2]
  }
}

function partition(str, sep, headtail) {
  headtail[1] = substr(str, 1, index(str, sep) - length(sep))
  headtail[2] = substr(str, index(str, sep) + length(sep))
}

function call(key, args,    bindings) {
  printf "key: %s, length(args): %d\n", key, length(args)
  if (!BINDING[key]) {
    print "unregistered function call"
    return
  }
  printArray(FUNCSIG, "FUNCSIG")
  printArray(BINDING, "BINDING")
  printArray(args, "args")

  buildParameter(key, args, params)

  switch (length(params)) {
    case 1:
      executeFunc1(fnname, params)
      break
    case 2:
      executeFunc2(fnname, params)
      break
    case 3:
      executeFunc3(fnname, params)
      break
    case 4:
      executeFunc4(fnname, params)
      break
    default:
      print "can not execute #(function params) > 4"
      return
  }

}

function buildParameter(key, args, params) {
  partition(BINDING[key], SSEP, fnBinding)
  fnname = fnBinding[1]
  inspectParams(fnname, paramDict)
  bindingRepr = fnBinding[2]
  bindingRepr2Dict(bindingRepr, bindingDict)

  print "fnname: " fnname
  printArray(paramDict, "paramDict")
  printArray(args, "args")
  printArray(bindingDict, "bindingDict")
  for (idx in args) {
    params[idx] = args[idx]
  }
  for (idx in paramDict) {
    if (!params[paramDict[idx]]) {
      params[paramDict[idx]] = bindingDict[idx]
    }
  }
  if (length(paramDict) != length(params)) {
    print "invalid execution, mismatch between original function and binded function"
    delete params
  }
}

function bindingRepr2Dict(repr, bindingDict,    tmp) {
  split(repr, tmp, SSEP)
  print "repr: " repr
  for (idx in tmp) {
    split(tmp[idx], keyVal, SUBSEP)
    print keyVal[1]
    print keyVal[2]
    bindingDict[keyVal[1]] = keyVal[2]
  }
}

function inspectParams(fnname, paramDict) {
  posRepr = FUNCSIG[fnname]
  posRepr2Dict(posRepr, paramDict)
}

function posRepr2Dict(posRepr, paramDict,    tmp, posNameTuple) {
  split(posRepr, tmp, SSEP)
  for (idx in tmp) {
    split(tmp[idx], posName, SUBSEP)
    paramDict[posName[2]] = posName[1]
  }
}

function executeFunc1(fnname, params) {
  @fnname(params[1])
}

function executeFunc2(fnname, params) {
  @fnname(params[1], params[2])
}

function executeFunc3(fnname, params) {
  @fnname(params[1], params[2], params[3])
}

function executeFunc4(fnname, params) {
  @fnname(params[1], params[2], params[3], params[4])
}

# save function signature to global variable FUNCSIG
# argument information is of form list of tuples (position, parameter name)
# list element delemter: SSEP, key-value delemeter: SUBSEP
function saveSignature(fnname, argInfo) {
  posRepr = bindPosition(argInfo)
  FUNCSIG[fnname] = posRepr
}

function zip(arr1, arr2, dict) {
  minlen = (length(arr1) < length(arr2) ? length(arr1) : length(arr2))
  for (i = 1; i <= minlen; i++) {
    dict[arr1[i]] = arr2[i]
  }
}

BEGIN {
  SSEP = "\035"
  split("a b c", arginfo)
  saveSignature("sample", arginfo)
  split("b c", keys)
  split("5678 asdf", vals)
  zip(keys, vals, bindings)
  bind("partial", "sample", bindings)
  split("1", args)
  call("partial", args)
}
```

---



```
@include "common"
@include "functool"


function sample(a, b, c) {
  printf "a: %s, b: %s, c: %s\n", a, b, c
}

begin {
  ssep = "\035"
  split("a b c", arginfo)
  savesignature("sample", arginfo)
  split("b c", keys)
  split("5678 asdf", vals)
  zip(keys, vals, bindings)
  bind("partial", "sample", bindings)
  split("1", args)
  call("partial", args)
}

```

```
# assume arr is 1 based array from 1 to length(arr)
function join(arr, sep, start, end) {
  if (length(arr) == 0) return start end

  acc = (start ? start : "") arr[1]
  for (i = 2; i <= length(arr); i++) {
    acc = acc sep arr[i]
  }
  if (end) acc = acc end

  return acc
}

function joinassoc(arr, sep, start, end) {

  origin_sort = procinfo["sorted_in"]
  procinfo["sorted_in"] = "@ind_str_asc"

  if (length(arr) == 0) return start end

  firstflag = 1

  for (idx in arr) {
    if (firstflag == 1) {
      acc = (start ? start : "") arr[idx]
      firstflag = 0
      continue
    }
    acc = acc sep arr[idx]
  }
  if (end) acc = acc end

  procinfo["sorted_in"] = origin_sort
  return acc
}

function strip(str) {
  gsub(/^\s+|\s+$/, "", str)
  return str
}

function rindex(hay, needle,    arr, lasttoken) {
  lasttoken = arr[split(hay, arr, needle)]
  return length(hay) - length(needle) - length(lasttoken) + 1
}

function format(fmt, target) {
  return sprintf(fmt, strip(target))
}

function compareassoc(assoc1, assoc2, res) {
  delete res
  for (idx1 in assoc1) {
    res[idx1]--
  }
  for (idx2 in assoc2) {
    res[idx2]++
  }
}

function comparearray(arr1, arr2, res) {
  delete res
  for (idx1 in arr1) {
    res[arr1[idx1]]--
  }
  for (idx2 in arr2) {
    res[arr2[idx2]]++
  }
}

function partition(str, sep, headtail) {
  headtail[1] = substr(str, 1, index(str, sep) - length(sep))
  headtail[2] = substr(str, index(str, sep) + length(sep))
}

function printarray(arr, arrname) {
  for (idx in arr) {
    printf "%s[%s]: %s\n", (arrname ? arrname : "arr"), idx, arr[idx]
  }
}

function flip(assoc) {
  for (idx in assoc) {
    assoc[assoc[idx]] = idx
  }
}

function zip(arr1, arr2, dict) {
  minlen = (length(arr1) < length(arr2) ? length(arr1) : length(arr2))
  for (i = 1; i <= minlen; i++) {
    dict[arr1[i]] = arr2[i]
  }
}
```

```
# out array set to global variable "mapres"
function map(arr, fn, res,     idx) {
  delete res
  for (idx in arr) {
    res[idx] = @fn(arr[idx])
  }
}

# inplace operation
function apply(arr, fn,     idx) {
  for (idx in arr) {
    arr[idx] = @fn(arr[idx])
  }
}

function filter(arr, pred, res,    count, i) {
  delete res
  for (i = 1; i <= length(arr); i++) {
    if (@pred(arr[i])) res[++count] = arr[i]
  }
}

function filterassoc(arr, pred, res,     idx) {
  delete res
  for (idx in arr) {
    if (@pred(arr[idx])) res[idx] = arr[idx]
  }
}

function executefunc1(fnname, params) {
  @fnname(params[1])
}

function executefunc2(fnname, params) {
  @fnname(params[1], params[2])
}

function executefunc3(fnname, params) {
  @fnname(params[1], params[2], params[3])
}

function executefunc4(fnname, params) {
  @fnname(params[1], params[2], params[3], params[4])
}

# save binding arguments to global variable binding
# key will be used as partial function(default parameter from binding info)
# the form value consists two parts, head and tails separated with first ssep
# head contains `original function name`
# tail is of form string representation of the list of tuple, which argname subsep value
# each elements is joined with ssep
function bind(key, fnname, bindings,    argrepr) {
  argrepr = fnname ssep

  if (length(bindings) == 0) {
    binding[key] = argrepr
    return
  }
  argrepr = argrepr serializeassoc(bindings)
  binding[key] = argrepr
}

function serializeassoc(assoc,    acc) {
  for (key in assoc) {
    acc = acc key subsep assoc[key] ssep
  }
  return substr(acc, 1, length(acc) - 1)
}

function bindposition(array,    acc) {
  for (i = 1; i <= length(array); i++) {
    acc = acc i subsep array[i] ssep
  }
  return substr(acc, 1, length(acc) - 1)
}

function strreprarr2dict(strreprarr, dict,    strrepr) {
  delete dict
  for (i = 1; i <= length(strreprarr); i++) {
    strrepr = strreprarr[i]
    partition(strrepr, subsep, headtail)
    dict[headtail[1]] = headtail[2]
  }
}

function call(key, args,    bindings) {
  if (!binding[key]) {
    print "unregistered function call"
    return
  }
  buildparameter(key, args, params)

  switch (length(params)) {
    case 1:
      executefunc1(fnname, params)
      break
    case 2:
      executefunc2(fnname, params)
      break
    case 3:
      executefunc3(fnname, params)
      break
    case 4:
      executefunc4(fnname, params)
      break
    default:
      print "#(function params) must one of 1, 2, 3, or 4"
      return
  }

}

function buildparameter(key, args, params) {
  partition(binding[key], ssep, fnbinding)
  fnname = fnbinding[1]
  inspectparams(fnname, paramdict)
  bindingrepr = fnbinding[2]
  bindingrepr2dict(bindingrepr, bindingdict)

  for (idx in args) {
    params[idx] = args[idx]
  }
  for (idx in paramdict) {
    if (!params[paramdict[idx]]) {
      params[paramdict[idx]] = bindingdict[idx]
    }
  }
  if (length(paramdict) != length(params)) {
    print "invalid execution, mismatch between original function and binded function"
    delete params
  }
}

function bindingrepr2dict(repr, bindingdict,    tmp) {
  split(repr, tmp, ssep)
  for (idx in tmp) {
    split(tmp[idx], keyval, subsep)
    bindingdict[keyval[1]] = keyval[2]
  }
}

function inspectparams(fnname, paramdict) {
  posrepr = funcsig[fnname]
  posrepr2dict(posrepr, paramdict)
}

function posrepr2dict(posrepr, paramdict,    tmp, posnametuple) {
  split(posrepr, tmp, ssep)
  for (idx in tmp) {
    split(tmp[idx], posname, subsep)
    paramdict[posname[2]] = posname[1]
  }
}

# save function signature to global variable funcsig
# argument information is of form list of tuples (position, parameter name)
# list element delemter: ssep, key-value delemeter: subsep
function savesignature(fnname, arginfo) {
  posrepr = bindposition(arginfo)
  funcsig[fnname] = posrepr
}
```


```
export awkpath='~/.cli/awk/lib'
```
