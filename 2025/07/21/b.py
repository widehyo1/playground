import random
import string

def generate_random_string(length):
    characters = string.ascii_letters
    return ''.join(random.choice(characters).lower() for i in range(length))

def main():
    # n <= 50, k <= 26
    # starts with "anta", ends with "tica"
    # num of distinct chars <= k ==> return n
    # num of distinct chars > k
    # 어떻게 빼나가야 할까 n개의 단어 중에서 distinct 한 char가 k로만 이루어짐
    # distinct char 개수만큼의 bit array를 생각
    # antarctica
    # antahellotica
    # antacartica

    # n, k = map(input().split(), int)
    # words = [input() for _ in range(n)]

    # n = 3
    # k = 6
    #
    # words = ["antarctica", "antahellotica", "antacartica"]

    # n = 9
    # k = 8
    # words = [
    #     "antabtica",
    #     "antaxtica",
    #     "antadtica",
    #     "antaetica",
    #     "antaftica",
    #     "antagtica",
    #     "antahtica",
    #     "antajtica",
    #     "antaktica",
    # ]
    words  = [generate_random_string(random.randint(10, 20)) for _ in range(20)]

    chars = set()
    for word in words:
        chars |= set(word)

    print(chars)
    print(len(chars))
    print(sorted(list(chars)))

    bit_mapper = {char: idx for idx, char in enumerate(sorted(list(chars)))}
    # print(f"{bit_mapper=}")

    # bit_arr = [str(bin(to_bit(word, bit_mapper)))[2:] for word in words]
    bit_arr = [bin(to_bit(word, bit_mapper)) for word in words]
    bit_arr = [str(bin(to_bit(word, bit_mapper)))[2:].zfill(len(chars)) for word in words]
    get_info(bit_arr)
    # bit_arr = [len(str(bin(to_bit(word, bit_mapper)))) for word in words]

    # 6개의 char가 있다
    # 1101010011
    # 1011111111
    # 1101010011
    # (6, bitarr) => 2
    # 일단 최소 개수보다 작다면 0
    # 모든 자리수만큼 있다면 n
    # 선택해야 하는 경우 어떻게 선택하는게 최선일까
    # 일단 모두 존재하는건 가지고 가는게 맞다
    # 그 다음은 어떻게 선택하나?
    #
    # 숫자 5를 써서 공통된 컬럼을 지운 모습
    # 10000
    # 01111
    # 10000
    #
    # 이제 사용할 수 있는 숫자는 (6 - 5) = 1
    # 이제부터는 컬럼별로 가장 많이 hit되는 word를 선택해서 0이 될 때까지 계속해서 빼나가기
    # 모두 0이 될 때마다 결과 +1
    # 모든 숫자가 소진되면 result 나옴
    #
    # 남은 length (at most 26) 에 대하여 zip 해서 더한 숫자로 counter를 구함
    # {2: 1, 1: 4}, 1
    # 컬럼순으로

    # 예시  2개 뺄 수 있음
    #
    # 10101|3
    # 01111|4
    # 10010|2
    #>21222

    # 이거 맞나?

    # 반례가 나올 것 같은데
    # 10101111|6
    # 01111111|8
    # 10010000|2
    #>21222222

    # 행과 열을 같이 보고 뺀다
    # remaining number: 8

    # 
    # 01100100000111#6
    # 11100100000101#6
    # 01100100001101#6
    # 01100100010101#6
    # 01100100100101#6
    # 01100101000101#6
    # 01100110000101#6
    # 01101100000101#6
    # 01110100000101#6
    #################
    # 19911911111919

    # remaining number: 3
    # 
    # 000000001#1
    # 100000000#1
    # 000000010#1
    # 000000100#1
    # 000001000#1
    # 000010000#1
    # 000100000#1
    # 001000000#1
    # 010000000#1
    ############
    # 111111111


    # remaining number: 8
    # 
    # 01100100000111#6
    # 11100000000101#5
    # 01000100001101#5
    # 01100100010100#5
    # 01100100100101#6
    # 01100101000101#6
    # 01100110000101#6
    # 01101100000001#5
    # 00110100000101#5
    #################
    # 18811811111818
    #
    # 이게 엄청 길어
    # 8이 10개야 근데 이걸 뺀다고 해도 하나의 단어도 안만들어져

    # 여기서 k개의 숫자를 사용할 수 있음
    # 컬럼 단위로 제거 가능
    # 어떤 전략으로 컬럼을 제거하여야 하는가?
    #

    # 11001001111010111010000011
    # 00000001011010110001010101
    # 10111101110101101010100110
    # 11100110010101110100001000
    # 00001001011001000101000010
    # 10110111100100101011100100
    # 11101010100000001001111000
    # 10001111111010000000111100
    # 00001011010010001011001111
    # 11101000000111000101010011
    # 00111000000101101111101111
    # 11001100001000110101100100
    # 00110001001110110100110011
    # 11111110001010011000001010
    # 01001010100100000001110010
    # 00001011001101000011010000
    # 00110010101101010011100100
    # 10000101111110110100011001
    # 01100001101001100111001011
    # 00111100100101000000010000

    # row_info={0: 14, 1: 10, 2: 16, 3: 12, 4: 8, 5: 14, 6: 11, 7: 13, 8: 12, 9: 12, 10: 15, 11: 11, 12: 13, 13: 13, 14: 9, 15: 9, 16: 12, 17: 14, 18: 13, 19: 8}
    # col_info={0: 10, 1: 8, 2: 11, 3: 7, 4: 13, 5: 8, 6: 9, 7: 11, 8: 10, 9: 8, 10: 11, 11: 11, 12: 8, 13: 9, 14: 10, 15: 8, 16: 7, 17: 8, 18: 8, 19: 12, 20: 9, 21: 9, 22: 8, 23: 8, 24: 10, 25: 8}

    # 여기서부터 재귀 먹여야할듯?
    # solution을 안ㄷ다면 어떨까 
    # 1열일때? 1행일때? 1행일때
    # 1행일 때의 답을 알면 2행일 때의 답이 나오나? 아님

    # 00 00 00 00 01 01 01 01 10 10 10 10 11 11 11 11
    # 00 01 10 11 00 01 10 11 00 01 10 11 00 01 10 11

    # n 이 2 <= n <= 4와 n >= 5
    #
    # 1111100
    # 1111100
    # 1111100
    # 1111100
    # 0000011
    # 1111100
    # 1111100
    # 1111100

    # backtracking?
    # 결국 n개에서 선택하는 것이긴 함
    # k라는건 d자리 2진수에서 1이 k인 것을 가지고 and 연산을 해서 자기자신이 나오는 숫자를 가장 많이 만들겠다.
    # 일단은 조합이네
    # 조합이면 DP?
    # backtracking? 2^k개의 경우의 수 중에서 더이상 안봐도 되는 경우는?
    # 결국 최고점수를 내는 조합찾기

    # 컬럼을 하나씩 순회하면서 선택할지 안할지 결정하는데
    # 1이 있는데도 선택하지 않는다면 해당하는 열은 아예 의미가 없어짐
    #

    # 11001001111010111010000011
    # 00000001011010110001010101
    # 10111101110101101010100110
    # 11100110010101110100001000
    # 00001001011001000101000010
    # 10110111100100101011100100
    # 11101010100000001001111000
    # 10001111111010000000111100
    # 00001011010010001011001111
    # 11101000000111000101010011
    # 00111000000101101111101111
    # 11001100001000110101100100
    # 00110001001110110100110011
    # 11111110001010011000001010
    # 01001010100100000001110010
    # 00001011001101000011010000
    # 00110010101101010011100100
    # 10000101111110110100011001
    # 01100001101001100111001011
    # 00111100100101000000010000

    # 에서 1열을 선택하지 않으면 1열이 1인 모든 행이 삭제된다.
    # 남은 숫자 8

    # 00000001011010110001010101
    # 00001001011001000101000010
    # 00001011010010001011001111
    # 00111000000101101111101111
    # 00110001001110110100110011
    # 01001010100100000001110010
    # 00001011001101000011010000
    # 00110010101101010011100100
    # 01100001101001100111001011
    # 00111100100101000000010000

    # 다음열은 모두 0이므로 숫자 차감없이 열만 하나 삭제


    # 0000001011010110001010101
    # 0001001011001000101000010
    # 0001011010010001011001111
    # 0111000000101101111101111
    # 0110001001110110100110011
    # 1001010100100000001110010
    # 0001011001101000011010000
    # 0110010101101010011100100
    # 1100001101001100111001011
    # 0111100100101000000010000

    # 0을 선택하는 것이 아주 강력한 영향을 미치네
    # 여기에서도 0을 선택하면?

    # 0000001011010110001010101
    # 0001001011001000101000010
    # 0001011010010001011001111
    # 0111000000101101111101111
    # 0110001001110110100110011
    # 1001010100100000001110010
    # 0001011001101000011010000
    # 0110010101101010011100100
    # 1100001101001100111001011
    # 0111100100101000000010000

    # 남은 숫자 8
    # 그리고 0만 남도록 강제했으므로(한 열을 소비했으므로)

    # 0000001011010110001010101
    # 0001001011001000101000010
    # 0001011010010001011001111
    # 0111000000101101111101111
    # 0110001001110110100110011
    # 0001011001101000011010000
    # 0110010101101010011100100
    # 0111100100101000000010000


    # 000001011010110001010101
    # 001001011001000101000010
    # 001011010010001011001111
    # 111000000101101111101111
    # 110001001110110100110011
    # 001011001101000011010000
    # 110010101101010011100100
    # 111100100101000000010000

    # 자리수 - 8개의 비트를 선택하여 해당하는 비트가 1인 모든 행을 삭제

    # 자리수는 7
    # n이 2라면 5개의 0 비트를 선택가능
    # 0 비트 배치로 보는게 더 간편하겠다.
    # 하나라도 걸리는 행 삭제
    # n 이 2 <= n <= 4와 n >= 5
    #
    # 1111100
    # 1111100
    # 1111100
    # 1111100
    # 0000011
    # 1111100
    # 1111100
    # 1111100

    # 7777711

    # 1100000
    # 0011111
    # 0011111
    # 0011111
    # 0011111
    # 0011111
    # 0011111
    # 0011111

    # 1177777

    # 이거랑 같음

    # 이정도부터 백트래킹할까
    # 일단 0으로 다 채우고 남는 행의 수보다 작아지는 경우 백트래킹 가능
    # 이쪽으로 가야겠네
    # 일단 0을 넣어본다
    # 일단 0을 가장 적은 수부터 넣어본다.
    # 이 상태에서는 정렬할수 있네
    # 이거 정렬해야한다.
    # 열별로 1의 개수 순으로 정렬하고 0을 하나씩 넣어보는 방법으로 가야할듯?
    # 그리고 열단위라서 대칭성 고려 됨


def to_bit(word, bit_mapper):
    print(f"{word=}, {bit_mapper=}")
    result = 0b0
    for char in word:
        print(f"{char=}")
        print(0b1 << bit_mapper[char])
        result |= 0b1 << bit_mapper[char]
    return result

def get_info(bit_arr):
    n = len(bit_arr)
    m = len(bit_arr[0])

    row_info = {}
    for row_idx, bits in enumerate(bit_arr):
        row_info[row_idx] = sum(1 if char == '1' else 0 for char in bits)

    col_info = {}
    for col_idx in range(m):
        col_info[col_idx] = sum(1 if bit_arr[idx][col_idx] == '1' else 0 for idx in range(n))

    print(bit_arr)
    print('\n'.join(bit_arr))
    print(f"{row_info=}")
    print(f"{col_info=}")

if __name__ == '__main__':
    main()
