:h motion
/usr/share/vim/vim82/doc/intro.txt
                                                        *{motion}* *movement*
{motion}        A command that moves the cursor.  These are explained in
                |motion.txt|.  Examples:
                        w                to start of next word
                        b                to begin of current word
                        4j                four lines down
                        /The<CR>        to next occurrence of "The"
                This is used after an |operator| command to move over the text
                that is to be operated upon.


:h motion.txt
/usr/share/vim/vim82/doc/motion.txt
1. Motions and operators                                *operator*

The motion commands can be used after an operator command, to have the command
operate on the text that was moved over.  That is the text between the cursor
position before and after the motion.  Operators are generally used to delete
or change text.  The following operators are available:

        |c|        c        change
        |d|        d        delete
        |y|        y        yank into register (does not change the text)
        |~|        ~        swap case (only if 'tildeop' is set)
        |g~|       g~       swap case
        |gu|       gu       make lowercase
        |gU|       gU       make uppercase
        |!|        !        filter through an external program
        |=|        =        filter through 'equalprg' or C-indenting if empty
        |gq|       gq       text formatting
        |gw|       gw       text formatting with no cursor movement
        |g?|       g?       ROT13 encoding
        |>|        >        shift right
        |<|        <        shift left
        |zf|       zf       define a fold
        |g@|       g@       call function set with the 'operatorfunc' option


Instead of first giving the operator and then a motion you can use Visual
mode: mark the start of the text with "v", move the cursor to the end of the
text that is to be affected and then hit the operator.  The text between the
start and the cursor position is highlighted, so you can see what text will
be operated upon.  This allows much more freedom, but requires more key
strokes and has limited redo functionality.  See the chapter on Visual mode
|Visual-mode|.


==============================================================================
2. Left-right motions                                   *left-right-motions*

h		or					*h*
<Left>		or					*<Left>*
CTRL-H		or					*CTRL-H* *<BS>*
<BS>			[count] characters to the left.  |exclusive| motion.

l		or					*l*
<Right>		or					*<Right>* *<Space>*
<Space>			[count] characters to the right.  |exclusive| motion.

							*0*
0			To the first character of the line.  |exclusive|
			motion.

							*<Home>* *<kHome>*
<Home>			To the first character of the line.  |exclusive|
			motion.

							*^*
^			To the first non-blank character of the line.
			|exclusive| motion.  Any count is ignored.

							*$* *<End>* *<kEnd>*
$  or <End>		To the end of the line.  |inclusive| motion.

							*f*
f{char}			To [count]'th occurrence of {char} to the right.  The
			cursor is placed on {char} |inclusive|.

							*F*
F{char}			To the [count]'th occurrence of {char} to the left.
			The cursor is placed on {char} |exclusive|.
			{char} can be entered like with the |f| command.

							*t*
t{char}			Till before [count]'th occurrence of {char} to the
			right.  The cursor is placed on the character left of
			{char} |inclusive|.
			{char} can be entered like with the |f| command.

							*T*
T{char}			Till after [count]'th occurrence of {char} to the
			left.  The cursor is placed on the character right of
			{char} |exclusive|.
			{char} can be entered like with the |f| command.

							*;*
;			Repeat latest f, t, F or T [count] times.

							*,*
,			Repeat latest f, t, F or T in opposite direction
			[count] times.

==============================================================================
3. Up-down motions                                      *up-down-motions*
k		or					*k*
<Up>		or					*<Up>* *CTRL-P*
CTRL-P			[count] lines upward |linewise|.

j		or					*j*
<Down>		or					*<Down>*
CTRL-J		or					*CTRL-J*
<NL>		or					*<NL>* *CTRL-N*
CTRL-N			[count] lines downward |linewise|.

gk		or					*gk* *g<Up>*
g<Up>			[count] display lines upward.  |exclusive| motion.
			Differs from 'k' when lines wrap, and when used with
			an operator, because it's not linewise.

gj		or					*gj* *g<Down>*
g<Down>			[count] display lines downward.  |exclusive| motion.
			Differs from 'j' when lines wrap, and when used with
			an operator, because it's not linewise.

							*G*
G			Goto line [count], default last line, on the first
			non-blank character |linewise|.

<C-Home>	or					*gg* *<C-Home>*
gg			Goto line [count], default first line, on the first
			non-blank character |linewise|.

							*N%*
{count}%		Go to {count} percentage in the file, on the first
			non-blank in the line |linewise|.

==============================================================================
4. Word motions                                         *word-motions*

<S-Right>	or					*<S-Right>* *w*
w			[count] words forward.  |exclusive| motion.

<C-Right>	or					*<C-Right>* *W*
W			[count] WORDS forward.  |exclusive| motion.
			If <C-Right> does not work, check out
			|arrow_modifiers|.

							*e*
e			Forward to the end of word [count] |inclusive|.
			Does not stop in an empty line.

							*E*
E			Forward to the end of WORD [count] |inclusive|.
			Does not stop in an empty line.

<S-Left>	or					*<S-Left>* *b*
b			[count] words backward.  |exclusive| motion.

<C-Left>	or					*<C-Left>* *B*
B			[count] WORDS backward.  |exclusive| motion.
			If <C-Left> does not work, check out
			|arrow_modifiers|.

							*ge*
ge			Backward to the end of word [count] |inclusive|.

							*gE*
gE			Backward to the end of WORD [count] |inclusive|.


These commands move over words or WORDS.
                                                        *word*
A word consists of a sequence of letters, digits and underscores, or a
sequence of other non-blank characters, separated with white space (spaces,
tabs, <EOL>).  This can be changed with the 'iskeyword' option.  An empty line
is also considered to be a word.
                                                        *WORD*
A WORD consists of a sequence of non-blank characters, separated with white
space.  An empty line is also considered to be a WORD.

==============================================================================
5. Text object motions					*object-motions*

							*(*
(			[count] sentences backward.  |exclusive| motion.

							*)*
)			[count] sentences forward.  |exclusive| motion.

							*{*
{			[count] paragraphs backward.  |exclusive| motion.

							*}*
}			[count] paragraphs forward.  |exclusive| motion.

							*]]*
]]			[count] sections forward or to the next '{' in the
			first column.  When used after an operator, then also
			stops below a '}' in the first column.  |exclusive|
			Note that |exclusive-linewise| often applies.

							*][*
][			[count] sections forward or to the next '}' in the
			first column.  |exclusive|
			Note that |exclusive-linewise| often applies.

							*[[*
[[			[count] sections backward or to the previous '{' in
			the first column.  |exclusive|
			Note that |exclusive-linewise| often applies.

							*[]*
[]			[count] sections backward or to the previous '}' in
			the first column.  |exclusive|
			Note that |exclusive-linewise| often applies.


These commands move over three kinds of text objects.

							*sentence*
A sentence is defined as ending at a '.', '!' or '?' followed by either the
end of a line, or by a space or tab.  Any number of closing ')', ']', '"'
and ''' characters may appear after the '.', '!' or '?' before the spaces,
tabs or end of line.  A paragraph and section boundary is also a sentence
boundary.
If the 'J' flag is present in 'cpoptions', at least two spaces have to
follow the punctuation mark; <Tab>s are not recognized as white space.
The definition of a sentence cannot be changed.

							*paragraph*
A paragraph begins after each empty line, and also at each of a set of
paragraph macros, specified by the pairs of characters in the 'paragraphs'
option.  The default is "IPLPPPQPP TPHPLIPpLpItpplpipbp", which corresponds to
the macros ".IP", ".LP", etc.  (These are nroff macros, so the dot must be in
the first column).  A section boundary is also a paragraph boundary.
Note that a blank line (only containing white space) is NOT a paragraph
boundary.
Also note that this does not include a '{' or '}' in the first column.  When
the '{' flag is in 'cpoptions' then '{' in the first column is used as a
paragraph boundary |posix|.

							*section*
A section begins after a form-feed (<C-L>) in the first column and at each of
a set of section macros, specified by the pairs of characters in the
'sections' option.  The default is "SHNHH HUnhsh", which defines a section to
start at the nroff macros ".SH", ".NH", ".H", ".HU", ".nh" and ".sh".

The "]]" and "[[" commands stop at the '{' in the first column.  This is
useful to find the start of a function in a C program.  To search for a '}' in
the first column, the end of a C function, use "][" (forward) or "[]"
(backward).  Note that the first character of the command determines the
search direction.

If your '{' or '}' are not in the first column, and you would like to use "[["
and "]]" anyway, try these mappings: >
   :map [[ ?{<CR>w99[{
   :map ][ /}<CR>b99]}
   :map ]] j0[[%/{<CR>
   :map [] k$][%?}<CR>
[type these literally, see |<>|]

==============================================================================
6. Text object selection			*object-select* *text-objects*
						*v_a* *v_i*

This is a series of commands that can only be used while in Visual mode or
after an operator.  The commands that start with "a" select "a"n object
including white space, the commands starting with "i" select an "inner" object
without white space, or just the white space.  Thus the "inner" commands
always select less text than the "a" commands.

These commands are not available when the |+textobjects| feature has been
disabled at compile time.
Also see `gn` and `gN`, operating on the last search pattern.

							*v_aw* *aw*
aw			"a word", select [count] words (see |word|).
			Leading or trailing white space is included, but not
			counted.
			When used in Visual linewise mode "aw" switches to
			Visual characterwise mode.

							*v_iw* *iw*
iw			"inner word", select [count] words (see |word|).
			White space between words is counted too.
			When used in Visual linewise mode "iw" switches to
			Visual characterwise mode.

							*v_aW* *aW*
aW			"a WORD", select [count] WORDs (see |WORD|).
			Leading or trailing white space is included, but not
			counted.
			When used in Visual linewise mode "aW" switches to
			Visual characterwise mode.

							*v_iW* *iW*
iW			"inner WORD", select [count] WORDs (see |WORD|).
			White space between words is counted too.
			When used in Visual linewise mode "iW" switches to
			Visual characterwise mode.

							*v_as* *as*
as			"a sentence", select [count] sentences (see
			|sentence|).
			When used in Visual mode it is made characterwise.

							*v_is* *is*
is			"inner sentence", select [count] sentences (see
			|sentence|).
			When used in Visual mode it is made characterwise.

							*v_ap* *ap*
ap			"a paragraph", select [count] paragraphs (see
			|paragraph|).
			Exception: a blank line (only containing white space)
			is also a paragraph boundary.
			When used in Visual mode it is made linewise.

							*v_ip* *ip*
ip			"inner paragraph", select [count] paragraphs (see
			|paragraph|).
			Exception: a blank line (only containing white space)
			is also a paragraph boundary.
			When used in Visual mode it is made linewise.

a]						*v_a]* *v_a[* *a]* *a[*
a[			"a [] block", select [count] '[' ']' blocks.  This
			goes backwards to the [count] unclosed '[', and finds
			the matching ']'.  The enclosed text is selected,
			including the '[' and ']'.
			When used in Visual mode it is made characterwise.

i]						*v_i]* *v_i[* *i]* *i[*
i[			"inner [] block", select [count] '[' ']' blocks.  This
			goes backwards to the [count] unclosed '[', and finds
			the matching ']'.  The enclosed text is selected,
			excluding the '[' and ']'.
			When used in Visual mode it is made characterwise.

a)							*v_a)* *a)* *a(*
a(							*vab* *v_ab* *v_a(* *ab*
ab			"a block", select [count] blocks, from "[count] [(" to
			the matching ')', including the '(' and ')' (see
			|[(|).  Does not include white space outside of the
			parenthesis.
			When used in Visual mode it is made characterwise.

i)							*v_i)* *i)* *i(*
i(							*vib* *v_ib* *v_i(* *ib*
ib			"inner block", select [count] blocks, from "[count] [("
			to the matching ')', excluding the '(' and ')' (see
			|[(|).
			When used in Visual mode it is made characterwise.

a>						*v_a>* *v_a<* *a>* *a<*
a<			"a <> block", select [count] <> blocks, from the
			[count]'th unmatched '<' backwards to the matching
			'>', including the '<' and '>'.
			When used in Visual mode it is made characterwise.

i>						*v_i>* *v_i<* *i>* *i<*
i<			"inner <> block", select [count] <> blocks, from
			the [count]'th unmatched '<' backwards to the matching
			'>', excluding the '<' and '>'.
			When used in Visual mode it is made characterwise.

						*v_at* *at*
at			"a tag block", select [count] tag blocks, from the
			[count]'th unmatched "<aaa>" backwards to the matching
			"</aaa>", including the "<aaa>" and "</aaa>".
			See |tag-blocks| about the details.
			When used in Visual mode it is made characterwise.

						*v_it* *it*
it			"inner tag block", select [count] tag blocks, from the
			[count]'th unmatched "<aaa>" backwards to the matching
			"</aaa>", excluding the "<aaa>" and "</aaa>".
			See |tag-blocks| about the details.
			When used in Visual mode it is made characterwise.

a}							*v_a}* *a}* *a{*
a{							*v_aB* *v_a{* *aB*
aB			"a Block", select [count] Blocks, from "[count] [{" to
			the matching '}', including the '{' and '}' (see
			|[{|).
			When used in Visual mode it is made characterwise.

i}							*v_i}* *i}* *i{*
i{							*v_iB* *v_i{* *iB*
iB			"inner Block", select [count] Blocks, from "[count] [{"
			to the matching '}', excluding the '{' and '}' (see
			|[{|).
			When used in Visual mode it is made characterwise.

a"							*v_aquote* *aquote*
a'							*v_a'* *a'*
a`							*v_a`* *a`*
			"a quoted string".  Selects the text from the previous
			quote until the next quote.  The 'quoteescape' option
			is used to skip escaped quotes.
			Only works within one line.
			When the cursor starts on a quote, Vim will figure out
			which quote pairs form a string by searching from the
			start of the line.
			Any trailing white space is included, unless there is
			none, then leading white space is included.
			When used in Visual mode it is made characterwise.
			Repeating this object in Visual mode another string is
			included.  A count is currently not used.

i"							*v_iquote* *iquote*
i'							*v_i'* *i'*
i`							*v_i`* *i`*
			Like a", a' and a`, but exclude the quotes and
			repeating won't extend the Visual selection.
			Special case: With a count of 2 the quotes are
			included, but no extra white space as with a"/a'/a`.

When used after an operator:
For non-block objects:
	For the "a" commands: The operator applies to the object and the white
	space after the object.  If there is no white space after the object
	or when the cursor was in the white space before the object, the white
	space before the object is included.
	For the "inner" commands: If the cursor was on the object, the
	operator applies to the object.  If the cursor was on white space, the
	operator applies to the white space.
For a block object:
	The operator applies to the block where the cursor is in, or the block
	on which the cursor is on one of the braces.  For the "inner" commands
	the surrounding braces are excluded.  For the "a" commands, the braces
	are included.

When used in Visual mode:
When start and end of the Visual area are the same (just after typing "v"):
	One object is selected, the same as for using an operator.
When start and end of the Visual area are not the same:
	For non-block objects the area is extended by one object or the white
	space up to the next object, or both for the "a" objects.  The
	direction in which this happens depends on which side of the Visual
	area the cursor is.  For the block objects the block is extended one
	level outwards.

For illustration, here is a list of delete commands, grouped from small to big
objects.  Note that for a single character and a whole line the existing vi
movement commands are used.
	"dl"	delete character (alias: "x")		|dl|
	"diw"	delete inner word			*diw*
	"daw"	delete a word				*daw*
	"diW"	delete inner WORD (see |WORD|)		*diW*
	"daW"	delete a WORD (see |WORD|)		*daW*
	"dgn"   delete the next search pattern match    *dgn*
	"dd"	delete one line				|dd|
	"dis"	delete inner sentence			*dis*
	"das"	delete a sentence			*das*
	"dib"	delete inner '(' ')' block		*dib*
	"dab"	delete a '(' ')' block			*dab*
	"dip"	delete inner paragraph			*dip*
	"dap"	delete a paragraph			*dap*
	"diB"	delete inner '{' '}' block		*diB*
	"daB"	delete a '{' '}' block			*daB*

Note the difference between using a movement command and an object.  The
movement command operates from here (cursor position) to where the movement
takes us.  When using an object the whole object is operated upon, no matter
where on the object the cursor is.  For example, compare "dw" and "daw": "dw"
deletes from the cursor position to the start of the next word, "daw" deletes
the word under the cursor and the space after or before it.


Tag blocks						*tag-blocks*

For the "it" and "at" text objects an attempt is done to select blocks between
matching tags for HTML and XML.  But since these are not completely compatible
there are a few restrictions.

The normal method is to select a <tag> until the matching </tag>.  For "at"
the tags are included, for "it" they are excluded.  But when "it" is repeated
the tags will be included (otherwise nothing would change).  Also, "it" used
on a tag block with no contents will select the leading tag.

"<aaa/>" items are skipped.  Case is ignored, also for XML where case does
matter.

In HTML it is possible to have a tag like <br> or <meta ...> without a
matching end tag.  These are ignored.

The text objects are tolerant about mistakes.  Stray end tags are ignored.

===

<table>
</table>

===



function createSlidesFromData() {
  // 새 프레젠테이션 생성
  var presentation = SlidesApp.create('Vim Command Table');
  var slide = presentation.getSlides()[0];

  // 테이블에 들어갈 데이터 (Command와 Description)
  var data = [
    ['h', '[count] characters to the left. |exclusive| motion.'],
    ['l', '[count] characters to the right. |exclusive| motion.'],
    ['0', 'To the first character of the line. |exclusive| motion.'],
    ['^', 'To the first non-blank character of the line. |exclusive| motion.'],
    ['$ or <End>', 'To the end of the line. |inclusive| motion.'],
    ['g_', 'To the last non-blank character of the line and [count - 1] lines downward |inclusive|.']
  ];

  // 슬라이드에 테이블 추가 (1개의 슬라이드에 모든 데이터를 포함한 테이블)
  var table = slide.insertTable(data.length + 1, 2);

  // 테이블 내용 채우기
  for (var i = 0; i < data.length; i++) {
    table.getCell(i, 0).getText().setText(data[i][0]);  // Command
    table.getCell(i, 1).getText().setText(data[i][1]);  // Description
  }


  // 완료된 프레젠테이션 확인
  Logger.log('슬라이드가 생성되었습니다: ' + presentation.getUrl());
}


===



BEGIN {
  RS = ""
}

{
  command_str = ""
  description_str = ""
  print "NR: " NR
  split($0, lines, "\n")
  for (idx_line in lines) {
    print "idx_line: " idx_line
    print "lines[idx_line]: " lines[idx_line]
    split(lines[idx_line], fields, "	")
    field_len = length(fields)
    for (idx_field in fields) {
      print "idx_field: " idx_field
      print "fields[idx_field]: " fields[idx_field]
      field_info[idx_line,idx_field] = fields[idx_field]
      print "field_info[idx_line,idx_field]: " field_info[idx_line,idx_field]
      if (idx_field == 1 && fields[idx_field] != "") {
        if (command_str) {
          command_str = command_str " or " fields[idx_field]
        } else {
          command_str = fields[idx_field]
        }
      }
      if (idx_field == field_len && index(fields[field_len], "*") == 0 ) {
        print "field_len: " field_len
        print "fields[field_len]: " fields[field_len]
        if (description_str) {
          description_str = description_str "\\n" fields[idx_field]
        } else {
          description_str = fields[idx_field]
        }
      }
    }
  }
#   print "command_str"
#   print command_str
  print "description_str"
  print description_str
  command_arr[NR] = command_str
  description_arr[NR] = description_str
  print "==="

}



BEGIN {
  RS = ""
}

{
  command_str = ""
  description_str = ""
#   print "NR: " NR
  split($0, lines, "\n")
  for (idx_line in lines) {
#     print "idx_line: " idx_line
#     print "lines[idx_line]: " lines[idx_line]
    split(lines[idx_line], fields, "	")
    field_len = length(fields)
    for (idx_field in fields) {
#       print "idx_field: " idx_field
#       print "fields[idx_field]: " fields[idx_field]
      field_info[idx_line,idx_field] = fields[idx_field]
#       print "field_info[idx_line,idx_field]: " field_info[idx_line,idx_field]
      if (idx_field == 1 && fields[idx_field] != "") {
        if (command_str) {
          command_str = command_str " or " fields[idx_field]
        } else {
          command_str = fields[idx_field]
        }
      }
      if (idx_field == field_len && index(fields[field_len], "*") == 0 ) {
#         print "field_len: " field_len
#         print "fields[field_len]: " fields[field_len]
        if (description_str) {
          description_str = description_str "\\n" fields[idx_field]
        } else {
          description_str = fields[idx_field]
        }
      }
    }
  }
#   print "command_str"
#   print command_str
#   print "description_str"
#   print description_str
  command_arr[NR] = command_str
  description_arr[NR] = description_str
#   print "==="
}

END {
  for (i = 1; i <= NR; i++) {
    print "[ '" command_arr[i] "', '" description_arr[i] "' ],"
  }
}


BEGIN {
  RS = ""
}

{
  command_str = ""
  description_str = ""
  split($0, lines, "\n")
  for (idx_line in lines) {
    split(lines[idx_line], fields, "	")
    field_len = length(fields)
    if (fields[1] != "") {
      if (command_str) {
        command_str = command_str " or " fields[1]
      } else {
        command_str = fields[1]
      }
    }
    if (index(fields[field_len], "*") == 0) {
      if (description_str) {
        description_str = description_str "\\n" fields[field_len]
      } else {
        description_str = fields[field_len]
      }
    }
  }
  command_arr[NR] = command_str
  description_arr[NR] = description_str
}

END {
  for (i = 1; i <= NR; i++) {
    print "[ \"" command_arr[i] "\", \"" description_arr[i] "\" ],"
  }
}

===


[ "h or <Left> or <BS>", "[count] characters to the left.  |exclusive| motion." ],
[ "l or <Right> or <Space>", "[count] characters to the right.  |exclusive| motion." ],
[ "0", "To the first character of the line.  |exclusive|\nmotion." ],
[ "<Home>", "To the first character of the line.  |exclusive|\nmotion." ],
[ "^", "To the first non-blank character of the line.\n|exclusive| motion.  Any count is ignored." ],
[ "$  or <End>", "To the end of the line.  |inclusive| motion." ],
[ "f{char}", "To [count]'th occurrence of {char} to the right.  The\ncursor is placed on {char} |inclusive|.\n{char} can be entered as a digraph |digraph-arg|.\nWhen 'encoding' is set to Unicode, composing\ncharacters may be used, see |utf-8-char-arg|.\n|:lmap| mappings apply to {char}.  The CTRL-^ command\nin Insert mode can be used to switch this on/off\n|i_CTRL-^|." ],
[ "F{char}", "To the [count]'th occurrence of {char} to the left.\nThe cursor is placed on {char} |exclusive|.\n{char} can be entered like with the |f| command." ],
[ "t{char}", "Till before [count]'th occurrence of {char} to the\nright.  The cursor is placed on the character left of\n{char} |inclusive|.\n{char} can be entered like with the |f| command." ],
[ "T{char}", "Till after [count]'th occurrence of {char} to the\nleft.  The cursor is placed on the character right of\n{char} |exclusive|.\n{char} can be entered like with the |f| command." ],
[ ";", "Repeat latest f, t, F or T [count] times. See |cpo-;|" ],
[ ",", "Repeat latest f, t, F or T in opposite direction\n[count] times. See also |cpo-;|" ],


===



h		or					*h*
<Left>		or					*<Left>*
CTRL-H		or					*CTRL-H* *<BS>*
<BS>			[count] characters to the left.  |exclusive| motion.

l		or					*l*
<Right>		or					*<Right>* *<Space>*
<Space>			[count] characters to the right.  |exclusive| motion.

							*0*
0			To the first character of the line.  |exclusive|
			motion.

							*<Home>* *<kHome>*
<Home>			To the first character of the line.  |exclusive|
			motion.

							*^*
^			To the first non-blank character of the line.
			|exclusive| motion.  Any count is ignored.

							*$* *<End>* *<kEnd>*
$  or <End>		To the end of the line.  |inclusive| motion.

							*f*
f{char}			To [count]'th occurrence of {char} to the right.  The
			cursor is placed on {char} |inclusive|.

							*F*
F{char}			To the [count]'th occurrence of {char} to the left.
			The cursor is placed on {char} |exclusive|.
			{char} can be entered like with the |f| command.

							*t*
t{char}			Till before [count]'th occurrence of {char} to the
			right.  The cursor is placed on the character left of
			{char} |inclusive|.
			{char} can be entered like with the |f| command.

							*T*
T{char}			Till after [count]'th occurrence of {char} to the
			left.  The cursor is placed on the character right of
			{char} |exclusive|.
			{char} can be entered like with the |f| command.

							*;*
;			Repeat latest f, t, F or T [count] times.

							*,*
,			Repeat latest f, t, F or T in opposite direction
			[count] times.

===

[ "h or <Left> or CTRL-H or <BS>", "[count] characters to the left.  |exclusive| motion." ],
[ "l or <Right> or <Space>", "[count] characters to the right.  |exclusive| motion." ],
[ "0", "To the first character of the line.  |exclusive|\nmotion." ],
[ "<Home>", "To the first character of the line.  |exclusive|\nmotion." ],
[ "^", "To the first non-blank character of the line.\n|exclusive| motion.  Any count is ignored." ],
[ "$  or <End>", "To the end of the line.  |inclusive| motion." ]

[ "f{char}", "To [count]'th occurrence of {char} to the right.  The\ncursor is placed on {char} |inclusive|." ],
[ "F{char}", "To the [count]'th occurrence of {char} to the left.\nThe cursor is placed on {char} |exclusive|.\n{char} can be entered like with the |f| command." ],
[ "t{char}", "Till before [count]'th occurrence of {char} to the\nright.  The cursor is placed on the character left of\n{char} |inclusive|.\n{char} can be entered like with the |f| command." ],
[ "T{char}", "Till after [count]'th occurrence of {char} to the\nleft.  The cursor is placed on the character right of\n{char} |exclusive|.\n{char} can be entered like with the |f| command." ],
[ ";", "Repeat latest f, t, F or T [count] times." ],
[ ",", "Repeat latest f, t, F or T in opposite direction\n[count] times." ]

===



[ "k or <Up> or CTRL-P", "[count] lines upward |linewise|." ],
[ "j or <Down> or CTRL-J or <NL> or CTRL-N", "[count] lines downward |linewise|." ],
[ "gk or g<Up>", "[count] display lines upward.  |exclusive| motion.\nDiffers from 'k' when lines wrap, and when used with\nan operator, because it's not linewise." ],
[ "gj or g<Down>", "[count] display lines downward.  |exclusive| motion.\nDiffers from 'j' when lines wrap, and when used with\nan operator, because it's not linewise." ],
[ "G", "Goto line [count], default last line, on the first\nnon-blank character |linewise|." ],
[ "<C-Home> or gg", "Goto line [count], default first line, on the first\nnon-blank character |linewise|." ],
[ "{count}%", "Go to {count} percentage in the file, on the first\nnon-blank in the line |linewise|." ]

===


[ "<S-Right> or w", "[count] words forward.  |exclusive| motion." ],
[ "<C-Right> or W", "[count] WORDS forward.  |exclusive| motion.\nIf <C-Right> does not work, check out\n|arrow_modifiers|." ],
[ "e", "Forward to the end of word [count] |inclusive|.\nDoes not stop in an empty line." ],
[ "E", "Forward to the end of WORD [count] |inclusive|.\nDoes not stop in an empty line." ],
[ "<S-Left> or b", "[count] words backward.  |exclusive| motion." ],
[ "<C-Left> or B", "[count] WORDS backward.  |exclusive| motion.\nIf <C-Left> does not work, check out\n|arrow_modifiers|." ],
[ "ge", "Backward to the end of word [count] |inclusive|." ],
[ "gE", "Backward to the end of WORD [count] |inclusive|." ],

===



<table border="1" cellspacing="0" cellpadding="5">
  <thead><tr><th>Command</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td>h, &lt;Left&gt;, CTRL-H</td><td>[count] characters to the left.  |exclusive| motion.<br>Note: If you prefer &lt;BS&gt; to delete a character, use<br>the mapping:<br>:map CTRL-V&lt;BS&gt; X<br>(to enter "CTRL-V&lt;BS&gt;" type the CTRL-V key, followed<br>by the &lt;BS&gt; key)<br>See |:fixdel| if the &lt;BS&gt; key does not do what you<br>want.</td></tr>
    <tr><td>l, &lt;Right&gt;, &lt;Space&gt;</td><td>[count] characters to the right.  |exclusive| motion.<br>See the 'whichwrap' option for adjusting the behavior<br>at end of line</td></tr>
    <tr><td>0</td><td>To the first character of the line.  |exclusive|<br>motion.</td></tr>
    <tr><td>&lt;Home&gt;</td><td>To the first character of the line.  |exclusive|<br>motion.  When moving up or down next, stay in same<br>TEXT column (if possible).  Most other commands stay<br>in the same SCREEN column.  &lt;Home&gt; works like "1|",<br>which differs from "0" when the line starts with a<br>&lt;Tab&gt;.</td></tr>
    <tr><td>^</td><td>To the first non-blank character of the line.<br>|exclusive| motion.  Any count is ignored.</td></tr>
    <tr><td>$, &lt;End&gt;</td><td>To the end of the line.  When a count is given also go<br>[count - 1] lines downward, or as far is possible.<br>|inclusive| motion.  If a count of 2 or larger is<br>given and the cursor is on the last line, that is an<br>error and the cursor doesn't move.<br>In Visual mode the cursor goes to just after the last<br>character in the line.<br>When 'virtualedit' is active, "$" may move the cursor<br>back from past the end of the line to the last<br>character in the line.</td></tr>
    <tr><td>g_</td><td>To the last non-blank character of the line and<br>[count - 1] lines downward |inclusive|.</td></tr>
  </tbody>
</table>

===



<table border="1" cellspacing="0" cellpadding="5">
  <thead><tr><th>Command</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td><S-Right> or w</td><td>[count] words forward.  |exclusive| motion.</td></tr>
    <tr><td><C-Right> or W</td><td>[count] WORDS forward.  |exclusive| motion.\nIf <C-Right> does not work, check out\n|arrow_modifiers|.</td></tr>
    <tr><td>e</td><td>Forward to the end of word [count] |inclusive|.\nDoes not stop in an empty line.</td></tr>
    <tr><td>E</td><td>Forward to the end of WORD [count] |inclusive|.\nDoes not stop in an empty line.</td></tr>
    <tr><td><S-Left> or b</td><td>[count] words backward.  |exclusive| motion.</td></tr>
    <tr><td><C-Left> or B</td><td>[count] WORDS backward.  |exclusive| motion.\nIf <C-Left> does not work, check out\n|arrow_modifiers|.</td></tr>
    <tr><td>ge</td><td>Backward to the end of word [count] |inclusive|.</td></tr>
    <tr><td>gE</td><td>Backward to the end of WORD [count] |inclusive|.</td></tr>
  </tbody>
</table>

```awk
BEGIN {
  RS = ""
  table_start_str = "<html>\n<head>\n    <style>\n        table, td {{ border: 1px solid black; border-collapse: collapse; padding: 5px; }}\n        table, th {{ border: 1px solid black; border-collapse: collapse; padding: 5px; }}\n    </style>\n</head>\n<body>\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"5\">\n  <thead><tr><th>Command</th><th>Description</th></tr></thead>\n  <tbody>"
  table_end_str = "  </tbody>\n</table>\n</body>\n</html>"
}

{
  command_str = ""
  description_str = ""
  split($0, lines, "\n")
  for (idx_line in lines) {
    split(lines[idx_line], fields, "	")
    field_len = length(fields)
    if (fields[1] != "") {
      if (command_str) {
        command_str = command_str " or " fields[1]
      } else {
        command_str = fields[1]
      }
    }
    if (index(fields[field_len], "*") == 0) {
      if (description_str) {
        description_str = description_str "\\n" fields[field_len]
      } else {
        description_str = fields[field_len]
      }
    }
  }
  command_arr[NR] = command_str
  description_arr[NR] = description_str
}

END {
  print table_start_str
  for (i = 1; i <= NR; i++) {
    gsub("<", "\\&lt;", command_arr[i])
    gsub(">", "\\&gt;", command_arr[i])
    gsub("<", "\\&lt;", description_arr[i])
    gsub(">", "\\&gt;", description_arr[i])
    gsub(/\\n/, "<br>", description_arr[i])
    print "    <tr><td>" command_arr[i] "</td><td>" description_arr[i] "</td></tr>"
  }
  print table_end_str
}
```


```pyproject.toml
[tool.poetry]
name = "pdf"
version = "0.1.0"
description = ""
authors = ["widehyo <widehyo@gmail.com>"]
readme = "README.md"

[tool.poetry.dependencies]
python = "^3.10"
weasyprint = "^65.1"


[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
```


```py
from weasyprint import HTML

HTML(filename='a.html').write_pdf('a.pdf')
print('done')
```


[user@Win11-01 UserK]$ history
    1  16:42:13 2025-05-08 yum
    2  16:42:13 2025-05-08 sudo yum update
    3  16:42:13 2025-05-08 sudo yum ungrade
    4  16:42:13 2025-05-08 sudo yum upgrade
    5  16:42:13 2025-05-08 sudo vim /etc/profile
    6  16:42:13 2025-05-08 exit
    7  16:42:13 2025-05-08 history
    8  16:42:13 2025-05-08 cat /etc/profile
    9  16:42:13 2025-05-08 sudo vim /etc/profile
   10  16:42:13 2025-05-08 exit
   11  16:42:13 2025-05-08 history
   12  16:42:13 2025-05-08 pwd
   13  16:42:13 2025-05-08 cd
   14  16:42:13 2025-05-08 pwd
   15  16:42:13 2025-05-08 history
   16  16:42:13 2025-05-08 exit
   17  16:42:13 2025-05-08 history
   18  16:42:13 2025-05-08 sudo vim /etc/profile
   19  16:42:13 2025-05-08 bash
   20  16:42:13 2025-05-08 exit
   21  16:42:13 2025-05-08 history
   22  16:42:13 2025-05-08 vi .vimrc
   23  16:42:13 2025-05-08 which $SHELL
   24  16:42:13 2025-05-08 vi .bashrc
   25  16:42:13 2025-05-08 exit
   26  16:42:13 2025-05-08 history
   27  16:42:13 2025-05-08 cat ~/.bashrc
   28  16:42:13 2025-05-08 cd
   29  16:42:13 2025-05-08 ls -al
   30  16:42:13 2025-05-08 vi .bashrc
   31  16:42:13 2025-05-08 cat /etc/profile
   32  16:42:13 2025-05-08 sudo vim /etc/profile
   33  16:42:13 2025-05-08 exit
   34  16:42:15 2025-05-08 history
   35  16:42:24 2025-05-08 dnf
   36  16:42:33 2025-05-08 sudo dnf update
   37  16:42:43 2025-05-08 sudo dnf upgrade
   38  16:42:49 2025-05-08 dnf search vim
   39  16:43:43 2025-05-08 vim --version
   40  16:43:51 2025-05-08 dnf search vim
   41  16:44:02 2025-05-08 sudo dnf install vim-X11
   42  16:44:40 2025-05-08 ll
   43  16:44:46 2025-05-08 vim --version
   44  16:44:53 2025-05-08 which vim
   45  16:45:05 2025-05-08 ls -al /usr/bin | grep vim
   46  16:45:28 2025-05-08 ls -al /usr/vim/gvim
   47  16:45:33 2025-05-08 ls -al /usr/bin/gvim
   48  16:45:39 2025-05-08 gvim
   49  16:46:11 2025-05-08 vimx
   50  16:46:17 2025-05-08 vimx --version
   51  16:46:29 2025-05-08 vi ~/.bashrc
   52  16:46:52 2025-05-08 source ~/.bashrc
   53  16:46:54 2025-05-08 vi
   54  16:47:04 2025-05-08 history
