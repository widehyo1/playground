function! GetLoadedBufferList()
  let l:buf_info = getbufinfo()
  let l:listed_buffer_info = l:buf_info
        \ ->filter({_, val -> val.listed == 1 })
        \ ->map({_, val -> {'bufnr': val.bufnr, 'name': val.name}})
  return l:listed_buffer_info
endfunction

function! GetSmithWatermanScore(search_word, buf_name)
  let l:tx = ' ' . a:search_word
  let l:ty = ' ' . a:buf_name

  " direction
  let l:up      = 0b001
  let l:left    = 0b010
  let l:upleft  = 0b100
  let l:default = 0b000

  let l:matrix = []
  let l:highest_scored_position_list = []
  let l:score = 0

  function! CalcElement(row, col, match = 3, mis_match = -3, gap_panalty = -2) closure
    " closure for calculate matrix element with free variables:
    " l:matrix, l:highest_scored_position_list, l:score, l:tx, l:ty
    " l:up, l:left, l:upleft, l:default

    " echo 'CalcElement (row: ' . a:row ', col: ' . a:col . ') len(l:matrix) is ' . len(l:matrix) . ' len(l:matrix[0]) is ' . len(l:matrix[0])

    if a:row == 0
      return 0
    elseif a:col == 0
      return 0
    endif

    let l:up_value = l:matrix[a:row - 1][a:col][0]
    let l:left_value = l:matrix[a:row][a:col - 1][0]
    let l:diag_value = l:matrix[a:row - 1][a:col - 1][0]

    let l:up_candidate = l:up_value + a:gap_panalty
    let l:left_candidate = l:left_value + a:gap_panalty

    let l:diag_candidate = l:diag_value + a:mis_match

    if l:tx[a:row] == l:ty[a:col]
      let l:diag_candidate = l:diag_value + a:match
    endif

    let l:element_value = max([l:up_candidate, l:left_candidate, l:diag_candidate])
    let l:element_direction = l:default

    if l:element_value < 0
      let l:matrix[a:row][a:col] = [0, 0]
      return 0
    endif

    if l:element_value == l:up_candidate
      let l:element_direction = or(l:element_direction, l:up)
    endif
    if l:element_value == l:left_candidate
      let l:element_direction = or(l:element_direction, l:left)
    endif
    if l:element_value == l:diag_candidate
      let l:element_direction = or(l:element_direction, l:upleft)
    endif

    let l:matrix[a:row][a:col] = [l:element_value, l:element_direction]

    if l:element_value > l:score
      if len(l:highest_scored_position_list) > 0
        call remove(l:highest_scored_position_list, 0, len(l:highest_scored_position_list)-1)
      endif
      call add(l:highest_scored_position_list, [a:row, a:col])
      return l:element_value
    elseif l:element_value == l:score
      call add(l:highest_scored_position_list, [a:row, a:col])
      return l:element_value
    else
      return l:score
    endif
  endfunction


  " initialize matrix
  for i in range(len(l:tx))
      let l:matrix_row = []
      for j in range(len(l:ty))
        call add(l:matrix_row, [0,0])
      endfor
      call add(l:matrix, l:matrix_row)
  endfor

  for i in range(len(l:tx))
    for j in range(len(l:ty))
      let l:score = CalcElement(i, j)
    endfor
  endfor

  let l:buf_name_position_list = []

  while len(l:highest_scored_position_list) > 0
    let l:cur_position = remove(l:highest_scored_position_list, -1)
    let [l:cur_row, l:cur_col] = l:cur_position
    let [l:cur_value, l:cur_direction] = l:matrix[l:cur_row][l:cur_col]

    if l:cur_value == 0
      break
    endif

    if and(l:cur_direction, l:up) > 0
      call add(l:highest_scored_position_list, [l:cur_row - 1, l:cur_col])
    endif
    if and(l:cur_direction, l:left) > 0
      call insert(l:buf_name_position_list, l:cur_col)
      call add(l:highest_scored_position_list, [l:cur_row, l:cur_col - 1])
    endif
    if and(l:cur_direction, l:upleft) > 0
      call insert(l:buf_name_position_list, l:cur_col)
      call add(l:highest_scored_position_list, [l:cur_row - 1, l:cur_col - 1])
    endif

    break
  endwhile

  let l:temp_reg = getreg('t')
  if match(l:temp_reg, '|flag1|') != -1
    call setreg('t', @t . '|flag2|' . l:score, 'a')
  else
    call setreg('t', @t . '#' . l:score . '|flag3|', 'a')
  endif

  return [l:score, l:buf_name_position_list]
endfunction

function! PopupBuffer()

  " Function to capture and echo the text in the search buffer
  function! CaptureSearchText() closure
    " Get the content of the search buffer
    let l:text = join(getline(1,1), '')
    " Echo the content to the command line
    let l:search_word = l:text
    " initialize temp register
    call setreg('t', l:text . '|flag1|')
    if l:search_word == ''
      call RedrawBufferList(l:buffer_info_list)
    else
      call SmithWaterman(l:search_word, l:buffer_info_list)
    endif
  endfunction

  function! SmithWaterman(search_word, buffer_info_list) closure
    " echo l:search_word
    let l:filtered_buffer_list = copy(a:buffer_info_list)
          \ ->filter({_, val -> GetSmithWatermanScore(a:search_word, val.name)[0] > 0})
    call RedrawBufferList(l:filtered_buffer_list)
  endfunction

  function! RedrawBufferList(buffers) closure
    if bufnr() != l:pop_bufnr
      return
    endif

    let l:header = []
    let l:lines = []
    for idx in range(len(a:buffers))
      let l:buffer = a:buffers[idx]
      let l:bufnr = l:buffer.bufnr
      let l:bufname = l:buffer.name
      call add(l:lines, l:bufname)
    endfor

    execute 'buffer' . l:pop_bufnr
    setlocal modifiable
    call setbufline(l:pop_bufnr, 1, l:header + l:lines)
    setlocal nomodifiable
  endfunction

  let l:search_word = ""
  let l:buffer_info_list = GetLoadedBufferList()

  new
  let l:pop_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal noswapfile
  setlocal nobuflisted
  setlocal nomodifiable
  resize 20

  new
  let l:search_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal filetype=search
  setlocal noswapfile
  setlocal nobuflisted
  resize 1

  " echo l:pop_bufnr . ' ' . ' ' . l:search_bufnr
  call RedrawBufferList(l:buffer_info_list)

  redraw

  " Create an autocommand for TextChangedI in the 'search' buffer
  autocmd TextChangedI <buffer> call CaptureSearchText()

endfunction


call PopupBuffer()

===


function! GetLoadedBufferList()
  let l:buf_info = getbufinfo()
  let l:listed_buffer_info = l:buf_info
        \ ->filter({_, val -> val.listed == 1 })
        \ ->map({_, val -> {'bufnr': val.bufnr, 'name': val.name}})
  return l:listed_buffer_info
endfunction

function! GetSmithWatermanScore(search_word, buf_name)
  let l:tx = ' ' . a:search_word
  let l:ty = ' ' . a:buf_name

  " direction
  let l:up      = 0b001
  let l:left    = 0b010
  let l:upleft  = 0b100
  let l:default = 0b000

  let l:matrix = []
  let l:highest_scored_position_list = []
  let l:score = 0

  function! CalcElement(row, col, match = 3, mis_match = -3, gap_panalty = -2) closure
    " closure for calculate matrix element with free variables:
    " l:matrix, l:highest_scored_position_list, l:score, l:tx, l:ty
    " l:up, l:left, l:upleft, l:default

    " echo 'CalcElement (row: ' . a:row ', col: ' . a:col . ') len(l:matrix) is ' . len(l:matrix) . ' len(l:matrix[0]) is ' . len(l:matrix[0])

    if a:row == 0
      return 0
    elseif a:col == 0
      return 0
    endif

    let l:up_value = l:matrix[a:row - 1][a:col][0]
    let l:left_value = l:matrix[a:row][a:col - 1][0]
    let l:diag_value = l:matrix[a:row - 1][a:col - 1][0]

    let l:up_candidate = l:up_value + a:gap_panalty
    let l:left_candidate = l:left_value + a:gap_panalty

    let l:diag_candidate = l:diag_value + a:mis_match

    if l:tx[a:row] == l:ty[a:col]
      let l:diag_candidate = l:diag_value + a:match
    endif

    let l:element_value = max([l:up_candidate, l:left_candidate, l:diag_candidate])
    let l:element_direction = l:default

    if l:element_value < 0
      let l:matrix[a:row][a:col] = [0, 0]
      return 0
    endif

    if l:element_value == l:up_candidate
      let l:element_direction = or(l:element_direction, l:up)
    endif
    if l:element_value == l:left_candidate
      let l:element_direction = or(l:element_direction, l:left)
    endif
    if l:element_value == l:diag_candidate
      let l:element_direction = or(l:element_direction, l:upleft)
    endif

    let l:matrix[a:row][a:col] = [l:element_value, l:element_direction]

    if l:element_value > l:score
      if len(l:highest_scored_position_list) > 0
        call remove(l:highest_scored_position_list, 0, len(l:highest_scored_position_list)-1)
      endif
      call add(l:highest_scored_position_list, [a:row, a:col])
      return l:element_value
    elseif l:element_value == l:score
      call add(l:highest_scored_position_list, [a:row, a:col])
      return l:element_value
    else
      return l:score
    endif
  endfunction


  " initialize matrix
  for i in range(len(l:tx))
      let l:matrix_row = []
      for j in range(len(l:ty))
        call add(l:matrix_row, [0,0])
      endfor
      call add(l:matrix, l:matrix_row)
  endfor

  for i in range(len(l:tx))
    for j in range(len(l:ty))
      let l:score = CalcElement(i, j)
    endfor
  endfor

  let l:buf_name_position_list = []

  while len(l:highest_scored_position_list) > 0
    let l:cur_position = remove(l:highest_scored_position_list, -1)
    let [l:cur_row, l:cur_col] = l:cur_position
    let [l:cur_value, l:cur_direction] = l:matrix[l:cur_row][l:cur_col]

    if l:cur_value == 0
      break
    endif

    if and(l:cur_direction, l:up) > 0
      call add(l:highest_scored_position_list, [l:cur_row - 1, l:cur_col])
    endif
    if and(l:cur_direction, l:left) > 0
      call insert(l:buf_name_position_list, l:cur_col)
      call add(l:highest_scored_position_list, [l:cur_row, l:cur_col - 1])
    endif
    if and(l:cur_direction, l:upleft) > 0
      call insert(l:buf_name_position_list, l:cur_col)
      call add(l:highest_scored_position_list, [l:cur_row - 1, l:cur_col - 1])
    endif

    break
  endwhile

  let l:temp_reg = getreg('t')
  if match(l:temp_reg, '|flag1|') != -1
    call setreg('t', a:search_word . '|' . l:score . '|flag2|')
  else
    call setreg('t', @t . '|' . l:score . '|flag3|', 'a')
  endif

  return [l:score, l:buf_name_position_list]
endfunction

function! PopupBuffer()

  " Function to capture and echo the text in the search buffer
  function! CaptureSearchText() closure
    " Get the content of the search buffer
    let l:text = join(getline(1,1), '')
    " Echo the content to the command line
    let l:search_word = l:text
    " initialize temp register
    call setreg('t', l:search_word . '|flag1|')
    if l:search_word == ''
      call RedrawBufferList(l:buffer_info_list)
    else
      call SmithWaterman(l:search_word, l:buffer_info_list)
    endif
  endfunction

  function! SmithWaterman(search_word, buffer_info_list) closure
    " echo l:search_word
    let l:filtered_buffer_list = copy(a:buffer_info_list)
          \ ->filter({_, val -> GetSmithWatermanScore(a:search_word, val.name)[0] > 0})
    call RedrawBufferList(l:filtered_buffer_list)
  endfunction

  function! RedrawBufferList(buffers) closure
    if bufnr() != l:pop_bufnr
      return
    endif

    let l:header = []
    let l:lines = []
    for idx in range(len(a:buffers))
      let l:buffer = a:buffers[idx]
      let l:bufnr = l:buffer.bufnr
      let l:bufname = l:buffer.name
      call add(l:lines, l:bufname)
    endfor

    execute 'buffer' . l:pop_bufnr
    setlocal modifiable
    call setbufline(l:pop_bufnr, 1, l:header + l:lines)
    setlocal nomodifiable
  endfunction

  let l:search_word = ""
  let l:buffer_info_list = GetLoadedBufferList()

  new
  let l:pop_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal noswapfile
  setlocal nobuflisted
  setlocal nomodifiable
  resize 20

  new
  let l:search_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal filetype=search
  setlocal noswapfile
  setlocal nobuflisted
  resize 1

  " echo l:pop_bufnr . ' ' . ' ' . l:search_bufnr
  call RedrawBufferList(l:buffer_info_list)

  redraw

  " Create an autocommand for TextChangedI in the 'search' buffer
  autocmd TextChangedI <buffer> call CaptureSearchText()

endfunction


call PopupBuffer()

===

  " initialize matrix
  for i in range(len(l:tx))
      let l:matrix_row = []
      for j in range(len(l:ty))
        let l:matrix_row += [0,0]
      endfor
      call add(l:matrix, l:matrix_row)
      let l:matrix += l:matrix_row
  endfor

===


function! GetLoadedBufferList()
  let l:buf_info = getbufinfo()
  let l:listed_buffer_info = l:buf_info
        \ ->filter({_, val -> val.listed == 1 })
        \ ->map({_, val -> {'bufnr': val.bufnr, 'name': val.name}})
  return l:listed_buffer_info
endfunction

function! GetSmithWatermanScore(search_word, buf_name)
  let l:tx = ' ' . a:search_word
  let l:ty = ' ' . a:buf_name

  " direction
  let l:up      = 0b001
  let l:left    = 0b010
  let l:upleft  = 0b100
  let l:default = 0b000

  let l:matrix = []
  let l:highest_scored_position_list = []
  let l:score = 0

  function! CalcElement(row, col, match = 3, mis_match = -3, gap_panalty = -2) closure
    " closure for calculate matrix element with free variables:
    " l:matrix, l:highest_scored_position_list, l:score, l:tx, l:ty
    " l:up, l:left, l:upleft, l:default

    " echo 'CalcElement (row: ' . a:row ', col: ' . a:col . ') len(l:matrix) is ' . len(l:matrix) . ' len(l:matrix[0]) is ' . len(l:matrix[0])

    if a:row == 0
      return 0
    elseif a:col == 0
      return 0
    endif

    let l:up_value = l:matrix[a:row - 1][a:col][0]
    let l:left_value = l:matrix[a:row][a:col - 1][0]
    let l:diag_value = l:matrix[a:row - 1][a:col - 1][0]

    let l:up_candidate = l:up_value + a:gap_panalty
    let l:left_candidate = l:left_value + a:gap_panalty

    let l:diag_candidate = l:diag_value + a:mis_match

    if l:tx[a:row] == l:ty[a:col]
      let l:diag_candidate = l:diag_value + a:match
    endif

    let l:element_value = max([l:up_candidate, l:left_candidate, l:diag_candidate])
    let l:element_direction = l:default

    if l:element_value < 0
      let l:matrix[a:row][a:col] = [0, 0]
      return 0
    endif

    if l:element_value == l:up_candidate
      let l:element_direction = or(l:element_direction, l:up)
    endif
    if l:element_value == l:left_candidate
      let l:element_direction = or(l:element_direction, l:left)
    endif
    if l:element_value == l:diag_candidate
      let l:element_direction = or(l:element_direction, l:upleft)
    endif

    let l:matrix[a:row][a:col] = [l:element_value, l:element_direction]

    if l:element_value > l:score
      if len(l:highest_scored_position_list) > 0
        call remove(l:highest_scored_position_list, 0, len(l:highest_scored_position_list)-1)
      endif
      call add(l:highest_scored_position_list, [a:row, a:col])
      return l:element_value
    elseif l:element_value == l:score
      call add(l:highest_scored_position_list, [a:row, a:col])
      return l:element_value
    else
      return l:score
    endif
  endfunction


  " initialize matrix
  for i in range(len(l:tx))
      let l:matrix_row = []
      for j in range(len(l:ty))
        let l:matrix_row += [0,0]
      endfor
      let l:matrix += l:matrix_row
  endfor

  for i in range(len(l:tx))
    for j in range(len(l:ty))
      let l:score = CalcElement(i, j)
    endfor
  endfor

  let l:buf_name_position_list = []

  while len(l:highest_scored_position_list) > 0
    let l:cur_position = remove(l:highest_scored_position_list, -1)
    let [l:cur_row, l:cur_col] = l:cur_position
    let [l:cur_value, l:cur_direction] = l:matrix[l:cur_row][l:cur_col]

    if l:cur_value == 0
      break
    endif

    if and(l:cur_direction, l:up) > 0
      let l:highest_scored_position_list += [l:cur_row - 1, l:cur_col]
    endif
    if and(l:cur_direction, l:left) > 0
      let l:buf_name_position_list = [l:cur_col] + l:buf_name_position_list
      let l:highest_scored_position_list += [l:cur_row, l:cur_col - 1]
    endif
    if and(l:cur_direction, l:upleft) > 0
      let l:buf_name_position_list = [l:cur_col] + l:buf_name_position_list
      let l:highest_scored_position_list += [l:cur_row - 1, l:cur_col - 1]
    endif

    break
  endwhile

  if @t == ''
    call setreg('t', l:score)
  else
    call setreg('t', '|' . l:score, 'a')
  endif

  return [l:score, l:buf_name_position_list]
endfunction

function! PopupBuffer()

  " Function to capture and echo the text in the search buffer
  function! CaptureSearchText() closure
    " Get the content of the search buffer
    let l:text = join(getline(1,1), '')
    " Echo the content to the command line
    let l:search_word = l:text
    " initialize temp register
    call setreg('t', '')
    if l:search_word == ''
      call RedrawBufferList(l:buffer_info_list)
    else
      call SmithWaterman(l:search_word, l:buffer_info_list)
    endif
  endfunction

  function! SmithWaterman(search_word, buffer_info_list) closure
    " echo l:search_word
    let l:filtered_buffer_list = copy(a:buffer_info_list)
          \ ->filter({_, val -> GetSmithWatermanScore(a:search_word, val.name)[0] > 0})
    call RedrawBufferList(l:filtered_buffer_list)
  endfunction

  function! RedrawBufferList(buffers) closure
    if bufnr() != l:pop_bufnr
      return
    endif

    let l:header = []
    let l:lines = []
    for idx in range(len(a:buffers))
      let l:buffer = a:buffers[idx]
      let l:bufnr = l:buffer.bufnr
      let l:bufname = l:buffer.name
      let l:lines += [l:bufname]
    endfor

    execute 'buffer' . l:pop_bufnr

    setlocal modifiable
    call setbufline(l:pop_bufnr, 1, l:header + l:lines)
    setlocal nomodifiable
  endfunction

  let l:search_word = ""
  let l:buffer_info_list = GetLoadedBufferList()

  new
  let l:pop_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal noswapfile
  setlocal nobuflisted
  setlocal nomodifiable
  resize 20

  new
  let l:search_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal filetype=search
  setlocal noswapfile
  setlocal nobuflisted
  resize 1

  " echo l:pop_bufnr . ' ' . ' ' . l:search_bufnr
  call RedrawBufferList(l:buffer_info_list)

  redraw

  " Create an autocommand for TextChangedI in the 'search' buffer
  autocmd TextChangedI <buffer> call CaptureSearchText()

endfunction


call PopupBuffer()


===


					*sub-replace-special* *:s\=*
When the {string} starts with "\=" it is evaluated as an expression, see
|sub-replace-expression|.  You can use that for complex replacement or special
characters.

Otherwise these characters in {string} have a special meaning:
								*:s%*
When {string} is equal to "%" and '/' is included with the 'cpoptions' option,
then the {string} of the previous substitute command is used, see |cpo-/|

magic	nomagic	  action    ~
  &	  \&	  replaced with the whole matched pattern	     *s/\&*
 \&	   &	  replaced with &
      \0	  replaced with the whole matched pattern	   *\0* *s/\0*
      \1	  replaced with the matched pattern in the first
		  pair of ()					     *s/\1*
      \2	  replaced with the matched pattern in the second
		  pair of ()					     *s/\2*
      ..	  ..						     *s/\3*
      \9	  replaced with the matched pattern in the ninth
		  pair of ()					     *s/\9*
  ~	  \~	  replaced with the {string} of the previous
		  substitute					     *s~*
 \~	   ~	  replaced with ~				     *s/\~*
      \u	  next character made uppercase			     *s/\u*
      \U	  following characters made uppercase, until \E      *s/\U*
      \l	  next character made lowercase			     *s/\l*
      \L	  following characters made lowercase, until \E      *s/\L*
      \e	  end of \u, \U, \l and \L (NOTE: not <Esc>!)	     *s/\e*
      \E	  end of \u, \U, \l and \L			     *s/\E*
      <CR>	  split line in two at this point
		  (Type the <CR> as CTRL-V <Enter>)		     *s<CR>*
      \r	  idem						     *s/\r*
      \<CR>	  insert a carriage-return (CTRL-M)
		  (Type the <CR> as CTRL-V <Enter>)		     *s/\<CR>*
      \n	  insert a <NL> (<NUL> in the file)
		  (does NOT break the line)			     *s/\n*
      \b	  insert a <BS>					     *s/\b*
      \t	  insert a <Tab>				     *s/\t*
      \\	  insert a single backslash			     *s/\\*
      \x	  where x is any character not mentioned above:
		  Reserved for future expansion

The special meaning is also used inside the third argument {sub} of
the |substitute()| function with the following exceptions:
  - A % inserts a percent literally without regard to 'cpoptions'.
  - magic is always set without regard to 'magic'.
  - A ~ inserts a tilde literally.
  - <CR> and \r inserts a carriage-return (CTRL-M).
  - \<CR> does not have a special meaning. It's just one of \x.

Examples: >
  :s/a\|b/xxx\0xxx/g		 modifies "a b"	     to "xxxaxxx xxxbxxx"
  :s/\([abc]\)\([efg]\)/\2\1/g	 modifies "af fa bg" to "fa fa gb"
  :s/abcde/abc^Mde/		 modifies "abcde"    to "abc", "de" (two lines)
  :s/$/\^M/			 modifies "abcde"    to "abcde^M"
  :s/\w\+/\u\0/g		 modifies "bla bla"  to "Bla Bla"
  :s/\w\+/\L\u\0/g		 modifies "BLA bla"  to "Bla Bla"

Note: "\L\u" can be used to capitalize the first letter of a word.  This is
not compatible with Vi and older versions of Vim, where the "\u" would cancel
out the "\L". Same for "\U\l".

Note: In previous versions CTRL-V was handled in a special way.  Since this is
not Vi compatible, this was removed.  Use a backslash instead.

command		text	result ~
:s/aa/a^Ma/	aa	a<line-break>a
:s/aa/a\^Ma/	aa	a^Ma
:s/aa/a\\^Ma/	aa	a\<line-break>a

(you need to type CTRL-V <CR> to get a ^M here)

The numbering of "\1", "\2" etc. is done based on which "\(" comes first in
the pattern (going left to right).  When a parentheses group matches several
times, the last one will be used for "\1", "\2", etc.  Example: >
  :s/\(\(a[a-d] \)*\)/\2/      modifies "aa ab x" to "ab x"
The "\2" is for "\(a[a-d] \)".  At first it matches "aa ", secondly "ab ".

When using parentheses in combination with '|', like in \([ab]\)\|\([cd]\),
either the first or second pattern in parentheses did not match, so either
\1 or \2 is empty.  Example: >
  :s/\([ab]\)\|\([cd]\)/\1x/g   modifies "a b c d"  to "ax bx x x"

===


nnoremap <leader><C-T> :echo @t<CR>

function! GetLoadedBufferList()
  let l:buf_info = getbufinfo()
  let l:listed_buffer_info = l:buf_info
        \ ->filter({_, val -> val.listed == 1 })
        \ ->map({_, val -> {'bufnr': val.bufnr, 'name': val.name}})
  return l:listed_buffer_info
endfunction

function! GetSmithWatermanScore(search_word, buf_name)
  let l:tx = ' ' . a:search_word
  let l:ty = ' ' . a:buf_name

  " direction
  let l:up      = 0b001
  let l:left    = 0b010
  let l:upleft  = 0b100
  let l:default = 0b000

  let l:matrix = []
  let l:highest_scored_position_list = []
  let l:score = 0

  function! CalcElement(row, col, match = 3, mis_match = -3, gap_panalty = -2) closure
    " closure for calculate matrix element with free variables:
    " l:matrix, l:highest_scored_position_list, l:score, l:tx, l:ty
    " l:up, l:left, l:upleft, l:default

    " echo 'CalcElement (row: ' . a:row ', col: ' . a:col . ') len(l:matrix) is ' . len(l:matrix) . ' len(l:matrix[0]) is ' . len(l:matrix[0])

    if a:row == 0
      return 0
    elseif a:col == 0
      return 0
    endif

    let l:up_value = l:matrix[a:row - 1][a:col][0]
    let l:left_value = l:matrix[a:row][a:col - 1][0]
    let l:diag_value = l:matrix[a:row - 1][a:col - 1][0]

    let l:up_candidate = l:up_value + a:gap_panalty
    let l:left_candidate = l:left_value + a:gap_panalty

    let l:diag_candidate = l:diag_value + a:mis_match

    if l:tx[a:row] == l:ty[a:col]
      let l:diag_candidate = l:diag_value + a:match
    endif

    let l:element_value = max([l:up_candidate, l:left_candidate, l:diag_candidate])
    let l:element_direction = l:default

    if l:element_value < 0
      let l:matrix[a:row][a:col] = [0, 0]
      call setreg('a', max([l:score, l:element_value]), 'a')
      return max([l:score, l:element_value])
    endif

    if l:element_value == l:up_candidate
      let l:element_direction = or(l:element_direction, l:up)
    endif
    if l:element_value == l:left_candidate
      let l:element_direction = or(l:element_direction, l:left)
    endif
    if l:element_value == l:diag_candidate
      let l:element_direction = or(l:element_direction, l:upleft)
    endif

    let l:matrix[a:row][a:col] = [l:element_value, l:element_direction]

    if l:element_value > l:score
      if len(l:highest_scored_position_list) > 0
        call remove(l:highest_scored_position_list, 0, len(l:highest_scored_position_list)-1)
      endif
      call add(l:highest_scored_position_list, [a:row, a:col])
      call setreg('a', max([l:score, l:element_value]), 'a')
      return max([l:score, l:element_value])
    elseif l:element_value == l:score
      call add(l:highest_scored_position_list, [a:row, a:col])
      call setreg('a', max([l:score, l:element_value]), 'a')
      return max([l:score, l:element_value])
    else
      call setreg('a', max([l:score, l:element_value]), 'a')
      return max([l:score, l:element_value])
    endif
  endfunction

  " initialize matrix
  for i in range(len(l:tx))
      let l:matrix_row = []
      for j in range(len(l:ty))
        call add(l:matrix_row, [0,0])
      endfor
      call add(l:matrix, l:matrix_row)
  endfor

  let @a = ''
  for i in range(len(l:tx))
    call setreg('a', l:tx[i] . '#', 'a')
    for j in range(len(l:ty))
      let l:score = CalcElement(i, j)
    endfor
  endfor
  call setreg('a', '||', 'a')

  let l:buf_name_position_list = []
  let @d = string(l:score)

  while len(l:highest_scored_position_list) > 0
    let l:cur_position = remove(l:highest_scored_position_list, -1)
    let [l:cur_row, l:cur_col] = l:cur_position
    let [l:cur_value, l:cur_direction] = l:matrix[l:cur_row][l:cur_col]

    if l:cur_value == 0
      break
    endif

    if and(l:cur_direction, l:up) > 0
      call add(l:highest_scored_position_list, [l:cur_row - 1, l:cur_col])
    endif
    if and(l:cur_direction, l:left) > 0
      call insert(l:buf_name_position_list, l:cur_col)
      call add(l:highest_scored_position_list, [l:cur_row, l:cur_col - 1])
    endif
    if and(l:cur_direction, l:upleft) > 0
      call insert(l:buf_name_position_list, l:cur_col)
      call add(l:highest_scored_position_list, [l:cur_row - 1, l:cur_col - 1])
    endif

    break
  endwhile

  let @b = string(l:buf_name_position_list)
  let @c = string(l:matrix)

  if @t == ''
    let @t = a:search_word . '#' . a:buf_name . '(' . l:score . ')'
  else
    call setreg('t', '|' . a:buf_name . '(' . l:score . ')', 'a')
  endif

  return [l:score, l:buf_name_position_list]
endfunction

function! PopupBuffer()

  " Function to capture and echo the text in the search buffer
  function! CaptureSearchText() closure
    " Get the content of the search buffer
    let l:text = join(getline(1,1), '')
    " Echo the content to the command line
    let l:search_word = l:text
    " initialize temp register
    let @t = ''
    if l:search_word == ''
      call RedrawBufferList(l:buffer_info_list)
    else
      call SmithWaterman(l:search_word, l:buffer_info_list)
    endif
  endfunction

  function! SmithWaterman(search_word, buffer_info_list) closure
    " echo l:search_word
    let l:filtered_buffer_list = copy(a:buffer_info_list)
          \ ->filter({_, val -> GetSmithWatermanScore(a:search_word, val.name)[0] > 0})
    call RedrawBufferList(l:filtered_buffer_list)
  endfunction

  function! RedrawBufferList(buffers) closure
    if bufnr() != l:pop_bufnr
      return
    endif

    let l:header = []
    let l:lines = []
    for idx in range(len(a:buffers))
      let l:buffer = a:buffers[idx]
      let l:bufnr = l:buffer.bufnr
      let l:bufname = l:buffer.name
      call add(l:lines, l:bufname)
    endfor

    execute 'buffer' . l:pop_bufnr
    setlocal modifiable
    call setbufline(l:pop_bufnr, 1, l:header + l:lines)
    setlocal nomodifiable
  endfunction

  let l:search_word = ''
  let l:buffer_info_list = GetLoadedBufferList()

  new
  let l:pop_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal noswapfile
  setlocal nobuflisted
  setlocal nomodifiable
  resize 20

  new
  let l:search_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal filetype=search
  setlocal noswapfile
  setlocal nobuflisted
  resize 1

  " echo l:pop_bufnr . ' ' . ' ' . l:search_bufnr
  call RedrawBufferList(l:buffer_info_list)

  redraw

  " Create an autocommand for TextChangedI in the 'search' buffer
  autocmd TextChangedI <buffer> call CaptureSearchText()

endfunction


call PopupBuffer()


>>> 문제는 다음 코드
continue로 처리해야 함

  function! CalcElement(row, col, match = 3, mis_match = -3, gap_panalty = -2) closure
    " closure for calculate matrix element with free variables:
    " l:matrix, l:highest_scored_position_list, l:score, l:tx, l:ty
    " l:up, l:left, l:upleft, l:default

    " echo 'CalcElement (row: ' . a:row ', col: ' . a:col . ') len(l:matrix) is ' . len(l:matrix) . ' len(l:matrix[0]) is ' . len(l:matrix[0])

    if a:row == 0
      return 0
    elseif a:col == 0
      return 0
    endif

===

range({expr} [, {max} [, {stride}]])				*range()*
		Returns a |List| with Numbers:
		- If only {expr} is specified: [0, 1, ..., {expr} - 1]
		- If {max} is specified: [{expr}, {expr} + 1, ..., {max}]
		- If {stride} is specified: [{expr}, {expr} + {stride}, ...,
		  {max}] (increasing {expr} with {stride} each time, not
		  producing a value past {max}).
		When the maximum is one before the start the result is an
		empty list.  When the maximum is more than one before the
		start this is an error.
		Examples: >
			range(4)		" [0, 1, 2, 3]
			range(2, 4)		" [2, 3, 4]
			range(2, 9, 3)		" [2, 5, 8]
			range(2, -2, -1)	" [2, 1, 0, -1, -2]
			range(0)		" []
			range(2, 0)		" error!

start와 end를 명시하면 end를 inclusive하게 포함하게 됨
=> index error의 원인

===


nnoremap <leader><C-T> :echo @t<CR>

function! GetLoadedBufferList()
  let l:buf_info = getbufinfo()
  let l:listed_buffer_info = l:buf_info
        \ ->filter({_, val -> val.listed == 1 })
        \ ->map({_, val -> {'bufnr': val.bufnr, 'name': val.name}})
  return l:listed_buffer_info
endfunction

function! GetSmithWatermanScore(search_word, buf_name)
  let l:tx = ' ' . a:search_word
  let l:ty = ' ' . a:buf_name

  " direction
  let l:up      = 0b001
  let l:left    = 0b010
  let l:upleft  = 0b100
  let l:default = 0b000

  let l:matrix = []
  let l:highest_scored_position_list = []
  let l:score = 0

  function! CalcElement(row, col, match = 3, mis_match = -3, gap_panalty = -2) closure
    " closure for calculate matrix element with free variables:
    " l:matrix, l:highest_scored_position_list, l:score, l:tx, l:ty
    " l:up, l:left, l:upleft, l:default

    echo 'CalcElement (row: ' . a:row ', col: ' . a:col . ') len(l:matrix) is ' . len(l:matrix) . ' len(l:matrix[0]) is ' . len(l:matrix[0])

    let l:up_value = l:matrix[a:row - 1][a:col][0]
    let l:left_value = l:matrix[a:row][a:col - 1][0]
    let l:diag_value = l:matrix[a:row - 1][a:col - 1][0]

    let l:up_candidate = l:up_value + a:gap_panalty
    let l:left_candidate = l:left_value + a:gap_panalty

    let l:diag_candidate = l:diag_value + a:mis_match

    if l:tx[a:row] == l:ty[a:col]
      let l:diag_candidate = l:diag_value + a:match
    endif

    let l:element_value = max([l:up_candidate, l:left_candidate, l:diag_candidate])
    let l:element_direction = l:default

    if l:element_value < 0
      let l:matrix[a:row][a:col] = [0, 0]
      call setreg('a', max([l:score, l:element_value]), 'a')
      return max([l:score, l:element_value])
    endif

    if l:element_value == l:up_candidate
      let l:element_direction = or(l:element_direction, l:up)
    endif
    if l:element_value == l:left_candidate
      let l:element_direction = or(l:element_direction, l:left)
    endif
    if l:element_value == l:diag_candidate
      let l:element_direction = or(l:element_direction, l:upleft)
    endif

    let l:matrix[a:row][a:col] = [l:element_value, l:element_direction]

    if l:element_value > l:score
      if len(l:highest_scored_position_list) > 0
        call remove(l:highest_scored_position_list, 0, len(l:highest_scored_position_list)-1)
      endif
      call add(l:highest_scored_position_list, [a:row, a:col])
      call setreg('a', max([l:score, l:element_value]), 'a')
      return max([l:score, l:element_value])
    elseif l:element_value == l:score
      call add(l:highest_scored_position_list, [a:row, a:col])
      call setreg('a', max([l:score, l:element_value]), 'a')
      return max([l:score, l:element_value])
    else
      call setreg('a', max([l:score, l:element_value]), 'a')
      return max([l:score, l:element_value])
    endif
  endfunction

  " initialize matrix
  for i in range(len(l:tx))
      let l:matrix_row = []
      for j in range(len(l:ty))
        call add(l:matrix_row, [0,0])
      endfor
      call add(l:matrix, l:matrix_row)
  endfor

  let @a = ''
  for i in range(1, len(a:search_word))
    call setreg('a', l:tx[i] . '#', 'a')
    for j in range(1, len(a:buf_name))
      let l:score = CalcElement(i, j)
    endfor
  endfor
  call setreg('a', '||', 'a')

  let l:buf_name_position_list = []
  let @d = string(l:score)

  while len(l:highest_scored_position_list) > 0
    let l:cur_position = remove(l:highest_scored_position_list, -1)
    let [l:cur_row, l:cur_col] = l:cur_position
    let [l:cur_value, l:cur_direction] = l:matrix[l:cur_row][l:cur_col]

    if l:cur_value == 0
      break
    endif

    if and(l:cur_direction, l:up) > 0
      call add(l:highest_scored_position_list, [l:cur_row - 1, l:cur_col])
    endif
    if and(l:cur_direction, l:left) > 0
      call insert(l:buf_name_position_list, l:cur_col)
      call add(l:highest_scored_position_list, [l:cur_row, l:cur_col - 1])
    endif
    if and(l:cur_direction, l:upleft) > 0
      call insert(l:buf_name_position_list, l:cur_col)
      call add(l:highest_scored_position_list, [l:cur_row - 1, l:cur_col - 1])
    endif

    break
  endwhile

  let @b = string(l:buf_name_position_list)
  let @c = string(l:matrix)

  if @t == ''
    let @t = a:search_word . '#' . a:buf_name . '(' . l:score . ')'
  else
    call setreg('t', '|' . a:buf_name . '(' . l:score . ')', 'a')
  endif

  return [l:score, l:buf_name_position_list]
endfunction

function! PopupBuffer()

  " Function to capture and echo the text in the search buffer
  function! CaptureSearchText() closure
    " Get the content of the search buffer
    let l:text = join(getline(1,1), '')
    " Echo the content to the command line
    let l:search_word = l:text
    " initialize temp register
    let @t = ''
    if l:search_word == ''
      call RedrawBufferList(l:buffer_info_list)
    else
      call SmithWaterman(l:search_word, l:buffer_info_list)
    endif
  endfunction

  function! SmithWaterman(search_word, buffer_info_list) closure
    " echo l:search_word
    let l:filtered_buffer_list = copy(a:buffer_info_list)
          \ ->filter({_, val -> GetSmithWatermanScore(a:search_word, val.name)[0] > 0})
    call RedrawBufferList(l:filtered_buffer_list)
  endfunction

  function! RedrawBufferList(buffers) closure
    if bufnr() != l:pop_bufnr
      return
    endif

    let l:header = []
    let l:lines = []
    for idx in range(len(a:buffers))
      let l:buffer = a:buffers[idx]
      let l:bufnr = l:buffer.bufnr
      let l:bufname = l:buffer.name
      call add(l:lines, l:bufname)
    endfor

    execute 'buffer' . l:pop_bufnr
    setlocal modifiable
    call setbufline(l:pop_bufnr, 1, l:header + l:lines)
    setlocal nomodifiable
  endfunction

  let l:search_word = ''
  let l:buffer_info_list = GetLoadedBufferList()

  new
  let l:pop_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal noswapfile
  setlocal nobuflisted
  setlocal nomodifiable
  resize 20

  new
  let l:search_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal filetype=search
  setlocal noswapfile
  setlocal nobuflisted
  resize 1

  " echo l:pop_bufnr . ' ' . ' ' . l:search_bufnr
  call RedrawBufferList(l:buffer_info_list)

  redraw

  " Create an autocommand for TextChangedI in the 'search' buffer
  autocmd TextChangedI <buffer> call CaptureSearchText()

endfunction


call PopupBuffer()

[{'bufnr': 1, 'name': '/home/widehyo/gitclone/playground/content_base/bundle/buffer_fzf.vim'}, {'bufnr': 6, 'name': '/home/widehyo/gitclone/playground/2025/03/22/20250322.md'}, {'bufnr': 7, 'name': '/home/widehyo/.vim/util/common.vim'}]



  let @a = string(a:buf_info)








[{"lnum": 1229, "bufnr": 1, "variables": {"current_syntax": "markdown", "undo_ftplugin": "setlocal commentstring< matchpairs< omnifunc< comments< formatoptions< | unlet! b:match_ignorecase b:match_skip b:match_words b:browsefilter|setl cms< com< fo< flp<", "changedtick": 6, "git_dir": "/home/widehyo/gitclone/playground/.git", "did_ftplugin": 1, "html_omni_flavor": "html401t", "airline_wordcount": "4,135 words ", "buffer_vcs_config": {"git": {"untracked": "Ɇ", "dirty": 1, "branch": "main"}, "mercurial": {"untracked": "", "dirty": 0, "branch": ""}}, "airline_changedtick": 6, "airline_head": "mainɆ", "airline_whitespace_check": "☲ [668]mixed-indent [653:2]mix-indent-file", "fugitive_name": ""}, "popups": [], "name": "/home/widehyo/gitclone/playground/2025/03/22/20250322.md", "changed": 1, "lastused": 1742629417, "loaded": 1, "windows": [1000], "hidden": 0, "listed": 1, "changedtick": 6, "linecount": 1229}, {"lnum": 0, "bufnr": 2, "variables": {"NERDTreeRoot": {"isCascadable": function("154"), "activate": function("135"), "getCascade": function("142"), "getChildIndex": function("147"), "path": {"copyingWillOverwrite": function("11"), "Resolve": function("35"), "drive": "", "isSymLink": 0, "createParentDirectories": function("12"), "extractDriveLetter": function("16"), "_strForGlob": function("44"), "getSortKey": function("24"), "cacheDisplayString": function("5"), "isUnixHiddenFile": function("26"), "flagSet": {"clearFlags": function("211"), "_flagsForScope": function("212"), "addFlag": function("210"), "removeFlag": function("214"), "renderToString": function("215"), "_flags": {}, "New": function("213")}, "rename": function("39"), "pathSegments": ["home", "widehyo", "gitclone", "playground", "content_base", "bundle"], "refresh": function("37"), "Create": function("8"), "AbsolutePathFor": function("3"), "getDir": function("19"), "isReadOnly": 0, "changeToDir": function("7"), "delete": function("13"), "_splitChunks": function("23"), "exists": function("17"), "cachedDisplayString": "", "New": function("34"), "_strForUI": function("41"), "_strForCd": function("42"), "copy": function("9"), "isUnder": function("31"), "ignore": function("28"), "strTrunk": function("46"), "getSortOrderIndex": function("22"), "displayString": function("14"), "isHiddenUnder": function("25"), "edit": function("15"), "isAncestor": function("30"), "isUnixHiddenPath": function("27"), "tabnr": function("47"), "bookmarkNames": function("4"), "readInfoFromDisk": function("36"), "str": function("40"), "_ignorePatternMatches": function("29"), "equals": function("33"), "_strForEdit": function("43"), "getParent": function("20"), "CopyingSupported": function("10"), "addDelimiter": function("6"), "_escChars": function("18"), "getLastPathComponent": function("21"), "isDirectory": 1, "isExecutable": 0, "JoinPathStrings": function("32"), "_str": function("45"), "WinToUnixPath": function("48"), "refreshFlags": function("38")}, "renderToString": function("132"), "reveal": function("166"), "refresh": function("163"), "getDirChildren": function("148"), "getCascadeRoot": function("143"), "openInNewTab": function("160"), "getVisibleChildCount": function("151"), "transplantChild": function("170"), "openExplorer": function("159"), "isOpen": 1, "isVisible": function("120"), "addChild": function("136"), "toggleOpen": function("169"), "close": function("137"), "delete": function("112"), "_renderToString": function("133"), "openSplit": function("124"), "_glob": function("149"), "getVisibleChildren": function("152"), "sortChildren": function("168"), "AbsoluteTreeRoot": function("134"), "openVSplit": function("125"), "New": function("156"), "refreshDirFlags": function("165"), "_initChildren": function("155"), "GetRootForTab": function("118"), "copy": function("111"), "GetSelected": function("150"), "isRoot": function("121"), "openAlong": function("158"), "rename": function("131"), "displayString": function("140"), "cacheParent": function("109"), "getChildByIndex": function("146"), "findNode": function("141"), "bookmark": function("108"), "removeChild": function("167"), "getChild": function("145"), "openRecursively": function("162"), "equals": function("114"), "_openInNewTab": function("161"), "children": [{"isRoot": function("121"), "rename": function("131"), "activate": function("107"), "clearBookmarks": function("110"), "displayString": function("113"), "cacheParent": function("109"), "delete": function("112"), "bookmark": function("108"), "findNode": function("115"), "_renderToString": function("133"), "openSplit": function("124"), "openInNewTab": function("126"), "findSibling": function("116"), "renderToString": function("132"), "openExplorer": function("127"), "getNerdtree": function("117"), "parent": "", "_nerdtree": {"root": "", "ForCurrentTab": function("224"), "GetWinNum": function("226"), "CursorToTreeWin": function("220"), "CursorToBookmarkTable": function("219"), "changeRoot": function("217"), "ui": {"_showHidden": 0, "restoreScreenState": function("253"), "_showFiles": 1, "setShowHidden": function("255"), "getRootLineNum": function("241"), "_showFileLines": 0, "getShowFileLines": function("246"), "_showHelp": 0, "IndentWid": function("248"), "getPath": function("239"), "_ignoreEnabled": 1, "centerView": function("236"), "getShowFiles": function("243"), "getShowHelp": function("244"), "toggleShowFileLines": function("264"), "_showBookmarks": 0, "renderViewSavingPosition": function("258"), "getShowBookmarks": function("242"), "toggleZoom": function("265"), "saveScreenState": function("254"), "_renderBookmarks": function("252"), "_dumpHelp": function("237"), "isIgnoreFilterEnabled": function("249"), "toggleShowBookmarks": function("261"), "nerdtree": "", "_stripMarkup": function("256"), "getLineNum": function("240"), "toggleShowHidden": function("263"), "New": function("238"), "toggleHelp": function("259"), "toggleIgnoreFilter": function("260"), "_indentLevelFor": function("247"), "render": function("257"), "getShowHidden": function("245"), "MarkupReg": function("251"), "UpDirLine": function("266"), "isMinimal": function("250"), "toggleShowFiles": function("262")}, "setPreviousBuf": function("234"), "_type": "tab", "PathFilters": function("232"), "ExistsForBuf": function("221"), "previousBuf": function("233"), "ForCurrentBuf": function("223"), "MustBeOpen": function("230"), "New": function("231"), "isTabTree": function("228"), "render": function("235"), "AddPathFilter": function("216"), "IsOpen": function("227"), "ExistsForTab": function("222"), "getRoot": function("225"), "Close": function("218"), "isWinTree": function("229")}, "openVSplit": function("125"), "New": function("122"), "putCursorHere": function("128"), "equals": function("114"), "GetRootForTab": function("118"), "copy": function("111"), "GetSelected": function("119"), "refresh": function("129"), "refreshFlags": function("130"), "open": function("123"), "isVisible": function("120"), "path": {"copyingWillOverwrite": function("11"), "Resolve": function("35"), "drive": "", "isSymLink": 0, "createParentDirectories": function("12"), "extractDriveLetter": function("16"), "_strForGlob": function("44"), "getSortKey": function("24"), "cacheDisplayString": function("5"), "isUnixHiddenFile": function("26"), "flagSet": {"clearFlags": function("211"), "_flagsForScope": function("212"), "addFlag": function("210"), "removeFlag": function("214"), "renderToString": function("215"), "_flags": {}, "New": function("213")}, "rename": function("39"), "pathSegments": ["home", "widehyo", "gitclone", "playground", "content_base", "bundle", "buffer_fzf.vim"], "refresh": function("37"), "Create": function("8"), "AbsolutePathFor": function("3"), "getDir": function("19"), "isReadOnly": 0, "changeToDir": function("7"), "delete": function("13"), "_bookmarkNames": [], "_splitChunks": function("23"), "_sortKey": [1, "buffer_fzf.vim"], "exists": function("17"), "cachedDisplayString": "^Gbuffer_fzf.vim", "New": function("34"), "_strForUI": function("41"), "_strForCd": function("42"), "copy": function("9"), "isUnder": function("31"), "ignore": function("28"), "strTrunk": function("46"), "getSortOrderIndex": function("22"), "displayString": function("14"), "isHiddenUnder": function("25"), "edit": function("15"), "isAncestor": function("30"), "isUnixHiddenPath": function("27"), "tabnr": function("47"), "bookmarkNames": function("4"), "readInfoFromDisk": function("36"), "str": function("40"), "_ignorePatternMatches": function("29"), "equals": function("33"), "_strForEdit": function("43"), "getParent": function("20"), "CopyingSupported": function("10"), "addDelimiter": function("6"), "_escChars": function("18"), "getLastPathComponent": function("21"), "isDirectory": 0, "isExecutable": 0, "JoinPathStrings": function("32"), "_str": function("45"), "WinToUnixPath": function("48"), "refreshFlags": function("38")}}, {"isRoot": function("121"), "rename": function("131"), "activate": function("107"), "clearBookmarks": function("110"), "displayString": function("113"), "cacheParent": function("109"), "delete": function("112"), "bookmark": function("108"), "findNode": function("115"), "_renderToString": function("133"), "openSplit": function("124"), "openInNewTab": function("126"), "findSibling": function("116"), "renderToString": function("132"), "openExplorer": function("127"), "getNerdtree": function("117"), "parent": "", "_nerdtree": "", "openVSplit": function("125"), "New": function("122"), "putCursorHere": function("128"), "equals": function("114"), "GetRootForTab": function("118"), "copy": function("111"), "GetSelected": function("119"), "refresh": function("129"), "refreshFlags": function("130"), "open": function("123"), "isVisible": function("120"), "path": {"copyingWillOverwrite": function("11"), "Resolve": function("35"), "drive": "", "isSymLink": 0, "createParentDirectories": function("12"), "extractDriveLetter": function("16"), "_strForGlob": function("44"), "getSortKey": function("24"), "cacheDisplayString": function("5"), "isUnixHiddenFile": function("26"), "flagSet": {"clearFlags": function("211"), "_flagsForScope": function("212"), "addFlag": function("210"), "removeFlag": function("214"), "renderToString": function("215"), "_flags": {}, "New": function("213")}, "rename": function("39"), "pathSegments": ["home", "widehyo", "gitclone", "playground", "content_base", "bundle", "longest_common_subsequence.py"], "refresh": function("37"), "Create": function("8"), "AbsolutePathFor": function("3"), "getDir": function("19"), "isReadOnly": 0, "changeToDir": function("7"), "delete": function("13"), "_bookmarkNames": [], "_splitChunks": function("23"), "_sortKey": [1, "longest_common_subsequence.py"], "exists": function("17"), "cachedDisplayString": "^Glongest_common_subsequence.py", "New": function("34"), "_strForUI": function("41"), "_strForCd": function("42"), "copy": function("9"), "isUnder": function("31"), "ignore": function("28"), "strTrunk": function("46"), "getSortOrderIndex": function("22"), "displayString": function("14"), "isHiddenUnder": function("25"), "edit": function("15"), "isAncestor": function("30"), "isUnixHiddenPath": function("27"), "tabnr": function("47"), "bookmarkNames": function("4"), "readInfoFromDisk": function("36"), "str": function("40"), "_ignorePatternMatches": function("29"), "equals": function("33"), "_strForEdit": function("43"), "getParent": function("20"), "CopyingSupported": function("10"), "addDelimiter": function("6"), "_escChars": function("18"), "getLastPathComponent": function("21"), "isDirectory": 0, "isExecutable": 0, "JoinPathStrings": function("32"), "_str": function("45"), "WinToUnixPath": function("48"), "refreshFlags": function("38")}}, {"isRoot": function("121"), "rename": function("131"), "activate": function("107"), "clearBookmarks": function("110"), "displayString": function("113"), "cacheParent": function("109"), "delete": function("112"), "bookmark": function("108"), "findNode": function("115"), "_renderToString": function("133"), "openSplit": function("124"), "openInNewTab": function("126"), "findSibling": function("116"), "renderToString": function("132"), "openExplorer": function("127"), "getNerdtree": function("117"), "parent": "", "_nerdtree": "", "openVSplit": function("125"), "New": function("122"), "putCursorHere": function("128"), "equals": function("114"), "GetRootForTab": function("118"), "copy": function("111"), "GetSelected": function("119"), "refresh": function("129"), "refreshFlags": function("130"), "open": function("123"), "isVisible": function("120"), "path": {"copyingWillOverwrite": function("11"), "Resolve": function("35"), "drive": "", "isSymLink": 0, "createParentDirectories": function("12"), "extractDriveLetter": function("16"), "_strForGlob": function("44"), "getSortKey": function("24"), "cacheDisplayString": function("5"), "isUnixHiddenFile": function("26"), "flagSet": {"clearFlags": function("211"), "_flagsForScope": function("212"), "addFlag": function("210"), "removeFlag": function("214"), "renderToString": function("215"), "_flags": {}, "New": function("213")}, "rename": function("39"), "pathSegments": ["home", "widehyo", "gitclone", "playground", "content_base", "bundle", "longest_common_subsequence.vim"], "refresh": function("37"), "Create": function("8"), "AbsolutePathFor": function("3"), "getDir": function("19"), "isReadOnly": 0, "changeToDir": function("7"), "delete": function("13"), "_bookmarkNames": [], "_splitChunks": function("23"), "_sortKey": [1, "longest_common_subsequence.vim"], "exists": function("17"), "cachedDisplayString": "^Glongest_common_subsequence.vim", "New": function("34"), "_strForUI": function("41"), "_strForCd": function("42"), "copy": function("9"), "isUnder": function("31"), "ignore": function("28"), "strTrunk": function("46"), "getSortOrderIndex": function("22"), "displayString": function("14"), "isHiddenUnder": function("25"), "edit": function("15"), "isAncestor": function("30"), "isUnixHiddenPath": function("27"), "tabnr": function("47"), "bookmarkNames": function("4"), "readInfoFromDisk": function("36"), "str": function("40"), "_ignorePatternMatches": function("29"), "equals": function("33"), "_strForEdit": function("43"), "getParent": function("20"), "CopyingSupported": function("10"), "addDelimiter": function("6"), "_escChars": function("18"), "getLastPathComponent": function("21"), "isDirectory": 0, "isExecutable": 0, "JoinPathStrings": function("32"), "_str": function("45"), "WinToUnixPath": function("48"), "refreshFlags": function("38")}}, {"isRoot": function("121"), "rename": function("131"), "activate": function("107"), "clearBookmarks": function("110"), "displayString": function("113"), "cacheParent": function("109"), "delete": function("112"), "bookmark": function("108"), "findNode": function("115"), "_renderToString": function("133"), "openSplit": function("124"), "openInNewTab": function("126"), "findSibling": function("116"), "renderToString": function("132"), "openExplorer": function("127"), "getNerdtree": function("117"), "parent": "", "_nerdtree": "", "openVSplit": function("125"), "New": function("122"), "putCursorHere": function("128"), "equals": function("114"), "GetRootForTab": function("118"), "copy": function("111"), "GetSelected": function("119"), "refresh": function("129"), "refreshFlags": function("130"), "open": function("123"), "isVisible": function("120"), "path": {"copyingWillOverwrite": function("11"), "Resolve": function("35"), "drive": "", "isSymLink": 0, "createParentDirectories": function("12"), "extractDriveLetter": function("16"), "_strForGlob": function("44"), "getSortKey": function("24"), "cacheDisplayString": function("5"), "isUnixHiddenFile": function("26"), "flagSet": {"clearFlags": function("211"), "_flagsForScope": function("212"), "addFlag": function("210"), "removeFlag": function("214"), "renderToString": function("215"), "_flags": {}, "New": function("213")}, "rename": function("39"), "pathSegments": ["home", "widehyo", "gitclone", "playground", "content_base", "bundle", "LongestCommonSubsequence.jar"], "refresh": function("37"), "Create": function("8"), "AbsolutePathFor": function("3"), "getDir": function("19"), "isReadOnly": 0, "changeToDir": function("7"), "delete": function("13"), "_bookmarkNames": [], "_splitChunks": function("23"), "_sortKey": [1, "longestcommonsubsequence.jar"], "exists": function("17"), "cachedDisplayString": "^GLongestCommonSubsequence.jar", "New": function("34"), "_strForUI": function("41"), "_strForCd": function("42"), "copy": function("9"), "isUnder": function("31"), "ignore": function("28"), "strTrunk": function("46"), "getSortOrderIndex": function("22"), "displayString": function("14"), "isHiddenUnder": function("25"), "edit": function("15"), "isAncestor": function("30"), "isUnixHiddenPath": function("27"), "tabnr": function("47"), "bookmarkNames": function("4"), "readInfoFromDisk": function("36"), "str": function("40"), "_ignorePatternMatches": function("29"), "equals": function("33"), "_strForEdit": function("43"), "getParent": function("20"), "CopyingSupported": function("10"), "addDelimiter": function("6"), "_escChars": function("18"), "getLastPathComponent": function("21"), "isDirectory": 0, "isExecutable": 0, "JoinPathStrings": function("32"), "_str": function("45"), "WinToUnixPath": function("48"), "refreshFlags": function("38")}}, {"isRoot": function("121"), "rename": function("131"), "activate": function("107"), "clearBookmarks": function("110"), "displayString": function("113"), "cacheParent": function("109"), "delete": function("112"), "bookmark": function("108"), "findNode": function("115"), "_renderToString": function("133"), "openSplit": function("124"), "openInNewTab": function("126"), "findSibling": function("116"), "renderToString": function("132"), "openExplorer": function("127"), "getNerdtree": function("117"), "parent": "", "_nerdtree": "", "openVSplit": function("125"), "New": function("122"), "putCursorHere": function("128"), "equals": function("114"), "GetRootForTab": function("118"), "copy": function("111"), "GetSelected": function("119"), "refresh": function("129"), "refreshFlags": function("130"), "open": function("123"), "isVisible": function("120"), "path": {"copyingWillOverwrite": function("11"), "Resolve": function("35"), "drive": "", "isSymLink": 0, "createParentDirectories": function("12"), "extractDriveLetter": function("16"), "_strForGlob": function("44"), "getSortKey": function("24"), "cacheDisplayString": function("5"), "isUnixHiddenFile": function("26"), "flagSet": {"clearFlags": function("211"), "_flagsForScope": function("212"), "addFlag": function("210"), "removeFlag": function("214"), "renderToString": function("215"), "_flags": {}, "New": function("213")}, "rename": function("39"), "pathSegments": ["home", "widehyo", "gitclone", "playground", "content_base", "bundle", "LongestCommonSubsequence.kt"], "refresh": function("37"), "Create": function("8"), "AbsolutePathFor": function("3"), "getDir": function("19"), "isReadOnly": 0, "changeToDir": function("7"), "delete": function("13"), "_bookmarkNames": [], "_splitChunks": function("23"), "_sortKey": [1, "longestcommonsubsequence.kt"], "exists": function("17"), "cachedDisplayString": "^GLongestCommonSubsequence.kt", "New": function("34"), "_strForUI": function("41"), "_strForCd": function("42"), "copy": function("9"), "isUnder": function("31"), "ignore": function("28"), "strTrunk": function("46"), "getSortOrderIndex": function("22"), "displayString": function("14"), "isHiddenUnder": function("25"), "edit": function("15"), "isAncestor": function("30"), "isUnixHiddenPath": function("27"), "tabnr": function("47"), "bookmarkNames": function("4"), "readInfoFromDisk": function("36"), "str": function("40"), "_ignorePatternMatches": function("29"), "equals": function("33"), "_strForEdit": function("43"), "getParent": function("20"), "CopyingSupported": function("10"), "addDelimiter": function("6"), "_escChars": function("18"), "getLastPathComponent": function("21"), "isDirectory": 0, "isExecutable": 0, "JoinPathStrings": function("32"), "_str": function("45"), "WinToUnixPath": function("48"), "refreshFlags": function("38")}}, {"isRoot": function("121"), "rename": function("131"), "activate": function("107"), "clearBookmarks": function("110"), "displayString": function("113"), "cacheParent": function("109"), "delete": function("112"), "bookmark": function("108"), "findNode": function("115"), "_renderToString": function("133"), "openSplit": function("124"), "openInNewTab": function("126"), "findSibling": function("116"), "renderToString": function("132"), "openExplorer": function("127"), "getNerdtree": function("117"), "parent": "", "_nerdtree": "", "openVSplit": function("125"), "New": function("122"), "putCursorHere": function("128"), "equals": function("114"), "GetRootForTab": function("118"), "copy": function("111"), "GetSelected": function("119"), "refresh": function("129"), "refreshFlags": function("130"), "open": function("123"), "isVisible": function("120"), "path": {"copyingWillOverwrite": function("11"), "Resolve": function("35"), "drive": "", "isSymLink": 0, "createParentDirectories": function("12"), "extractDriveLetter": function("16"), "_strForGlob": function("44"), "getSortKey": function("24"), "cacheDisplayString": function("5"), "isUnixHiddenFile": function("26"), "flagSet": {"clearFlags": function("211"), "_flagsForScope": function("212"), "addFlag": function("210"), "removeFlag": function("214"), "renderToString": function("215"), "_flags": {}, "New": function("213")}, "rename": function("39"), "pathSegments": ["home", "widehyo", "gitclone", "playground", "content_base", "bundle", "needleman_wunsch.py"], "refresh": function("37"), "Create": function("8"), "AbsolutePathFor": function("3"), "getDir": function("19"), "isReadOnly": 0, "changeToDir": function("7"), "delete": function("13"), "_bookmarkNames": [], "_splitChunks": function("23"), "_sortKey": [1, "needleman_wunsch.py"], "exists": function("17"), "cachedDisplayString": "^Gneedleman_wunsch.py", "New": function("34"), "_strForUI": function("41"), "_strForCd": function("42"), "copy": function("9"), "isUnder": function("31"), "ignore": function("28"), "strTrunk": function("46"), "getSortOrderIndex": function("22"), "displayString": function("14"), "isHiddenUnder": function("25"), "edit": function("15"), "isAncestor": function("30"), "isUnixHiddenPath": function("27"), "tabnr": function("47"), "bookmarkNames": function("4"), "readInfoFromDisk": function("36"), "str": function("40"), "_ignorePatternMatches": function("29"), "equals": function("33"), "_strForEdit": function("43"), "getParent": function("20"), "CopyingSupported": function("10"), "addDelimiter": function("6"), "_escChars": function("18"), "getLastPathComponent": function("21"), "isDirectory": 0, "isExecutable": 0, "JoinPathStrings": function("32"), "_str": function("45"), "WinToUnixPath": function("48"), "refreshFlags": function("38")}}, {"isRoot": function("121"), "rename": function("131"), "activate": function("107"), "clearBookmarks": function("110"), "displayString": function("113"), "cacheParent": function("109"), "delete": function("112"), "bookmark": function("108"), "findNode": function("115"), "_renderToString": function("133"), "openSplit": function("124"), "openInNewTab": function("126"), "findSibling": function("116"), "renderToString": function("132"), "openExplorer": function("127"), "getNerdtree": function("117"), "parent": "", "_nerdtree": "", "openVSplit": function("125"), "New": function("122"), "putCursorHere": function("128"), "equals": function("114"), "GetRootForTab": function("118"), "copy": function("111"), "GetSelected": function("119"), "refresh": function("129"), "refreshFlags": function("130"), "open": function("123"), "isVisible": function("120"), "path": {"copyingWillOverwrite": function("11"), "Resolve": function("35"), "drive": "", "isSymLink": 0, "createParentDirectories": function("12"), "extractDriveLetter": function("16"), "_strForGlob": function("44"), "getSortKey": function("24"), "cacheDisplayString": function("5"), "isUnixHiddenFile": function("26"), "flagSet": {"clearFlags": function("211"), "_flagsForScope": function("212"), "addFlag": function("210"), "removeFlag": function("214"), "renderToString": function("215"), "_flags": {}, "New": function("213")}, "rename": function("39"), "pathSegments": ["home", "widehyo", "gitclone", "playground", "content_base", "bundle", "NeedlemanWunsch.jar"], "refresh": function("37"), "Create": function("8"), "AbsolutePathFor": function("3"), "getDir": function("19"), "isReadOnly": 0, "changeToDir": function("7"), "delete": function("13"), "_bookmarkNames": [], "_splitChunks": function("23"), "_sortKey": [1, "needlemanwunsch.jar"], "exists": function("17"), "cachedDisplayString": "^GNeedlemanWunsch.jar", "New": function("34"), "_strForUI": function("41"), "_strForCd": function("42"), "copy": function("9"), "isUnder": function("31"), "ignore": function("28"), "strTrunk": function("46"), "getSortOrderIndex": function("22"), "displayString": function("14"), "isHiddenUnder": function("25"), "edit": function("15"), "isAncestor": function("30"), "isUnixHiddenPath": function("27"), "tabnr": function("47"), "bookmarkNames": function("4"), "readInfoFromDisk": function("36"), "str": function("40"), "_ignorePatternMatches": function("29"), "equals": function("33"), "_strForEdit": function("43"), "getParent": function("20"), "CopyingSupported": function("10"), "addDelimiter": function("6"), "_escChars": function("18"), "getLastPathComponent": function("21"), "isDirectory": 0, "isExecutable": 0, "JoinPathStrings": function("32"), "_str": function("45"), "WinToUnixPath": function("48"), "refreshFlags": function("38")}}, {"isRoot": function("121"), "rename": function("131"), "activate": function("107"), "clearBookmarks": function("110"), "displayString": function("113"), "cacheParent": function("109"), "delete": function("112"), "bookmark": function("108"), "findNode": function("115"), "_renderToString": function("133"), "openSplit": function("124"), "openInNewTab": function("126"), "findSibling": function("116"), "renderToString": function("132"), "openExplorer": function("127"), "getNerdtree": function("117"), "parent": "", "_nerdtree": "", "openVSplit": function("125"), "New": function("122"), "putCursorHere": function("128"), "equals": function("114"), "GetRootForTab": function("118"), "copy": function("111"), "GetSelected": function("119"), "refresh": function("129"), "refreshFlags": function("130"), "open": function("123"), "isVisible": function("120"), "path": {"copyingWillOverwrite": function("11"), "Resolve": function("35"), "drive": "", "isSymLink": 0, "createParentDirectories": function("12"), "extractDriveLetter": function("16"), "_strForGlob": function("44"), "getSortKey": function("24"), "cacheDisplayString": function("5"), "isUnixHiddenFile": function("26"), "flagSet": {"clearFlags": function("211"), "_flagsForScope": function("212"), "addFlag": function("210"), "removeFlag": function("214"), "renderToString": function("215"), "_flags": {}, "New": function("213")}, "rename": function("39"), "pathSegments": ["home", "widehyo", "gitclone", "playground", "content_base", "bundle", "NeedlemanWunsch.kt"], "refresh": function("37"), "Create": function("8"), "AbsolutePathFor": function("3"), "getDir": function("19"), "isReadOnly": 0, "changeToDir": function("7"), "delete": function("13"), "_bookmarkNames": [], "_splitChunks": function("23"), "_sortKey": [1, "needlemanwunsch.kt"], "exists": function("17"), "cachedDisplayString": "^GNeedlemanWunsch.kt", "New": function("34"), "_strForUI": function("41"), "_strForCd": function("42"), "copy": function("9"), "isUnder": function("31"), "ignore": function("28"), "strTrunk": function("46"), "getSortOrderIndex": function("22"), "displayString": function("14"), "isHiddenUnder": function("25"), "edit": function("15"), "isAncestor": function("30"), "isUnixHiddenPath": function("27"), "tabnr": function("47"), "bookmarkNames": function("4"), "readInfoFromDisk": function("36"), "str": function("40"), "_ignorePatternMatches": function("29"), "equals": function("33"), "_strForEdit": function("43"), "getParent": function("20"), "CopyingSupported": function("10"), "addDelimiter": function("6"), "_escChars": function("18"), "getLastPathComponent": function("21"), "isDirectory": 0, "isExecutable": 0, "JoinPathStrings": function("32"), "_str": function("45"), "WinToUnixPath": function("48"), "refreshFlags": function("38")}}, {"isRoot": function("121"), "rename": function("131"), "activate": function("107"), "clearBookmarks": function("110"), "displayString": function("113"), "cacheParent": function("109"), "delete": function("112"), "bookmark": function("108"), "findNode": function("115"), "_renderToString": function("133"), "openSplit": function("124"), "openInNewTab": function("126"), "findSibling": function("116"), "renderToString": function("132"), "openExplorer": function("127"), "getNerdtree": function("117"), "parent": "", "_nerdtree": "", "openVSplit": function("125"), "New": function("122"), "putCursorHere": function("128"), "equals": function("114"), "GetRootForTab": function("118"), "copy": function("111"), "GetSelected": function("119"), "refresh": function("129"), "refreshFlags": function("130"), "open": function("123"), "isVisible": function("120"), "path": {"copyingWillOverwrite": function("11"), "Resolve": function("35"), "drive": "", "isSymLink": 0, "createParentDirectories": function("12"), "extractDriveLetter": function("16"), "_strForGlob": function("44"), "getSortKey": function("24"), "cacheDisplayString": function("5"), "isUnixHiddenFile": function("26"), "flagSet": {"clearFlags": function("211"), "_flagsForScope": function("212"), "addFlag": function("210"), "removeFlag": function("214"), "renderToString": function("215"), "_flags": {}, "New": function("213")}, "rename": function("39"), "pathSegments": ["home", "widehyo", "gitclone", "playground", "content_base", "bundle", "smith_waterman.py"], "refresh": function("37"), "Create": function("8"), "AbsolutePathFor": function("3"), "getDir": function("19"), "isReadOnly": 0, "changeToDir": function("7"), "delete": function("13"), "_bookmarkNames": [], "_splitChunks": function("23"), "_sortKey": [1, "smith_waterman.py"], "exists": function("17"), "cachedDisplayString": "^Gsmith_waterman.py", "New": function("34"), "_strForUI": function("41"), "_strForCd": function("42"), "copy": function("9"), "isUnder": function("31"), "ignore": function("28"), "strTrunk": function("46"), "getSortOrderIndex": function("22"), "displayString": function("14"), "isHiddenUnder": function("25"), "edit": function("15"), "isAncestor": function("30"), "isUnixHiddenPath": function("27"), "tabnr": function("47"), "bookmarkNames": function("4"), "readInfoFromDisk": function("36"), "str": function("40"), "_ignorePatternMatches": function("29"), "equals": function("33"), "_strForEdit": function("43"), "getParent": function("20"), "CopyingSupported": function("10"), "addDelimiter": function("6"), "_escChars": function("18"), "getLastPathComponent": function("21"), "isDirectory": 0, "isExecutable": 0, "JoinPathStrings": function("32"), "_str": function("45"), "WinToUnixPath": function("48"), "refreshFlags": function("38")}}, {"isRoot": function("121"), "rename": function("131"), "activate": function("107"), "clearBookmarks": function("110"), "displayString": function("113"), "cacheParent": function("109"), "delete": function("112"), "bookmark": function("108"), "findNode": function("115"), "_renderToString": function("133"), "openSplit": function("124"), "openInNewTab": function("126"), "findSibling": function("116"), "renderToString": function("132"), "openExplorer": function("127"), "getNerdtree": function("117"), "parent": "", "_nerdtree": "", "openVSplit": function("125"), "New": function("122"), "putCursorHere": function("128"), "equals": function("114"), "GetRootForTab": function("118"), "copy": function("111"), "GetSelected": function("119"), "refresh": function("129"), "refreshFlags": function("130"), "open": function("123"), "isVisible": function("120"), "path": {"copyingWillOverwrite": function("11"), "Resolve": function("35"), "drive": "", "isSymLink": 0, "createParentDirectories": function("12"), "extractDriveLetter": function("16"), "_strForGlob": function("44"), "getSortKey": function("24"), "cacheDisplayString": function("5"), "isUnixHiddenFile": function("26"), "flagSet": {"clearFlags": function("211"), "_flagsForScope": function("212"), "addFlag": function("210"), "removeFlag": function("214"), "renderToString": function("215"), "_flags": {}, "New": function("213")}, "rename": function("39"), "pathSegments": ["home", "widehyo", "gitclone", "playground", "content_base", "bundle", "SmithWaterman.jar"], "refresh": function("37"), "Create": function("8"), "AbsolutePathFor": function("3"), "getDir": function("19"), "isReadOnly": 0, "changeToDir": function("7"), "delete": function("13"), "_bookmarkNames": [], "_splitChunks": function("23"), "_sortKey": [1, "smithwaterman.jar"], "exists": function("17"), "cachedDisplayString": "^GSmithWaterman.jar", "New": function("34"), "_strForUI": function("41"), "_strForCd": function("42"), "copy": function("9"), "isUnder": function("31"), "ignore": function("28"), "strTrunk": function("46"), "getSortOrderIndex": function("22"), "displayString": function("14"), "isHiddenUnder": function("25"), "edit": function("15"), "isAncestor": function("30"), "isUnixHiddenPath": function("27"), "tabnr": function("47"), "bookmarkNames": function("4"), "readInfoFromDisk": function("36"), "str": function("40"), "_ignorePatternMatches": function("29"), "equals": function("33"), "_strForEdit": function("43"), "getParent": function("20"), "CopyingSupported": function("10"), "addDelimiter": function("6"), "_escChars": function("18"), "getLastPathComponent": function("21"), "isDirectory": 0, "isExecutable": 0, "JoinPathStrings": function("32"), "_str": function("45"), "WinToUnixPath": function("48"), "refreshFlags": function("38")}}, {"isRoot": function("121"), "rename": function("131"), "activate": function("107"), "clearBookmarks": function("110"), "displayString": function("113"), "cacheParent": function("109"), "delete": function("112"), "bookmark": function("108"), "findNode": function("115"), "_renderToString": function("133"), "openSplit": function("124"), "openInNewTab": function("126"), "findSibling": function("116"), "renderToString": function("132"), "openExplorer": function("127"), "getNerdtree": function("117"), "parent": "", "_nerdtree": "", "openVSplit": function("125"), "New": function("122"), "putCursorHere": function("128"), "equals": function("114"), "GetRootForTab": function("118"), "copy": function("111"), "GetSelected": function("119"), "refresh": function("129"), "refreshFlags": function("130"), "open": function("123"), "isVisible": function("120"), "path": {"copyingWillOverwrite": function("11"), "Resolve": function("35"), "drive": "", "isSymLink": 0, "createParentDirectories": function("12"), "extractDriveLetter": function("16"), "_strForGlob": function("44"), "getSortKey": function("24"), "cacheDisplayString": function("5"), "isUnixHiddenFile": function("26"), "flagSet": {"clearFlags": function("211"), "_flagsForScope": function("212"), "addFlag": function("210"), "removeFlag": function("214"), "renderToString": function("215"), "_flags": {}, "New": function("213")}, "rename": function("39"), "pathSegments": ["home", "widehyo", "gitclone", "playground", "content_base", "bundle", "SmithWaterman.kt"], "refresh": function("37"), "Create": function("8"), "AbsolutePathFor": function("3"), "getDir": function("19"), "isReadOnly": 0, "changeToDir": function("7"), "delete": function("13"), "_bookmarkNames": [], "_splitChunks": function("23"), "_sortKey": [1, "smithwaterman.kt"], "exists": function("17"), "cachedDisplayString": "^GSmithWaterman.kt", "New": function("34"), "_strForUI": function("41"), "_strForCd": function("42"), "copy": function("9"), "isUnder": function("31"), "ignore": function("28"), "strTrunk": function("46"), "getSortOrderIndex": function("22"), "displayString": function("14"), "isHiddenUnder": function("25"), "edit": function("15"), "isAncestor": function("30"), "isUnixHiddenPath": function("27"), "tabnr": function("47"), "bookmarkNames": function("4"), "readInfoFromDisk": function("36"), "str": function("40"), "_ignorePatternMatches": function("29"), "equals": function("33"), "_strForEdit": function("43"), "getParent": function("20"), "CopyingSupported": function("10"), "addDelimiter": function("6"), "_escChars": function("18"), "getLastPathComponent": function("21"), "isDirectory": 0, "isExecutable": 0, "JoinPathStrings": function("32"), "_str": function("45"), "WinToUnixPath": function("48"), "refreshFlags": function("38")}}, {"isRoot": function("121"), "rename": function("131"), "activate": function("107"), "clearBookmarks": function("110"), "displayString": function("113"), "cacheParent": function("109"), "delete": function("112"), "bookmark": function("108"), "findNode": function("115"), "_renderToString": function("133"), "openSplit": function("124"), "openInNewTab": function("126"), "findSibling": function("116"), "renderToString": function("132"), "openExplorer": function("127"), "getNerdtree": function("117"), "parent": "", "_nerdtree": "", "openVSplit": function("125"), "New": function("122"), "putCursorHere": function("128"), "equals": function("114"), "GetRootForTab": function("118"), "copy": function("111"), "GetSelected": function("119"), "refresh": function("129"), "refreshFlags": function("130"), "open": function("123"), "isVisible": function("120"), "path": {"copyingWillOverwrite": function("11"), "Resolve": function("35"), "drive": "", "isSymLink": 0, "createParentDirectories": function("12"), "extractDriveLetter": function("16"), "_strForGlob": function("44"), "getSortKey": function("24"), "cacheDisplayString": function("5"), "isUnixHiddenFile": function("26"), "flagSet": {"clearFlags": function("211"), "_flagsForScope": function("212"), "addFlag": function("210"), "removeFlag": function("214"), "renderToString": function("215"), "_flags": {}, "New": function("213")}, "rename": function("39"), "pathSegments": ["home", "widehyo", "gitclone", "playground", "content_base", "bundle", "swap_camel_snake.awk"], "refresh": function("37"), "Create": function("8"), "AbsolutePathFor": function("3"), "getDir": function("19"), "isReadOnly": 0, "changeToDir": function("7"), "delete": function("13"), "_bookmarkNames": [], "_splitChunks": function("23"), "_sortKey": [1, "swap_camel_snake.awk"], "exists": function("17"), "cachedDisplayString": "^Gswap_camel_snake.awk", "New": function("34"), "_strForUI": function("41"), "_strForCd": function("42"), "copy": function("9"), "isUnder": function("31"), "ignore": function("28"), "strTrunk": function("46"), "getSortOrderIndex": function("22"), "displayString": function("14"), "isHiddenUnder": function("25"), "edit": function("15"), "isAncestor": function("30"), "isUnixHiddenPath": function("27"), "tabnr": function("47"), "bookmarkNames": function("4"), "readInfoFromDisk": function("36"), "str": function("40"), "_ignorePatternMatches": function("29"), "equals": function("33"), "_strForEdit": function("43"), "getParent": function("20"), "CopyingSupported": function("10"), "addDelimiter": function("6"), "_escChars": function("18"), "getLastPathComponent": function("21"), "isDirectory": 0, "isExecutable": 0, "JoinPathStrings": function("32"), "_str": function("45"), "WinToUnixPath": function("48"), "refreshFlags": function("38")}}, {"isRoot": function("121"), "rename": function("131"), "activate": function("107"), "clearBookmarks": function("110"), "displayString": function("113"), "cacheParent": function("109"), "delete": function("112"), "bookmark": function("108"), "findNode": function("115"), "_renderToString": function("133"), "openSplit": function("124"), "openInNewTab": function("126"), "findSibling": function("116"), "renderToString": function("132"), "openExplorer": function("127"), "getNerdtree": function("117"), "parent": "", "_nerdtree": "", "openVSplit": function("125"), "New": function("122"), "putCursorHere": function("128"), "equals": function("114"), "GetRootForTab": function("118"), "copy": function("111"), "GetSelected": function("119"), "refresh": function("129"), "refreshFlags": function("130"), "open": function("123"), "isVisible": function("120"), "path": {"copyingWillOverwrite": function("11"), "Resolve": function("35"), "drive": "", "isSymLink": 0, "createParentDirectories": function("12"), "extractDriveLetter": function("16"), "_strForGlob": function("44"), "getSortKey": function("24"), "cacheDisplayString": function("5"), "isUnixHiddenFile": function("26"), "flagSet": {"clearFlags": function("211"), "_flagsForScope": function("212"), "addFlag": function("210"), "removeFlag": function("214"), "renderToString": function("215"), "_flags": {}, "New": function("213")}, "rename": function("39"), "pathSegments": ["home", "widehyo", "gitclone", "playground", "content_base", "bundle", "swap_camel_snake.py"], "refresh": function("37"), "Create": function("8"), "AbsolutePathFor": function("3"), "getDir": function("19"), "isReadOnly": 0, "changeToDir": function("7"), "delete": function("13"), "_bookmarkNames": [], "_splitChunks": function("23"), "_sortKey": [1, "swap_camel_snake.py"], "exists": function("17"), "cachedDisplayString": "^Gswap_camel_snake.py", "New": function("34"), "_strForUI": function("41"), "_strForCd": function("42"), "copy": function("9"), "isUnder": function("31"), "ignore": function("28"), "strTrunk": function("46"), "getSortOrderIndex": function("22"), "displayString": function("14"), "isHiddenUnder": function("25"), "edit": function("15"), "isAncestor": function("30"), "isUnixHiddenPath": function("27"), "tabnr": function("47"), "bookmarkNames": function("4"), "readInfoFromDisk": function("36"), "str": function("40"), "_ignorePatternMatches": function("29"), "equals": function("33"), "_strForEdit": function("43"), "getParent": function("20"), "CopyingSupported": function("10"), "addDelimiter": function("6"), "_escChars": function("18"), "getLastPathComponent": function("21"), "isDirectory": 0, "isExecutable": 0, "JoinPathStrings": function("32"), "_str": function("45"), "WinToUnixPath": function("48"), "refreshFlags": function("38")}}, {"isRoot": function("121"), "rename": function("131"), "activate": function("107"), "clearBookmarks": function("110"), "displayString": function("113"), "cacheParent": function("109"), "delete": function("112"), "bookmark": function("108"), "findNode": function("115"), "_renderToString": function("133"), "openSplit": function("124"), "openInNewTab": function("126"), "findSibling": function("116"), "renderToString": function("132"), "openExplorer": function("127"), "getNerdtree": function("117"), "parent": "", "_nerdtree": "", "openVSplit": function("125"), "New": function("122"), "putCursorHere": function("128"), "equals": function("114"), "GetRootForTab": function("118"), "copy": function("111"), "GetSelected": function("119"), "refresh": function("129"), "refreshFlags": function("130"), "open": function("123"), "isVisible": function("120"), "path": {"copyingWillOverwrite": function("11"), "Resolve": function("35"), "drive": "", "isSymLink": 0, "createParentDirectories": function("12"), "extractDriveLetter": function("16"), "_strForGlob": function("44"), "getSortKey": function("24"), "cacheDisplayString": function("5"), "isUnixHiddenFile": function("26"), "flagSet": {"clearFlags": function("211"), "_flagsForScope": function("212"), "addFlag": function("210"), "removeFlag": function("214"), "renderToString": function("215"), "_flags": {}, "New": function("213")}, "rename": function("39"), "pathSegments": ["home", "widehyo", "gitclone", "playground", "content_base", "bundle", "SwapCamelSnake.kt"], "refresh": function("37"), "Create": function("8"), "AbsolutePathFor": function("3"), "getDir": function("19"), "isReadOnly": 0, "changeToDir": function("7"), "delete": function("13"), "_bookmarkNames": [], "_splitChunks": function("23"), "_sortKey": [1, "swapcamelsnake.kt"], "exists": function("17"), "cachedDisplayString": "^GSwapCamelSnake.kt", "New": function("34"), "_strForUI": function("41"), "_strForCd": function("42"), "copy": function("9"), "isUnder": function("31"), "ignore": function("28"), "strTrunk": function("46"), "getSortOrderIndex": function("22"), "displayString": function("14"), "isHiddenUnder": function("25"), "edit": function("15"), "isAncestor": function("30"), "isUnixHiddenPath": function("27"), "tabnr": function("47"), "bookmarkNames": function("4"), "readInfoFromDisk": function("36"), "str": function("40"), "_ignorePatternMatches": function("29"), "equals": function("33"), "_strForEdit": function("43"), "getParent": function("20"), "CopyingSupported": function("10"), "addDelimiter": function("6"), "_escChars": function("18"), "getLastPathComponent": function("21"), "isDirectory": 0, "isExecutable": 0, "JoinPathStrings": function("32"), "_str": function("45"), "WinToUnixPath": function("48"), "refreshFlags": function("38")}}], "clearBookmarks": function("110"), "open": function("157"), "findSibling": function("116"), "closeChildren": function("138"), "getNerdtree": function("117"), "parent": {}, "_nerdtree": "", "putCursorHere": function("128"), "createChild": function("139"), "hasVisibleChildren": function("153"), "getChildCount": function("144"), "refreshFlags": function("164")}, "changedtick": 10, "NERDTree": ""}, "popups": [], "name": "/home/widehyo/gitclone/playground/content_base/bundle/NERD_tree_tab_1", "changed": 0, "lastused": 1742629364, "loaded": 1, "windows": [1001], "hidden": 0, "listed": 0, "changedtick": 10, "linecount": 18}]

{
  "lnum": 1229,
  "bufnr": 1,
  "variables": {
    "current_syntax": "markdown",
    "undo_ftplugin": "setlocal commentstring< matchpairs< omnifunc< comments< formatoptions< | unlet! b:match_ignorecase b:match_skip b:match_words b:browsefilter|setl cms< com< fo< flp<",
    "changedtick": 6,
    "git_dir": "/home/widehyo/gitclone/playground/.git",
    "did_ftplugin": 1,
    "html_omni_flavor": "html401t",
    "airline_wordcount": "4,135 words ",
    "buffer_vcs_config": {
      "git": {
        "untracked": "Ɇ",
        "dirty": 1,
        "branch": "main"
      },
      "mercurial": {
        "untracked": "",
        "dirty": 0,
        "branch": ""
      }
    },
    "airline_changedtick": 6,
    "airline_head": "mainɆ",
    "airline_whitespace_check": "☲ [668]mixed-indent [653:2]mix-indent-file",
    "fugitive_name": ""
  },
  "popups": [],
  "name": "/home/widehyo/gitclone/playground/2025/03/22/20250322.md",
  "changed": 1,
  "lastused": 1742629417,
  "loaded": 1,
  "windows": [
    1000
  ],
  "hidden": 0,
  "listed": 1,
  "changedtick": 6,
  "linecount": 1229
}

let a = '/home/widehyo/gitclone/playground/2025/03/22/20250322.md'
echo fnamemodify(expand(a), ":~:.")
let b = '/home/widehyo/gitclone/playground/content_base/bundle/buffer_fzf.vim'
echo fnamemodify(expand(b), ":~:.")


let buf_info = getbufinfo()
let listed_buffer_info = buf_info->filter({_, val -> val.listed == 1 })->map({_, val -> {'bufnr': val.bufnr, 'name': fnamemodify(expand(val.name), ":~:.")}})
return l:listed_buffer_info
echo listed_buffer_info

===

실패

nnoremap <leader><C-T> :echo @t<CR>

function! GetLoadedBufferList()
  let l:buf_info = getbufinfo()
  let l:listed_buffer_info = l:buf_info
        \ ->filter({_, val -> val.listed == 1 })
        \ ->map({_, val -> {'bufnr': val.bufnr, 'name': fnamemodify(expand(val.name), ":~:.")}})
  return l:listed_buffer_info
endfunction

function! GetSmithWatermanScore(search_word, buf_name)
  let l:tx = ' ' . a:search_word
  let l:ty = ' ' . a:buf_name

  " direction
  let l:up      = 0b001
  let l:left    = 0b010
  let l:upleft  = 0b100
  let l:default = 0b000

  let l:matrix = []
  let l:highest_scored_position_list = []
  let l:score = 0

  function! CalcElement(row, col, match = 3, mis_match = -3, gap_panalty = -2) closure
    " closure for calculate matrix element with free variables:
    " l:matrix, l:highest_scored_position_list, l:score, l:tx, l:ty
    " l:up, l:left, l:upleft, l:default

    " echo 'CalcElement (row: ' . a:row ', col: ' . a:col . ') len(l:matrix) is ' . len(l:matrix) . ' len(l:matrix[0]) is ' . len(l:matrix[0])

    let l:up_value = l:matrix[a:row - 1][a:col][0]
    let l:left_value = l:matrix[a:row][a:col - 1][0]
    let l:diag_value = l:matrix[a:row - 1][a:col - 1][0]

    let l:up_candidate = l:up_value + a:gap_panalty
    let l:left_candidate = l:left_value + a:gap_panalty

    let l:diag_candidate = l:diag_value + a:mis_match

    if l:tx[a:row] == l:ty[a:col]
      let l:diag_candidate = l:diag_value + a:match
    endif

    let l:element_value = max([l:up_candidate, l:left_candidate, l:diag_candidate])
    let l:element_direction = l:default

    if l:element_value < 0
      let l:matrix[a:row][a:col] = [0, 0]
      return max([l:score, l:element_value])
    endif

    if l:element_value == l:up_candidate
      let l:element_direction = or(l:element_direction, l:up)
    endif
    if l:element_value == l:left_candidate
      let l:element_direction = or(l:element_direction, l:left)
    endif
    if l:element_value == l:diag_candidate
      let l:element_direction = or(l:element_direction, l:upleft)
    endif

    let l:matrix[a:row][a:col] = [l:element_value, l:element_direction]

    if l:element_value > l:score
      if len(l:highest_scored_position_list) > 0
        call remove(l:highest_scored_position_list, 0, len(l:highest_scored_position_list)-1)
      endif
      call add(l:highest_scored_position_list, [a:row, a:col])
      return max([l:score, l:element_value])
    elseif l:element_value == l:score
      call add(l:highest_scored_position_list, [a:row, a:col])
      return max([l:score, l:element_value])
    else
      return max([l:score, l:element_value])
    endif
  endfunction

  " initialize matrix
  for i in range(len(l:tx))
      let l:matrix_row = []
      for j in range(len(l:ty))
        call add(l:matrix_row, [0,0])
      endfor
      call add(l:matrix, l:matrix_row)
  endfor

  for i in range(1, len(a:search_word))
    for j in range(1, len(a:buf_name))
      let l:score = CalcElement(i, j)
    endfor
  endfor

  let l:buf_name_position_list = []

  while len(l:highest_scored_position_list) > 0
    let l:cur_position = remove(l:highest_scored_position_list, -1)
    let [l:cur_row, l:cur_col] = l:cur_position
    let [l:cur_value, l:cur_direction] = l:matrix[l:cur_row][l:cur_col]

    if l:cur_value == 0
      break
    endif

    if and(l:cur_direction, l:up) > 0
      call add(l:highest_scored_position_list, [l:cur_row - 1, l:cur_col])
    endif
    if and(l:cur_direction, l:left) > 0
      call insert(l:buf_name_position_list, l:cur_col)
      call add(l:highest_scored_position_list, [l:cur_row, l:cur_col - 1])
    endif
    if and(l:cur_direction, l:upleft) > 0
      call insert(l:buf_name_position_list, l:cur_col)
      call add(l:highest_scored_position_list, [l:cur_row - 1, l:cur_col - 1])
    endif

    break
  endwhile

  if @t == ''
    let @t = a:search_word . '#' . a:buf_name . '(' . l:score . ')'
  else
    call setreg('t', '|' . a:buf_name . '(' . l:score . ')', 'a')
  endif

  return [l:score, l:buf_name_position_list]
endfunction

function! PopupBuffer()

  let l:search_word = ''
  let l:buffer_info_list = GetLoadedBufferList()

  new
  let l:pop_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal noswapfile
  setlocal nobuflisted
  setlocal nomodifiable
  resize 20

  new
  let l:search_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal filetype=search
  setlocal noswapfile
  setlocal nobuflisted
  resize 1

  " echo l:pop_bufnr . ' ' . ' ' . l:search_bufnr
  call RedrawBufferList(l:buffer_info_list, l:pop_bufnr, l:search_bufnr)

  redraw

  let Partial = function('CaptureSearchText', [l:buffer_info_list, l:pop_bufnr, l:search_bufnr])

  " Create an autocommand for TextChangedI in the 'search' buffer
  autocmd TextChangedI <buffer> call Partial()

endfunction

" Function to capture and echo the text in the search buffer
function! CaptureSearchText(buffer_info_list, pop_bufnr, search_bufnr)
  " Get the content of the search buffer
  let l:search_word = join(getline(1,1), '')
  " initialize temp register
  let @t = ''
  if l:search_word == ''
    call RedrawBufferList(a:buffer_info_list, a:pop_bufnr, a:search_bufnr)
  else
    call SmithWaterman(l:search_word, a:buffer_info_list, a:pop_bufnr, a:search_bufnr)
  endif
endfunction

function! RedrawBufferList(buffers, pop_bufnr, search_bufnr)

  if bufnr() != a:pop_bufnr
    return
  endif

  let l:header = []
  let l:lines = []
  for idx in range(len(a:buffers))
    let l:buffer = a:buffers[idx]
    let l:bufnr = l:buffer.bufnr
    let l:bufname = l:buffer.name
    call add(l:lines, l:bufname)
  endfor

  execute 'buffer' . a:pop_bufnr
  setlocal modifiable
  call setbufline(a:pop_bufnr, 1, l:header + l:lines)
  setlocal nomodifiable
endfunction

function! SmithWaterman(search_word, buffer_info_list, pop_bufnr, search_bufnr)
  let l:filtered_buffer_list = copy(a:buffer_info_list)
        \ ->filter({_, val -> GetSmithWatermanScore(a:search_word, val.name)[0] > 0})
  let @h = string(l:filtered_buffer_list)
  call RedrawBufferList(l:filtered_buffer_list, a:pop_bufnr, a:search_bufnr)
endfunction

call PopupBuffer()

===


nnoremap <leader><C-T> :echo @t<CR>

function! GetLoadedBufferList()
  let l:buf_info = getbufinfo()
  let l:listed_buffer_info = l:buf_info
        \ ->filter({_, val -> val.listed == 1 })
        \ ->map({_, val -> {'bufnr': val.bufnr, 'name': val.name}})
  return l:listed_buffer_info
endfunction

function! GetSmithWatermanScore(search_word, buf_name)
  let l:tx = ' ' . a:search_word
  let l:ty = ' ' . a:buf_name

  " direction
  let l:up      = 0b001
  let l:left    = 0b010
  let l:upleft  = 0b100
  let l:default = 0b000

  let l:matrix = []
  let l:highest_scored_position_list = []
  let l:score = 0

  function! CalcElement(row, col, match = 3, mis_match = -3, gap_panalty = -2) closure
    " closure for calculate matrix element with free variables:
    " l:matrix, l:highest_scored_position_list, l:score, l:tx, l:ty
    " l:up, l:left, l:upleft, l:default

    " echo 'CalcElement (row: ' . a:row ', col: ' . a:col . ') len(l:matrix) is ' . len(l:matrix) . ' len(l:matrix[0]) is ' . len(l:matrix[0])

    let l:up_value = l:matrix[a:row - 1][a:col][0]
    let l:left_value = l:matrix[a:row][a:col - 1][0]
    let l:diag_value = l:matrix[a:row - 1][a:col - 1][0]

    let l:up_candidate = l:up_value + a:gap_panalty
    let l:left_candidate = l:left_value + a:gap_panalty

    let l:diag_candidate = l:diag_value + a:mis_match

    if l:tx[a:row] == l:ty[a:col]
      let l:diag_candidate = l:diag_value + a:match
    endif

    let l:element_value = max([l:up_candidate, l:left_candidate, l:diag_candidate])
    let l:element_direction = l:default

    if l:element_value < 0
      let l:matrix[a:row][a:col] = [0, 0]
      return max([l:score, l:element_value])
    endif

    if l:element_value == l:up_candidate
      let l:element_direction = or(l:element_direction, l:up)
    endif
    if l:element_value == l:left_candidate
      let l:element_direction = or(l:element_direction, l:left)
    endif
    if l:element_value == l:diag_candidate
      let l:element_direction = or(l:element_direction, l:upleft)
    endif

    let l:matrix[a:row][a:col] = [l:element_value, l:element_direction]

    if l:element_value > l:score
      if len(l:highest_scored_position_list) > 0
        call remove(l:highest_scored_position_list, 0, len(l:highest_scored_position_list)-1)
      endif
      call add(l:highest_scored_position_list, [a:row, a:col])
      return max([l:score, l:element_value])
    elseif l:element_value == l:score
      call add(l:highest_scored_position_list, [a:row, a:col])
      return max([l:score, l:element_value])
    else
      return max([l:score, l:element_value])
    endif
  endfunction

  " initialize matrix
  for i in range(len(l:tx))
      let l:matrix_row = []
      for j in range(len(l:ty))
        call add(l:matrix_row, [0,0])
      endfor
      call add(l:matrix, l:matrix_row)
  endfor

  let @a = ''
  for i in range(1, len(a:search_word))
    for j in range(1, len(a:buf_name))
      let l:score = CalcElement(i, j)
    endfor
  endfor

  let l:buf_name_position_list = []
  let @d = string(l:score)

  while len(l:highest_scored_position_list) > 0
    let l:cur_position = remove(l:highest_scored_position_list, -1)
    let [l:cur_row, l:cur_col] = l:cur_position
    let [l:cur_value, l:cur_direction] = l:matrix[l:cur_row][l:cur_col]

    if l:cur_value == 0
      break
    endif

    if and(l:cur_direction, l:up) > 0
      call add(l:highest_scored_position_list, [l:cur_row - 1, l:cur_col])
    endif
    if and(l:cur_direction, l:left) > 0
      call insert(l:buf_name_position_list, l:cur_col)
      call add(l:highest_scored_position_list, [l:cur_row, l:cur_col - 1])
    endif
    if and(l:cur_direction, l:upleft) > 0
      call insert(l:buf_name_position_list, l:cur_col)
      call add(l:highest_scored_position_list, [l:cur_row - 1, l:cur_col - 1])
    endif

    break
  endwhile

  if @t == ''
    let @t = a:search_word . '#' . a:buf_name . '(' . l:score . ')'
  else
    call setreg('t', '|' . a:buf_name . '(' . l:score . ')', 'a')
  endif

  return [l:score, l:buf_name_position_list]
endfunction

function! PopupBuffer()

  " Function to capture and echo the text in the search buffer
  function! CaptureSearchText() closure
    " Get the content of the search buffer
    let l:text = join(getline(1,1), '')
    " Echo the content to the command line
    let l:search_word = l:text
    " initialize temp register
    let @t = ''
    if l:search_word == ''
      call RedrawBufferList(l:buffer_info_list)
    else
      call SmithWaterman(l:search_word, l:buffer_info_list)
    endif
  endfunction

  function! SmithWaterman(search_word, buffer_info_list) closure
    " echo l:search_word
    let l:temp_target = copy(a:buffer_info_list)
          \ ->map({_, val -> GetSmithWatermanScore(a:search_word, val.name)})
    let @h = string(l:temp_target)
    let l:filtered_buffer_list = copy(a:buffer_info_list)
          \ ->filter({_, val -> GetSmithWatermanScore(a:search_word, val.name)[0] > 0})
    call RedrawBufferList(l:filtered_buffer_list)
  endfunction

  function! RedrawBufferList(buffers) closure
    if bufnr() != l:pop_bufnr
      return
    endif

    let l:header = []
    let l:lines = []
    for idx in range(len(a:buffers))
      let l:buffer = a:buffers[idx]
      let l:bufnr = l:buffer.bufnr
      let l:bufname = l:buffer.name
      call add(l:lines, l:bufname)
    endfor

    execute 'buffer' . l:pop_bufnr
    setlocal modifiable
    call setbufline(l:pop_bufnr, 1, l:header + l:lines)
    setlocal nomodifiable
  endfunction

  let l:search_word = ''
  let l:buffer_info_list = GetLoadedBufferList()

  new
  let l:pop_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal noswapfile
  setlocal nobuflisted
  setlocal nomodifiable
  resize 20

  new
  let l:search_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal filetype=search
  setlocal noswapfile
  setlocal nobuflisted
  resize 1

  " echo l:pop_bufnr . ' ' . ' ' . l:search_bufnr
  call RedrawBufferList(l:buffer_info_list)

  redraw

  " Create an autocommand for TextChangedI in the 'search' buffer
  autocmd TextChangedI <buffer> call CaptureSearchText()

endfunction


call PopupBuffer()

===

  function! SmithWaterman(search_word, buffer_info_list) closure
    " echo l:search_word
    let l:temp_target = copy(a:buffer_info_list)
          \ ->map({_, val -> GetSmithWatermanScore(a:search_word, val.name)})
    let @h = string(l:temp_target)
    let l:temp_target2 = copy(a:buffer_info_list)
          \ ->map({_, val -> GetSmithWatermanScore(a:search_word, val.name)[0] > 0})
    let @k = string(l:temp_target2)
    let l:filtered_buffer_list = copy(a:buffer_info_list)
          \ ->filter({_, val -> GetSmithWatermanScore(a:search_word, val.name)[0] > 0})
    call RedrawBufferList(l:filtered_buffer_list)
    let @r = string(l:filtered_buffer_list)
  endfunction


yes

echo @h
[[7, [51]], [0, []], [0, []]]
echo @t
203#/home/widehyo/gitclone/playground/2025/03/22/20250322.md(7)|/home/widehyo/.vim/util/common.vim(0)|/home/widehyo/gitclone/playground/content_base/bundle/buffer_fzf.vim(0)|/home/widehyo/gitclone/playground/2025/03/22/20250322.md(7)|/home/widehyo/.vim/util/common.vim(0)|/home/widehyo/gitclone/playground/content_base/bundle/buffer_fzf.vim(0)|/home/widehyo/gitclone/playground/2025/03/22/20250322.md(7)|/home/widehyo/.vim/util/common.vim(0)|/home/widehyo/gitclone/playground/content_base/bundle/buffer_fzf.vim(0)
echo @k
[1, 0, 0]
echo @r
[{'bufnr': 1, 'name': '/home/widehyo/gitclone/playground/2025/03/22/20250322.md'}]

===

    let l:filtered_buffer_list = copy(a:buffer_info_list)
          \ ->map({_, val -> extend(val, {'score': GetSmithWatermanScore(a:search_word, val.name)[0]})})
          \ ->filter({_, val -> val.score > 0})

[{'score': 6, 'bufnr': 1, 'name': '/home/widehyo/gitclone/playground/2025/03/22/20250322.md'}]


let a = '/home/widehyo/gitclone/playground/content_base/bundle/buffer_fzf.vim'
echo a[57]


buffer
let a = '/home/widehyo/gitclone/playground/content_base/bundle/buffer_fzf.vim'
echo a[59] " r
echo a[60] " _
echo a[61] " f
let a = '/home/widehyo/gitclone/playground/2025/03/22/20250322.md'
echo a[28] " r
echo a[29] " o
echo a[30] " u
[{'score': 18, 'bufnr': 1, 'name': '/home/widehyo/gitclone/playground/content_base/bundle/buffer_fzf.vim', 'position': [60]}, {'score': 3, 'bufnr': 12, 'name': '/home/widehyo/gitclone/playground/2025/03/22/20250322.md', 'position': [29]}]


echo @r
[{'score': 18, 'bufnr': 1, 'name': '/home/widehyo/gitclone/playground/content_base/bundle/buffer_fzf.vim', 'position': [54, 55, 56, 57, 58, 59]}, {'score': 3, 'bufnr': 12, 'name': '/home/widehyo/gitclone/playground/2025/03/22/20250322.md', 'position': [28]}]

let a = '/home/widehyo/gitclone/playground/content_base/bundle/buffer_fzf.vim'
echo a[54:59]




echo @r

abuff202
[{'score': 12, 'hlposition': [[54, 57]], 'name': '/home/widehyo/gitclone/playground/content_base/bundle/buffer_fzf.vim', 'bufnr': 1}, {'score': 9, 'hlposition': [[45, 47]], 'name': '/home/widehyo/gitclone/playground/2025/03/22/20250322.md', 'bufnr': 12}, {'score': 6, 'hlposition': [[47, 48]], 'name': '/home/widehyo/gitclone/playground/content_base/bundle/temp.py', 'bufnr': 28}]

let a = '/home/widehyo/gitclone/playground/content_base/bundle/temp.py'
echo a[47:48]
echo a[48:48]
echo a[:48]
echo a[48:]


echo @r
[{'score': 18, 'hlposition': [[54, 59]], 'decorated_text': '/home/widehyo/gitclone/playground/content_base/bundle/[buffer]', 'name': '/home/widehyo/gitclone/playground/content_base/bundle/buffer_fzf.vim', 'bufnr': 1}, {'score': 3, 'hlposition': [[28, 28]], 'decorated_text': '/home/widehyo/gitclone/playg[r]', 'name': '/home/widehyo/gitclone/playground/2025/03/22/20250322.md', 'bufnr': 12}, {'score': 6, 'hlposition': [[47, 48]], 'decorated_text': '/home/widehyo/gitclone/playground/content_base/[bu]', 'name': '/home/widehyo/gitclone/playground/content_base/bundle/temp.py', 'bufnr': 28}]


echo @r
buffer.fzf
[{'score': 24, 'hlposition': [[54, 63]], 'decorated_text': '/home/widehyo/gitclone/playground/content_base/bundle/[buffer_fzf].vim', 'name': '/home/widehyo/gitclone/playground/content_base/bundle/buffer_fzf.vim', 'bufnr': 1}, {'score': 3, 'hlposition': [[53, 53]], 'decorated_text': '/home/widehyo/gitclone/playground/2025/03/22/20250322[.]md', 'name': '/home/widehyo/gitclone/playground/2025/03/22/20250322.md', 'bufnr': 12}, {'score': 6, 'hlposition': [[47, 48]], 'decorated_text': '/home/widehyo/gitclone/playground/content_base/[bu]ndle/temp.py', 'name': '/home/widehyo/gitclone/playground/content_base/bundle/temp.py', 'bufnr': 28}]


===


nnoremap <leader><C-T> :echo @t<CR>

function! GetLoadedBufferList()
  let l:buf_info = getbufinfo()
  let l:listed_buffer_info = l:buf_info
        \ ->filter({_, val -> val.listed == 1 })
        \ ->map({_, val -> {'bufnr': val.bufnr, 'name': val.name}})
  return l:listed_buffer_info
endfunction

function! GetSmithWatermanScore(search_word, buf_name)
  let l:tx = ' ' . a:search_word
  let l:ty = ' ' . a:buf_name

  " direction
  let l:up      = 0b001
  let l:left    = 0b010
  let l:upleft  = 0b100
  let l:default = 0b000

  let l:matrix = []
  let l:highest_scored_position_list = []
  let l:score = 0

  function! CalcElement(row, col, match = 3, mis_match = -3, gap_panalty = -2) closure
    " closure for calculate matrix element with free variables:
    " l:matrix, l:highest_scored_position_list, l:score, l:tx, l:ty
    " l:up, l:left, l:upleft, l:default

    " echo 'CalcElement (row: ' . a:row ', col: ' . a:col . ') len(l:matrix) is ' . len(l:matrix) . ' len(l:matrix[0]) is ' . len(l:matrix[0])

    let l:up_value = l:matrix[a:row - 1][a:col][0]
    let l:left_value = l:matrix[a:row][a:col - 1][0]
    let l:diag_value = l:matrix[a:row - 1][a:col - 1][0]

    let l:up_candidate = l:up_value + a:gap_panalty
    let l:left_candidate = l:left_value + a:gap_panalty

    let l:diag_candidate = l:diag_value + a:mis_match

    if l:tx[a:row] == l:ty[a:col]
      let l:diag_candidate = l:diag_value + a:match
    endif

    let l:element_value = max([l:up_candidate, l:left_candidate, l:diag_candidate])
    let l:element_direction = l:default

    if l:element_value < 0
      let l:matrix[a:row][a:col] = [0, 0]
      return max([l:score, l:element_value])
    endif

    if l:element_value == l:up_candidate
      let l:element_direction = or(l:element_direction, l:up)
    endif
    if l:element_value == l:left_candidate
      let l:element_direction = or(l:element_direction, l:left)
    endif
    if l:element_value == l:diag_candidate
      let l:element_direction = or(l:element_direction, l:upleft)
    endif

    let l:matrix[a:row][a:col] = [l:element_value, l:element_direction]

    if l:element_value > l:score
      if len(l:highest_scored_position_list) > 0
        call remove(l:highest_scored_position_list, 0, len(l:highest_scored_position_list)-1)
      endif
      call add(l:highest_scored_position_list, [a:row, a:col])
      return max([l:score, l:element_value])
    elseif l:element_value == l:score
      call add(l:highest_scored_position_list, [a:row, a:col])
      return max([l:score, l:element_value])
    else
      return max([l:score, l:element_value])
    endif
  endfunction

  " initialize matrix
  for i in range(len(l:tx))
      let l:matrix_row = []
      for j in range(len(l:ty))
        call add(l:matrix_row, [0,0])
      endfor
      call add(l:matrix, l:matrix_row)
  endfor

  let @a = ''
  for i in range(1, len(a:search_word))
    for j in range(1, len(a:buf_name))
      let l:score = CalcElement(i, j)
    endfor
  endfor

  let l:buf_name_position_list = []
  let @d = string(l:score)

  while len(l:highest_scored_position_list) > 0
    let l:cur_position = remove(l:highest_scored_position_list, -1)
    let [l:cur_row, l:cur_col] = l:cur_position
    let [l:cur_value, l:cur_direction] = l:matrix[l:cur_row][l:cur_col]

    if l:cur_value == 0
      break
    endif

    if and(l:cur_direction, l:up) > 0
      call add(l:highest_scored_position_list, [l:cur_row - 1, l:cur_col])
    endif
    if and(l:cur_direction, l:left) > 0
      call insert(l:buf_name_position_list, l:cur_col - 1)
      call add(l:highest_scored_position_list, [l:cur_row, l:cur_col - 1])
    endif
    if and(l:cur_direction, l:upleft) > 0
      call insert(l:buf_name_position_list, l:cur_col - 1)
      call add(l:highest_scored_position_list, [l:cur_row - 1, l:cur_col - 1])
    endif
  endwhile

  if @t == ''
    let @t = a:search_word . '#' . a:buf_name . '(' . l:score . ')'
  else
    call setreg('t', '|' . a:buf_name . '(' . l:score . ')', 'a')
  endif

  return [l:score, l:buf_name_position_list]
endfunction

function! GetHighlightPosition(position)
  let l:flag = 0
  let l:prev = -1
  let l:start = -1
  let l:result = []
  for pos in a:position
    if l:flag
      if pos - l:prev == 1
        let l:prev = pos
      else
        let l:flag = 0
        call add(l:result, [l:start, pos])
      endif
    else
      let l:start = pos
      let l:prev = pos
      let l:flag = 1
    endif
  endfor
  if l:flag
    call add(l:result, [l:start, a:position[-1]])
  endif
  return l:result
endfunction

function! DecorateText(text, position_list)
  let l:result_text = ""
  let l:idx = 0
  for [start, end] in a:position_list
    let l:result_text = a:text[l:idx:start - 1] . '[' . a:text[start:end] . ']'
    let l:idx = end + 1
  endfor
  if l:idx != len(a:text)
    let l:result_text = l:result_text . a:text[l:idx:]
  endif
  return l:result_text
endfunction

function! PopupBuffer()

  " Function to capture and echo the text in the search buffer
  function! CaptureSearchText() closure
    " Get the content of the search buffer
    let l:text = join(getline(1,1), '')
    " Echo the content to the command line
    let l:search_word = l:text
    " initialize temp register
    let @t = ''
    if l:search_word == ''
      call RedrawBufferList(l:buffer_info_list)
    else
      call SmithWaterman(l:search_word, l:buffer_info_list)
    endif
  endfunction

  function! SmithWaterman(search_word, buffer_info_list) closure
    let l:filtered_buffer_list = []
    for l:buffer_info in copy(a:buffer_info_list)
      let [l:score, l:position] = GetSmithWatermanScore(a:search_word, l:buffer_info.name)
      if l:score > 0
        let l:hlpos = GetHighlightPosition(l:position)
        let l:target_buf_info = {}
        let l:target_buf_info.score = l:score
        let l:target_buf_info.hlposition = l:hlpos
        let l:target_buf_info.decorated_text = DecorateText(l:buffer_info.name, l:hlpos)
        let l:target_buf_info = extend(l:target_buf_info, l:buffer_info)
        call add(l:filtered_buffer_list, l:target_buf_info)
      endif
    endfor
    let @r = string(l:filtered_buffer_list)

    call RedrawBufferList(l:filtered_buffer_list)
  endfunction

  function! RedrawBufferList(buffers) closure
    if bufnr() != l:pop_bufnr
      return
    endif

    let l:header = []
    let l:lines = []
    for idx in range(len(a:buffers))
      let l:buffer = a:buffers[idx]
      let l:bufnr = l:buffer.bufnr
      let l:bufname = l:buffer.name
      call add(l:lines, l:bufname)
    endfor

    execute 'buffer' . l:pop_bufnr
    setlocal modifiable
    call setbufline(l:pop_bufnr, 1, l:header + l:lines)
    setlocal nomodifiable
  endfunction

  let l:search_word = ''
  let l:buffer_info_list = GetLoadedBufferList()

  new
  let l:pop_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal noswapfile
  setlocal nobuflisted
  setlocal nomodifiable
  resize 20

  new
  let l:search_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal filetype=search
  setlocal noswapfile
  setlocal nobuflisted
  resize 1

  " echo l:pop_bufnr . ' ' . ' ' . l:search_bufnr
  call RedrawBufferList(l:buffer_info_list)

  redraw

  " Create an autocommand for TextChangedI in the 'search' buffer
  autocmd TextChangedI <buffer> call CaptureSearchText()

endfunction


call PopupBuffer()


echo @k

echo @p
[{'bufnr': 1, 'name': '/home/widehyo/gitclone/playground/content_base/bundle/buffer_fzf.vim'}, {'bufnr': 12, 'name': '/home/widehyo/gitclone/playground/2025/03/22/20250322.md'}, {'bufnr': 28, 'name': '/home/widehyo/gitclone/playground/content_base/bundle/temp.py'}]

let a = [{'bufnr': 1, 'name': '/home/widehyo/gitclone/playground/content_base/bundle/buffer_fzf.vim'}, {'bufnr': 12, 'name': '/home/widehyo/gitclone/playground/2025/03/22/20250322.md'}, {'bufnr': 28, 'name': '/home/widehyo/gitclone/playground/content_base/bundle/temp.py'}]

echo a->map({_, val -> val.name})


echo @p

===


nnoremap <leader><C-T> :echo @t<CR>

function! GetLoadedBufferList()
  let l:buf_info = getbufinfo()
  let l:listed_buffer_info = l:buf_info
        \ ->filter({_, val -> val.listed == 1 })
        \ ->map({_, val -> {'bufnr': val.bufnr, 'name': val.name}})
  return l:listed_buffer_info
endfunction

function! GetSmithWatermanScore(search_word, buf_name)
  let l:tx = ' ' . a:search_word
  let l:ty = ' ' . a:buf_name

  " direction
  let l:up      = 0b001
  let l:left    = 0b010
  let l:upleft  = 0b100
  let l:default = 0b000

  let l:matrix = []
  let l:highest_scored_position_list = []
  let l:score = 0

  function! CalcElement(row, col, match = 3, mis_match = -3, gap_panalty = -2) closure
    " closure for calculate matrix element with free variables:
    " l:matrix, l:highest_scored_position_list, l:score, l:tx, l:ty
    " l:up, l:left, l:upleft, l:default

    " echo 'CalcElement (row: ' . a:row ', col: ' . a:col . ') len(l:matrix) is ' . len(l:matrix) . ' len(l:matrix[0]) is ' . len(l:matrix[0])

    let l:up_value = l:matrix[a:row - 1][a:col][0]
    let l:left_value = l:matrix[a:row][a:col - 1][0]
    let l:diag_value = l:matrix[a:row - 1][a:col - 1][0]

    let l:up_candidate = l:up_value + a:gap_panalty
    let l:left_candidate = l:left_value + a:gap_panalty

    let l:diag_candidate = l:diag_value + a:mis_match

    if l:tx[a:row] == l:ty[a:col]
      let l:diag_candidate = l:diag_value + a:match
    endif

    let l:element_value = max([l:up_candidate, l:left_candidate, l:diag_candidate])
    let l:element_direction = l:default

    if l:element_value < 0
      let l:matrix[a:row][a:col] = [0, 0]
      return max([l:score, l:element_value])
    endif

    if l:element_value == l:up_candidate
      let l:element_direction = or(l:element_direction, l:up)
    endif
    if l:element_value == l:left_candidate
      let l:element_direction = or(l:element_direction, l:left)
    endif
    if l:element_value == l:diag_candidate
      let l:element_direction = or(l:element_direction, l:upleft)
    endif

    let l:matrix[a:row][a:col] = [l:element_value, l:element_direction]

    if l:element_value > l:score
      if len(l:highest_scored_position_list) > 0
        call remove(l:highest_scored_position_list, 0, len(l:highest_scored_position_list)-1)
      endif
      call add(l:highest_scored_position_list, [a:row, a:col])
      return max([l:score, l:element_value])
    elseif l:element_value == l:score
      call add(l:highest_scored_position_list, [a:row, a:col])
      return max([l:score, l:element_value])
    else
      return max([l:score, l:element_value])
    endif
  endfunction

  " initialize matrix
  for i in range(len(l:tx))
      let l:matrix_row = []
      for j in range(len(l:ty))
        call add(l:matrix_row, [0,0])
      endfor
      call add(l:matrix, l:matrix_row)
  endfor

  let @a = ''
  for i in range(1, len(a:search_word))
    for j in range(1, len(a:buf_name))
      let l:score = CalcElement(i, j)
    endfor
  endfor

  let l:buf_name_position_list = []
  let @d = string(l:score)

  while len(l:highest_scored_position_list) > 0
    let l:cur_position = remove(l:highest_scored_position_list, -1)
    let [l:cur_row, l:cur_col] = l:cur_position
    let [l:cur_value, l:cur_direction] = l:matrix[l:cur_row][l:cur_col]

    if l:cur_value == 0
      break
    endif

    if and(l:cur_direction, l:up) > 0
      call add(l:highest_scored_position_list, [l:cur_row - 1, l:cur_col])
    endif
    if and(l:cur_direction, l:left) > 0
      call insert(l:buf_name_position_list, l:cur_col - 1)
      call add(l:highest_scored_position_list, [l:cur_row, l:cur_col - 1])
    endif
    if and(l:cur_direction, l:upleft) > 0
      call insert(l:buf_name_position_list, l:cur_col - 1)
      call add(l:highest_scored_position_list, [l:cur_row - 1, l:cur_col - 1])
    endif
  endwhile

  if @t == ''
    let @t = a:search_word . '#' . a:buf_name . '(' . l:score . ')'
  else
    call setreg('t', '|' . a:buf_name . '(' . l:score . ')', 'a')
  endif

  return [l:score, l:buf_name_position_list]
endfunction

function! GetHighlightPosition(position)
  let l:flag = 0
  let l:prev = -1
  let l:start = -1
  let l:result = []
  for pos in a:position
    if l:flag
      if pos - l:prev == 1
        let l:prev = pos
      else
        let l:flag = 0
        call add(l:result, [l:start, pos])
      endif
    else
      let l:start = pos
      let l:prev = pos
      let l:flag = 1
    endif
  endfor
  if l:flag
    call add(l:result, [l:start, a:position[-1]])
  endif
  return l:result
endfunction

function! DecorateText(text, position_list)
  let l:result_text = ""
  let l:idx = 0
  for [start, end] in a:position_list
    let l:result_text = a:text[l:idx:start - 1] . '[' . a:text[start:end] . ']'
    let l:idx = end + 1
  endfor
  if l:idx != len(a:text)
    let l:result_text = l:result_text . a:text[l:idx:]
  endif
  return l:result_text
endfunction

function! Helper(pop_bufnr, search_bufnr, contents)
    let l:is_search_buf = bufnr() == a:search_bufnr
    execute 'buffer!' . a:pop_bufnr
    setlocal modifiable
    call setbufline(a:pop_bufnr, 1, a:contents)
    setlocal nomodifiable

    if l:is_search_buf
      execute 'buffer!' . a:search_bufnr
    endif
    redraw
endfunction

function! PopupBuffer()

  " Function to capture and echo the text in the search buffer
  function! CaptureSearchText() closure
    " Get the content of the search buffer
    let l:text = join(getline(1,1), '')
    " Echo the content to the command line
    let l:search_word = l:text
    " initialize temp register
    let @t = ''
    if l:search_word == ''
      call RedrawBufferList(l:buffer_info_list, 0)
    else
      call SmithWaterman(l:search_word, l:buffer_info_list)
    endif
  endfunction

  function! SmithWaterman(search_word, buffer_info_list) closure
    let l:filtered_buffer_list = []
    let @p = string(a:buffer_info_list)
    for l:buffer_info in copy(a:buffer_info_list)
      let [l:score, l:position] = GetSmithWatermanScore(a:search_word, l:buffer_info.name)
      if l:score > 0
        let l:hlpos = GetHighlightPosition(l:position)
        let l:target_buf_info = {}
        let l:target_buf_info.score = l:score
        let l:target_buf_info.hlposition = l:hlpos
        let l:target_buf_info.decorated_text = DecorateText(l:buffer_info.name, l:hlpos)
        let l:target_buf_info = extend(l:target_buf_info, l:buffer_info)
        call add(l:filtered_buffer_list, l:target_buf_info)
      endif
    endfor
    let @r = string(l:filtered_buffer_list)

    call RedrawBufferList(l:filtered_buffer_list, 1)
  endfunction

  function! RedrawBufferList(buffers, flag) closure
    let @k = 'curruent_bufnr is ' . bufnr() . ' l:pop_bufnr is ' . l:pop_bufnr . ' l:search_bufnr is ' . l:search_bufnr

    let l:buf_len = len(a:buffers)


    if a:flag == 0

      if l:buf_len == 0
        call Helper(l:pop_bufnr, l:search_bufnr, ['there is no loaded buffer'])
        return
      endif

      let l:contents = copy(a:buffers)
            \ ->map({_, val -> val.name})
      call Helper(l:pop_bufnr, l:search_bufnr, l:contents)
      return
    else
      if l:buf_len == 0
        call Helper(l:pop_bufnr, l:search_bufnr, ['there is no searched buffer'])
        return
      endif
      let l:contents = copy(a:buffers)
            \ ->map({_, val -> val.decorated_text})
      call Helper(l:pop_bufnr, l:search_bufnr, l:contents)
      return
    endif
  endfunction

  let l:search_word = ''
  let l:buffer_info_list = GetLoadedBufferList()

  new
  let l:pop_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal noswapfile
  setlocal nobuflisted
  setlocal nomodifiable
  resize 20

  new
  let l:search_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal filetype=search
  setlocal noswapfile
  setlocal nobuflisted
  resize 1

  " echo l:pop_bufnr . ' ' . ' ' . l:search_bufnr
  call RedrawBufferList(l:buffer_info_list, 0)

  redraw

  " Create an autocommand for TextChangedI in the 'search' buffer
  autocmd TextChangedI <buffer> call CaptureSearchText()

endfunction


call PopupBuffer()

===


function! GetLoadedBufferList()
  let l:buf_info = getbufinfo()
  let l:listed_buffer_info = l:buf_info
        \ ->filter({_, val -> val.listed == 1 })
        \ ->map({_, val -> {'bufnr': val.bufnr, 'name': fnamemodify(expand(val.name), ":~:.")}})
  return l:listed_buffer_info
endfunction

function! GetSmithWatermanScore(search_word, buf_name)
  let l:tx = ' ' . a:search_word
  let l:ty = ' ' . a:buf_name

  " direction
  let l:up      = 0b001
  let l:left    = 0b010
  let l:upleft  = 0b100
  let l:default = 0b000

  let l:matrix = []
  let l:highest_scored_position_list = []
  let l:score = 0

  function! CalcElement(row, col, match = 3, mis_match = -3, gap_panalty = -2) closure
    " closure for calculate matrix element with free variables:
    " l:matrix, l:highest_scored_position_list, l:score, l:tx, l:ty
    " l:up, l:left, l:upleft, l:default

    let l:up_value = l:matrix[a:row - 1][a:col][0]
    let l:left_value = l:matrix[a:row][a:col - 1][0]
    let l:diag_value = l:matrix[a:row - 1][a:col - 1][0]

    let l:up_candidate = l:up_value + a:gap_panalty
    let l:left_candidate = l:left_value + a:gap_panalty

    let l:diag_candidate = l:diag_value + a:mis_match

    if l:tx[a:row] == l:ty[a:col]
      let l:diag_candidate = l:diag_value + a:match
    endif

    let l:element_value = max([l:up_candidate, l:left_candidate, l:diag_candidate])
    let l:element_direction = l:default

    if l:element_value < 0
      let l:matrix[a:row][a:col] = [0, 0]
      return max([l:score, l:element_value])
    endif

    if l:element_value == l:up_candidate
      let l:element_direction = or(l:element_direction, l:up)
    endif
    if l:element_value == l:left_candidate
      let l:element_direction = or(l:element_direction, l:left)
    endif
    if l:element_value == l:diag_candidate
      let l:element_direction = or(l:element_direction, l:upleft)
    endif

    let l:matrix[a:row][a:col] = [l:element_value, l:element_direction]

    if l:element_value > l:score
      if len(l:highest_scored_position_list) > 0
        call remove(l:highest_scored_position_list, 0, len(l:highest_scored_position_list)-1)
      endif
      call add(l:highest_scored_position_list, [a:row, a:col])
      return max([l:score, l:element_value])
    elseif l:element_value == l:score
      call add(l:highest_scored_position_list, [a:row, a:col])
      return max([l:score, l:element_value])
    else
      return max([l:score, l:element_value])
    endif
  endfunction

  " initialize matrix
  for i in range(len(l:tx))
      let l:matrix_row = []
      for j in range(len(l:ty))
        call add(l:matrix_row, [0,0])
      endfor
      call add(l:matrix, l:matrix_row)
  endfor

  for i in range(1, len(a:search_word))
    for j in range(1, len(a:buf_name))
      let l:score = CalcElement(i, j)
    endfor
  endfor

  let l:buf_name_position_list = []

  while len(l:highest_scored_position_list) > 0
    let l:cur_position = remove(l:highest_scored_position_list, -1)
    let [l:cur_row, l:cur_col] = l:cur_position
    let [l:cur_value, l:cur_direction] = l:matrix[l:cur_row][l:cur_col]

    if l:cur_value == 0
      break
    endif

    if and(l:cur_direction, l:up) > 0
      call insert(l:buf_name_position_list, -1)
      call add(l:highest_scored_position_list, [l:cur_row - 1, l:cur_col])
    endif
    if and(l:cur_direction, l:left) > 0
      call insert(l:buf_name_position_list, l:cur_col - 1)
      call add(l:highest_scored_position_list, [l:cur_row, l:cur_col - 1])
    endif
    if and(l:cur_direction, l:upleft) > 0
      call insert(l:buf_name_position_list, l:cur_col - 1)
      call add(l:highest_scored_position_list, [l:cur_row - 1, l:cur_col - 1])
    endif
  endwhile

  return [l:score, l:buf_name_position_list]
endfunction

function! GetHighlightPosition(position)
  let l:flag = 0
  let l:prev = -1
  let l:start = -1
  let l:result = []
  for pos in a:position
    if l:flag
      if pos - l:prev == 1
        let l:prev = pos
      else
        let l:flag = 0
        call add(l:result, [l:start, pos])
      endif
    else
      let l:start = pos
      let l:prev = pos
      let l:flag = 1
    endif
  endfor
  if l:flag
    call add(l:result, [l:start, a:position[-1]])
  endif
  return l:result
endfunction

function! DecorateText(text, position_list)
  let l:result_text = ""
  let l:idx = 0
  for [start, end] in a:position_list
    let l:result_text = a:text[l:idx:start - 1] . '[' . a:text[start:end] . ']'
    let l:idx = end + 1
  endfor
  if l:idx != len(a:text)
    let l:result_text = l:result_text . a:text[l:idx:]
  endif
  return l:result_text
endfunction

function! ScoreSortKey(lhs, rhs)
  return a:rhs.score - a:lhs.score
endfunction

function! Helper(pop_bufnr, search_bufnr, contents)
  let l:is_search_buf = bufnr() == a:search_bufnr

  let l:head = a:contents[0]
  let l:ct = copy(a:contents)
  if has_key(l:head, 'decorated_text')
    let l:ct = filter(l:ct, {_, val -> val.score > 0})
    let l:ct = sort(l:ct, 'ScoreSortKey')
    let l:lines = copy(l:ct)
          \ ->map({_, val -> val.score . '	' . val.decorated_text})
  else
    let l:lines = copy(l:ct)
          \ ->map({_, val -> val.name})
  endif

  execute 'buffer!' . a:pop_bufnr
  setlocal modifiable
  normal ggdG
  call setbufline(a:pop_bufnr, 1, l:lines)
  setlocal nomodifiable

  if l:is_search_buf
    execute 'buffer!' . a:search_bufnr
    call cursor(1, 9999)
  endif
  redraw
  return l:ct[0].bufnr
endfunction

function! PopupBuffer()

  " Function to capture and echo the text in the search buffer
  function! CaptureSearchText() closure
    " Get the content of the search buffer
    let l:search_buffer_lines = getline(1,'$')
    if len(l:search_buffer_lines) > 1
      execute 'quit!'
      execute 'quit!'
      execute 'buffer! ' . l:target_bufnr
      return
    endif
    let l:search_word = join(getline(1,1), '')
    " initialize temp register
    if l:search_word == ''
      call RedrawBufferList(l:buffer_info_list, 0)
    else
      call SmithWaterman(l:search_word, l:buffer_info_list)
    endif
  endfunction

  function! SmithWaterman(search_word, buffer_info_list) closure
    let l:filtered_buffer_list = []
    for l:buffer_info in copy(a:buffer_info_list)
      let [l:score, l:position] = GetSmithWatermanScore(a:search_word, l:buffer_info.name)
      if l:score > 0
        let l:hlpos = GetHighlightPosition(l:position)
        let l:target_buf_info = {}
        let l:target_buf_info.score = l:score
        let l:target_buf_info.hlposition = l:hlpos
        let l:target_buf_info.decorated_text = DecorateText(l:buffer_info.name, l:hlpos)
        let l:target_buf_info = extend(l:target_buf_info, l:buffer_info)
        call add(l:filtered_buffer_list, l:target_buf_info)
      endif
    endfor

    call RedrawBufferList(l:filtered_buffer_list, 1)
  endfunction

  function! RedrawBufferList(buffers, flag) closure

    let l:buf_len = len(a:buffers)

    if a:flag == 0

      if l:buf_len == 0
        let l:target_bufnr = Helper(l:pop_bufnr, l:search_bufnr, l:target_buffer_list)
        return
      endif

      let l:target_buffer_list = copy(a:buffers)
      let l:target_bufnr = Helper(l:pop_bufnr, l:search_bufnr, l:target_buffer_list)
      return
    else
      let l:target_buffer_list = [{'name': 'there is no searched buffer', 'bufnr': -1}]
      if l:buf_len == 0
        let l:target_bufnr = Helper(l:pop_bufnr, l:search_bufnr, l:target_buffer_list)
        return
      endif
      let l:target_buffer_list = copy(a:buffers)
      let l:target_bufnr = Helper(l:pop_bufnr, l:search_bufnr, l:target_buffer_list)
      return
    endif
  endfunction

  let l:search_word = ''
  let l:buffer_info_list = GetLoadedBufferList()
  let l:target_buffer_list = [{'name': 'there is no loaded buffer', 'bufnr': -1}]
  let l:target_bufnr = -1

  new
  let l:pop_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal filetype=bufpop
  setlocal noswapfile
  setlocal nobuflisted
  setlocal nomodifiable
  resize 20

  new
  let l:search_bufnr = bufnr()
  setlocal buftype=nofile
  setlocal filetype=search
  setlocal noswapfile
  setlocal nobuflisted
  resize 3

  " echo l:pop_bufnr . ' ' . ' ' . l:search_bufnr
  call RedrawBufferList(l:buffer_info_list, 0)

  redraw

endfunction


call PopupBuffer()
