# liftIO2025
13:00

## opening

설문내용 얘기 중
셀피스에서 주최했나봐

함수형 프로그래밍

LLM이 막대한 코드를 생성해내는 이 시기에 중요한 것은 단순성
어떻게 이해하기 쉽고 유지보수하기 쉽게 만들 것인가

4개의 발표를 이 맥락에서 보면 좋을 것

진짜로 추구하는 것이 뭔지 생각을 해보면 얻어가는 것이 많을 것


- 셀파스: IOT 자산관리 서비스 제공, smply
채용 관심있으면 말해주기를

- 청구스: 미수 청구 서비스, 재무 결제처리 자동화
제때 청구를 드리는 것만 해도 미수가 80% 줄더라

채용은 지금 하고 있지 않음, 엘릭서(Elixir) 쓰고 있음

함수형을 쓸때의 생산성/유지보수성

## Elixir 생산성의 비밀: 메타프로그래밍 (코드 짜는 코드) - 이재철(청구스, 데브올컴퍼니 CEO)
Ash project contributer
10년차 엘릭서 개발자

엘릭서 웹 프레임워크 피닉스
이거 웹개발 언어였어?

GPL vs DSL
범용 vs 특정 도메인

엘릭서는 macro로 DSL 생성
internal 하게 생성 가능

### macro
- function: value -> value(런타임 실행
- macro: ast -> ast(컴파일타임)
- quote키워드

- ast를 직접 다루면서 필요한 문법을 만들 수 있는게 신기하네
- 실제로 사용하는 것을 직접 커스텀 문법으로 할수 있는게 구미가 당기는데
- def는 키워드가 아니라 override되는것도 신기하고
- macro를 모아 dsl을 만들기

- 그리고 더 나아가서 이걸 쉽게해주는 Spark라는 프레임워크
- ruby는 런타임에 메타프로그래밍이 일어남
- 엘릭서는 IDE가 컴파일타임에 새 문법을 인식해서 lsp를 지원가능

- Ash
- 개발자가 macro를 잘 몰라도 spark와 ash로 쉽게 가능하

- 엘릭서는 DSL을 컴파일타임에서 사용 가능
- 지금은 메타프로그래밍으로 고급 개발자 수준에서 spark와 ash로 진입장벽을 많이 낮춤

Q&A
Q: lisp에 비슷해보이는데 macro를 거기선 위험하다고 안씀. 
A: homo 같은 형태로 되어야 하는데 엘릭서는 사람이 읽기 쉬운 모양으로 짤수 있음

Q: 매크로에 브레이크포인트를 넣는 등 디버깅을 지원하는지?
A: 엘릭서는 언어 컨셉차원에서 브레이크포인트를 지원하지 않음. 테스트를 잘 짜야함

Q: 매크로는 AST를 받아 AST를 반환하며 컴파일단계에서 일어남. 재귀 허용함?
A: 재귀 허용함. 일반적인 함수 작성과 크게 다르지는 않음


### 사랑받는 함수형 프로그래밍, Go와 JS로 쓴 대수적 이펙트 핸들러, 온더그라운드, 박주형

함수란?

함수를 stack 대신 queue로 돌리겠다???

아 이게 함수형이 동작하는 메커니즘인가?
lazy

태생이 breadth-first, queue기반
부모를 자식노드로 치환


execution과 실행전략/구조를 분리
이걸 순수함수/이펙트로 엮네


### Clojure로 도메인 모델링하기

1. 도메인과 도메인 모델링
  - 도메인이란?
    - 소프트웨어로 해결하려는 비즈니스 문제 영역
  - 도메인 모델링이란?
    - 비즈니스 개념과 규칙을 코드로 표현하는 과정 (비즈니스 개념 + 비즈니스 규칙)
  - 도메인 모델링 vs 데이터 모델링
    - 데이터: 데이터를 어떻게 저장할 것인가
    - 도메인: 비즈니스를 어떻게 할 것인가
  1. 도메인 모델링의 좋은 점
    - 명확하고 소통이 쉬움 (비즈니스 용어를 사용한다)
    - 변경과 테스트가 쉬움
      - 비즈니스 로직이 한 곳에 모임 => 수정 위치가 명확
      - 비즈니스 변경이 한 곳에서 완결
      - 순수함수로 구성 가능(이펙트는 다른 곳에 전이)
  2. 함수형의 핵심 특징
    - 데이터와 함수의 분리
    - 기본값이 불변 => 직관적, 멱등성, 오해의 소지 줄임
2. 도메인 모델링 구현
  1. 기기 도메인 모델 구현(7가지 구성 요소)
  - 비즈니스 문제: 회사 기기를 직원들에게 할당하고 관리
  - 기기: {속성: [ID, 모델명], 상태: [사용가능,할당됨,수리중,폐기], 할당: [누구에게,언제]}
  - 비즈니스규칙
    - 사용가능한 기기만 할당 가능
    - 수리중인 기기는 재할당 불가
  2. 예시
  - 스키마: 문서이면서 자동 검증 도구
  - factory: 스키마는 단순 맵인데 이게 맵인지 스키마인지 어떻게 아느냐? validate를 통과한 map은 스키마이다
    - 값과 필수속성은 사용자가 알 필요가 없다. 나머지 속성은 사용자에게 노출시키지 않음. 필요한 값만 전달
  - 커맨드: 모델 변경 <이 모델을 다루는 역할은 오직 command만 담당한다.>
  - Query: 조회모델. 단순맵이지만 절대 map을 직접 수정하지 않고, query 함수로 조회, command 함수로 변경한다
    - 모든 코드를 보면서 고치는 일이 일어나지 않도록
  - repository: 모델 영속화, 프로토콜을 정의하여 인터페이스 구현, 인프라 레이어에서 실제 코드 구현
    - 순수해야 함. 
    - 근데 실제코드는 jdbc sql을 쓰고 있음
    - 바꿀지 고민했지만 구현체를 그대로 놔두기로 결정함(순수성을 희생하여 실용성). 어떤 비즈니스 로직도 넣지 않고, ansi를 준수하도록 구현
  - Mapper: 모델 변환/ DB용으로 map 변환 혹은 vise versa
  - interface: 외부 공개
3. 마무리
  - 사람이 읽기 좋은 코드 = AI가 읽기 좋은 코드
  - 코딩 컨벤션의 견고함이 추가 코드/로직 변경을 용이하게 함(불편함을 감수할 가치)
  - 코딩하는 시간은 줄고 도메인/비즈니스에 집중하는 시간이 늘었음
  - 혼자 일하면 상관없지만 같이 일하기 때문에 중요


Q: 연관참조 간접/직접 참조가 있는데 n+1 문제나 코드가 더러워지는데 어떻게 해결하는지?
A: 변경에 용이한 구조로 만들어야 함. 빠르게 판단하고 된다안된다가 나오도록 설계.
DDD aggregate 홀때 주모델이 부모델n이 어떤 특성을 가지냐가 중요. n이 늘어나는 한계가 50,100개까지면 하나로 묶어도 됨
아니면 나눠야 성능문제 줄임. 경험이 줄요. DB 튜닝은 쉬워야하고 application 단에서 수정이 용이해야 함

Q: 디바이스히스토리 관리?, 상태에 따른 변경시각 필드를 넣은게 많아질때는 문제 아닐까?
A: 따로 만듦. ID로 간접참조. 모델링의 묘. 그런 생각이 되면 시그널, 모델을 다시 생각

Q: DDD 하는데 비즈니스 엮이는게 많아지면 체인순서로 인한 복잡성 처리 방안
A: 뭔가 많아진다는 거는 여러포인트에서 시그널이라고 생각함. 규칙이 많아지니까 복잡해진다 하지만 모델링으로 풀수 있다고 생각
체이닝, 변환작업은 도메인 레이어가 아니라 어플리케이션 레이어에서 오케스트레이션이 담당. 어플리케이션 레이어에서도 하나가 하나만 담당하도록
설계가 중요.


도메인 주도 설계를 위한 함수형 프로그래밍

### Optique: TypeScript의 타입 추론으로 CLI 유효성 검사를 대체하기, 홍민희

- optparse-applicative(haskell) 에 영감
- 파서 컴비네이터란?
  - 파서: 입력을 파싱하아여 값을 반환하는 함수
  - 컴비네이터: 파서를 조합하여 새로운 파서를 만드는 함수
  - 작은 파서를 조합하는 방식으로 파서를 작성하게 됨
- 그래서 어떻게 구현함?
  - cli 받을 때 구조파싱 선행, 값파싱 후행
  - 값 파싱
    - 1계층: 값 파서(value parsers), string, integer, url, choice
    - 2계층: 기본 파서(primitives), flag, option, argument, command, constant
    - 3계층: 수정자(modifier), optional, withDefault, map
    - 4계층: 구성자(constructs), object, or, merge
  - 구조파싱(Parser 인터페이스)
    - TValue: 최종 결과 타입(사용자가 받는 값)
    - TState: 시도했는지 판단하기 위해
  - InferValue<T> 유틸리티 타입
    - 팬턴타입을 통해 타입 추론
  - 우선순위 기반 파싱
    - argument와 flag가 subcommand가 subcomm.인지 supercommand의 argument인지 파악하기 위해 필요
  - message 템플릿 리터럴 만듦 (이런것도 신경쓰는구나)
  - 도움말 자동 생성
    - 파서로부터 토움말을 자동생성
    - document tree를 만듦. formatDocPage를 만들어서 만듦, DocPage 제공

