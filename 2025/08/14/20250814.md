state를 쓰는 이유:

변화시 re-rendering 기능
새로고침시

react는 이전 virtual dom과 현재 virtual dom을 비교함
변경된 부분만 반영해서 dom을 rerendering함

useState의 state 값은 rendering한 이후에 변경됨

다음 렌더링에 반영됨

setNumber(5) === setNumber(n => 5)

setState 메서드는 내부적으로 function 함수를 받는다

리액트 내부에서 객체를 비교할 때 주소값을 통해서 변경을 감지하기 때문에
해당 객체의 필드를 변경해도 변경을 감지하지 못한다.

자바스크립트 내에서 중첩은 없다
object의 value값으로 다른 object를 가리킬 수 있을 뿐

immer

useImmer

function handleFirstNameChainge(e) {
    setPerson({
        ...person,
        firstName: e.target.value
    })
}

function handleLastNameChainge(e) {
    setPerson({
        ...person,
        lastName: e.target.value
    })
}

function handleEmailChainge(e) {
    setPerson({
        ...person,
        email: e.target.value
    })
}

setPerson(



Welcome to Node.js v20.17.0.
Type ".help" for more information.
> let person = { firstName: 'a', lastName: 'b', email: 'c' }
undefined
> person
{ firstName: 'a', lastName: 'b', email: 'c' }
> let a = { ...person, lastName: 'test' }
undefined
> a
{ firstName: 'a', lastName: 'test', email: 'c' }
>
```js
function handleFirstNameChainge(e) {
    setPerson({
        ...person,
        firstName: e.target.value
    })
}
```

function handleFirstNameChainge(e) {
    ||setPerson({ ...person, firstName: e.target.value })||
}

async function handleClick() {
    setPending(pending => {
            setPending(pending => pending + 1);
        }
        await delay(3000)
        setCompleted(comp => comp + 1)
        pending - 1
        };
    )
}

async function handleClick() {
    setPending(p => p + 1);
    delay(3000);
    setPerson(p => p - 1);
    setCompleted(c => c + 1);
}

이렇게 되는구나

