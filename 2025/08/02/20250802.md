```lua
-- Reselect the last visual selection
vim.cmd.normal('gv')

-- Get start and end positions of the current visual selection
local start_pos = vim.fn.getpos("'<")  -- [bufnum, lnum, col, off]
local end_pos   = vim.fn.getpos("'>")  -- [bufnum, lnum, col, off]
local start_line_nr = start_pos[2]

-- Example: print positions
print(string.format("Start: line %d, col %d", start_pos[2], start_pos[3]))
print(string.format("End:   line %d, col %d", end_pos[2], end_pos[3]))

print(vim.fn.getline(start_line_nr))
```
-- Get start and end positions of the current visual selection

lua vim.fn.setline(16, '-- Get start and end positions of the current visual selection')

```lua
local M = {}

local MM = {}

function MM.send_esc()
  vim.api.nvim_feedkeys(
    vim.api.nvim_replace_termcodes('<Esc>', true, false, true),
    'n',
    true
  )
end

function MM.surround_visual(start_char, end_char)
  local start_nomal_cmd = 'a' .. start_char
  local end_nomal_cmd = 'i' .. end_char
  vim.cmd.normal('c')
  vim.cmd.normal(start_nomal_cmd)
  vim.cmd.normal('gp')
  vim.cmd.normal(end_nomal_cmd)
end

function MM.surround_visual_line(start_char, end_char, line_break)
  local start_nomal_cmd = 'a' .. start_char
  local end_nomal_cmd = 'i' .. end_char
  if line_break then
    vim.cmd.normal('c')
    vim.cmd.normal(start_nomal_cmd)
    vim.cmd.normal('gp')
    vim.cmd.normal(end_nomal_cmd)
  else
    local start_pos = vim.fn.getpos("'<")  -- [bufnum, lnum, col, off]
    local end_pos   = vim.fn.getpos("'>")  -- [bufnum, lnum, col, off]
    local start_line_nr = start_pos[2]
    local end_line_nr = end_pos[2]

    vim.fn.setline(start_line_nr, start_char .. vim.fn.getline(start_line_nr))
    vim.fn.setline(end_line_nr, vim.fn.getline(end_line_nr) .. end_char)
    MM.send_esc()
  end
end

function MM.surround_visual_block(start_char, end_char)
  local write_cmd = 'c' .. start_char .. end_char
  vim.cmd.normal(write_cmd)
  vim.cmd.normal('gP')
end


function MM.surround_factory(start_char, end_char, line_break)
  local visual_mode_dict = {
    v = function() MM.surround_visual(start_char, end_char) end,
    V = function() MM.surround_visual_line(start_char, end_char, line_break) end,
    ["\22"] = function() MM.surround_visual_block(start_char, end_char) end
  }
  vim.cmd.normal('gv')
  local visual_mode = vim.fn.visualmode()
  local handler = visual_mode_dict[visual_mode]
  if handler then
    return handler()
  end
end

function M.backtick(line_break)
  MM.surround_factory('`', '`', line_break)
end

function M.quote(line_break)
  MM.surround_factory("'", "'", line_break)
end

function M.double_quote(line_break)
  MM.surround_factory('"', '"', line_break)
end

function M.round_braket(line_break)
  MM.surround_factory('(', ')', line_break)
end

function M.square_braket(line_break)
  MM.surround_factory('[', ']', line_break)
end

function M.angle_braket(line_break)
  MM.surround_factory('<', '>', line_break)
end

function M.curly_braket(line_break)
  MM.surround_factory('{', '}', line_break)
end

M.curly_braket()
```


```txt
backtick `
quote '
double_quote "
round_braket (
square_braket [
angle_braket <
```

```awk
function makeCommand(cmd, func_name,    str) {
  str = "vim.api.nvim_create_user_command(\n"
  str = str "  '" cmd "',\n"
  str = str "  function(opts)\n"
  str = str "    surround." func_name "()\n"
  str = str "  end,\n"
  str = str "  { range = 0 }\n"
  str = str ")"
  return str
}

function makeKeymap(mode, keymap, cmd) {
  return "vim.keymap.set('" mode"', '<space>" keymap"', ':" cmd "<CR>')"
}

{
  cmd = "Surround" toupper(substr($1,1,1)) substr($1,2)

  print makeCommand(cmd, $1)
  print ""
  print(makeKeymap("n", $2, cmd))
  print(makeKeymap("v", $2, cmd))
  print ""
}


```txt
vim.api.nvim_create_user_command(
  'SurroundBacktick',
  function(opts)
    surround.backtick()
  end,
  { range = 0 }
)

vim.keymap.set('n', '<space>', ':SurroundBacktick<CR>')
vim.keymap.set('v', '<space>', ':SurroundBacktick<CR>')

vim.api.nvim_create_user_command(
  'SurroundQuote',
  function(opts)
    surround.quote()
  end,
  { range = 0 }
)

vim.keymap.set('n', '<space>', ':SurroundQuote<CR>')
vim.keymap.set('v', '<space>', ':SurroundQuote<CR>')

vim.api.nvim_create_user_command(
  'SurroundDouble_quote',
  function(opts)
    surround.double_quote()
  end,
  { range = 0 }
)

vim.keymap.set('n', '<space>', ':SurroundDouble_quote<CR>')
vim.keymap.set('v', '<space>', ':SurroundDouble_quote<CR>')

vim.api.nvim_create_user_command(
  'SurroundRound_braket',
  function(opts)
    surround.round_braket()
  end,
  { range = 0 }
)

vim.keymap.set('n', '<space>', ':SurroundRound_braket<CR>')
vim.keymap.set('v', '<space>', ':SurroundRound_braket<CR>')

vim.api.nvim_create_user_command(
  'SurroundSquare_braket',
  function(opts)
    surround.square_braket()
  end,
  { range = 0 }
)

vim.keymap.set('n', '<space>', ':SurroundSquare_braket<CR>')
vim.keymap.set('v', '<space>', ':SurroundSquare_braket<CR>')

vim.api.nvim_create_user_command(
  'SurroundAngle_braket',
  function(opts)
    surround.angle_braket()
  end,
  { range = 0 }
)

vim.keymap.set('n', '<space>', ':SurroundAngle_braket<CR>')
vim.keymap.set('v', '<space>', ':SurroundAngle_braket<CR>')

vim.api.nvim_create_user_command(
  'SurroundCurly_braket',
  function(opts)
    surround.curly_braket()
  end,
  { range = 0 }
)

vim.keymap.set('n', '<space>', ':SurroundCurly_braket<CR>')
vim.keymap.set('v', '<space>', ':SurroundCurly_braket<CR>')
```



```lua
local M = {}

```



```lua
local M = {}

local MM = {}
```



### surround-visual 포팅
- 개인적으로 사용하고 있던 `surround.vim`을 lua 버전으로 포팅했다.
- vimscript를 lua로 변경하면서 고려한 점은 다음과 같다.
  - 커서가 위치한 단어 기반에서 visual 모드로 지정한 영역 기반으로 변경
    - 파일의 절대경로나 url, uuid 등, 커서가 위치한 단어(`<cword>`)는
- 두가지 문제 발견
  - 클로저를 사용해 내부 함수를 고정하면서, 마지막 글자에 따라 end_normal_cmd가 달라져야 함에도 고정이 되어버리는 문제 발견
    - 하나의 함수로 만들면 아마 될 것 같지만, 다른 함수에 중복 로직을 사용할 수 없을 것으로 보임
      - 은 실험 먼저
      - dict를 사용하지 않으면 해결됨 확인 >> 해결 확인
  - 첫 번째 호출시 반응하지 않는 문제
  - 한 글자에 대해서 제대로 작동하지 않는 문제?
/home/widehyo/.config/nvim/lua/util/surround.lua
