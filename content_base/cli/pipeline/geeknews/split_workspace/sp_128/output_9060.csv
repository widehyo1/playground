"https://news.hada.io/topic?id=19942","European Alternative 사이트에 방문자 수 증가중 - 이 트렌드는 무엇인가?","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           European Alternative 사이트에 방문자 수 증가중 - 이 트렌드는 무엇인가?

     * 클라우드/SaaS등의 디지털 제품을 위한 유럽의 대체제들을 소개하는 사이트
     * 2025년 현재까지 130만 명의 방문자가 웹사이트를 방문했으며, 트래픽이 1100% 증가
     * 평균 페이지 체류 시간은 2분 47초로, 사용자가 라이브러리에 관심을 가지고 잘 참여하고 있음
     * Reddit이 Google을 추월하고, 개인정보 보호 검색 엔진이 주목받음
          + 2025년 상반기 주요 소스 보고서에서 Reddit이 31만 1천 명의 방문자를 유치하며 Google(19만 3천 명)을 추월함
          + DuckDuckGo, Ecosia, Qwant와 같은 개인정보 보호 검색 엔진도 주요 트래픽 소스로 작용함
     * 사람들이 찾는 상위 5개 카테고리
          + 이메일 제공자, 검색 엔진, 클라우드 컴퓨팅 플랫폼, 내비게이션 앱, 웹 분석 서비스가 인기 있는 카테고리로 나타남
          + B2B 카테고리가 다양하고 높은 순위를 차지하며, 기업들이 개인정보 보호 분석, 호스팅, 인프라 대안을 적극적으로 찾고 있음
     * 유럽을 넘어선 수요
          + 유럽 국가들이 대부분의 방문자를 차지하지만, 미국도 10만 명 이상의 방문자를 보내며 4위를 차지함
          + 캐나다와 인도도 상위 25위 안에 들어가며, 전 세계적으로 개인정보 보호 중심의 디지털 도구로의 전환이 진행 중임
     * 개인정보 보호 도구로의 전환을 주도하는 유럽 국가들
          + 독일이 37만 9천 명의 방문자로 선두를 달리며, 네덜란드와 프랑스가 그 뒤를 이음
          + 반면, 건지섬은 130명의 방문자를 기록하며, 바티칸 시국과 생마르탱은 각각 3명의 방문자를 기록함
     * 주목받는 유럽 도구들
          + Mailbox.org, ProtonMail, Soverin과 같은 이메일 제공자와 Startpage, Qwant와 같은 검색 엔진이 인기를 끌고 있음
          + 웹사이트에서 이러한 도구로의 총 아웃바운드 클릭 수가 120만 건을 넘으며, 미국 방문자만으로도 16.8%의 전환율을 기록함
     * 도구 선택에 도움이 필요함?
          + EU에서 제작된 B2B 도구를 검토하여 몇 가지 추천 도구를 선정함
          + 이 도구들은 EU 내에 본사를 두고 있으며, GDPR을 준수하고 높은 품질을 자랑함
     * 개인정보 보호 웹 분석의 부상
          + Plausible Analytics는 6년 전 개인정보 보호를 우선시하는 대안으로 시작됨
          + 2025년에 2700% 이상의 고유 방문자 증가를 기록하며, 개인정보 보호 웹 분석에 대한 수요가 급증하고 있음

        Hacker News 의견

     * 유럽인들은 미국의 기술과 군사 수출품을 기꺼이 구매하여 미국에 돈을 벌어주고 유럽을 기술적, 정치적으로 미국에 의존하게 했음. 그러나 미국은 이것이 나쁜 거래라고 판단하고 유럽으로부터 더 많은 돈과 의존성을 얻고자 했음. 그래서 유럽은 자체 기술과 군사에 투자하여 미국에 대한 의존도를 줄이고 경쟁자가 되었음. 트럼프가 이끌어낸 결과가 미국을 더 위대하게 만들었는지 묻고 있음
     * 내 직장에서는 태도 변화가 눈에 띄게 나타났음. 우리는 Mistral을 OCR에 사용하기로 결정했음. 이전에는 SV 제품과의 초기 마찰 때문에 EU 제품을 사용하려는 시도가 무시되었지만, 이제는 모두가 EU 제품을 사용하는 데 동의하고 있음. AWS/Azure K8s 클러스터를 사용하지 않는 방향으로 이동하고 있음
     * 미국 제품 불매운동뿐만 아니라 우리의 선택이 영향을 미친다는 인식이 증가하고 있음. 어떤 제품을 구매하고 사용하는지가 중요함. 이 움직임이 더 확산되기를 바람
     * Q1 실적 보고서가 이러한 행동이 주류인지 여부를 보여줄 것임. 현재 Tesla의 유럽 판매량이 크게 감소했으며, Tesla는 불매운동의 주요 대상임. Coca Cola, Nike, Amazon과 같은 소비자 기업도 유럽 판매량이 크게 감소할지 주목할 만함
     * 많은 사람들이 빅테크 회사를 피하고 있으며, Instagram, Google, Gmail, WhatsApp, ChatGPT, Amazon, X와 같은 서비스를 피하는 것이 더 쉬워졌음. Signal, Telegram, Mastodon, Posteo, Proton과 같은 대체 플랫폼을 사용하는 것이 더 가능해졌음. Amazon을 피하는 것은 여전히 어려움. 그러나 작은 변화도 가치가 있음
     * 전문적 관점에서, 일부 고객은 정치적 위험과 윤리적 문제로 인해 AWS/Vercel을 피하고 있음. AWS에서 Vercel로 이동하는 경우도 있음. 개인적으로 윤리적 고려와 정치적 위험을 강조함. 프로젝트 요구사항과 팀 구조가 허용하는 경우 자체 관리 Kubernetes 클러스터를 선호함
     * 독일의 ""Mittelstand""는 일반적으로 벤더 종속을 피하려고 함. 이들은 사설 및 공공 클라우드 서비스를 결합하여 클라우드 제공업체를 빠르게 전환할 수 있는 솔루션을 구현함
     * 웹사이트를 방문하는 것과 실제로 이동하는 비율이 궁금함. 개인적으로 ""Go European"" 브라우저 확장 프로그램을 설치한 후 전환을 시작했음. 사용자 고착성을 깨는 것이 어려움
     * 현재 많은 새로운 고객이 유입되고 있으며, 이들은 EU, 영국, 캐나다, 동남아시아, 호주에서 온 열정적인 스타트업이나 중소기업임. AWS/GCloud/Azure에 더 이상 투자하는 것이 좋은 생각이 아니라고 판단함. 정치가 주된 촉매제임
     * ""Non-US Alternatives"" 사이트가 있으면 캐나다, 호주, 중국 등에서 어떤 대안이 있는지 알 수 있을 것임
     * 미국은 세계화를 촉진했고, 세계화 과정을 끝냈음
     * 유용한 정보를 제공하는 전용 서브레딧이 있음
"
"https://news.hada.io/topic?id=19906","NestJS에서 DB를 연동한 단위 테스트 환경 구축 공유 (Sociable Test)","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            NestJS에서 DB를 연동한 단위 테스트 환경 구축 공유 (Sociable Test)

    1. 개요

     * Sociable Test(실제 DB 연동) 방식의 단위 테스트 구축 방법 공유
     * TypeORM 같은 ORM은 타입 안전성 문제가 있어, 실제 DB를 사용한 테스트가 필요함

    2. Solitary Test vs Sociable Test

     * 비교
          + Solitary Test 는 의존성을 Mock으로 대체하여 독립적으로 테스트 (빠르지만 실제 환경과 차이가 발생할 수 있음)
          + Sociable Test 는 실제 외부 의존성(DB)과 함께 테스트하여 신뢰성 확보 가능 (속도가 느리지만 현실적인 문제를 조기에 발견)
     * Solitary Test의 한계
          + 모킹으로는 실제 DB와의 상호작용 문제를 완벽히 발견하기 어려움
          + TypeORM의 타입 체크 문제로 인해 런타임 에러가 발생할 수 있음
     * Sociable Test 필요성
          + 실제 DB와의 연동을 통해 복잡한 쿼리, 트랜잭션, 관계 설정 문제를 검증할 수 있음
          + 테스트 데이터베이스를 설정하여 트랜잭션 방식으로 데이터 격리 테스트 수행
     * DB Sociable Test의 장점과 주의점
          + 장점: 신뢰성 높은 테스트, ORM 관련 문제 조기 발견, 스키마 불일치 확인
          + 주의점: 테스트 속도 저하, 환경 설정 복잡, 트랜잭션 관리 필요

    3. NestJS에서 DB 연동 테스트 구현

     * 설정
          + MySQL을 이용한 테스트 DB 연결 설정
          + 트랜잭션을 활용하여 각 테스트의 변경 사항을 롤백 처리
     * Jest 테스트 프레임워크의 라이프사이클 활용
          + beforeAll / beforeEach / afterEach / afterAll 를 이용
          + DB 초기화 및 연결, 트랜잭션 시작 및 종료 설정

    4. 결론

     * 단위 테스트 작성시 Solitary Test와 Sociable Test를 적절히 조합하여 사용하면 좋음
     * ORM 관련 문제를 방지하기 위해 Sociable Test는 큰 도움이 될 수 있음
"
"https://news.hada.io/topic?id=19971","TLA+ - 프로그램 및 동시/분산 시스템을 모델링하기 위한 고급 언어","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                TLA+ - 프로그램 및 동시/분산 시스템을 모델링하기 위한 고급 언어

     * TLA+는 코드 수준이 아닌 상위 수준에서 소프트웨어를 모델링하고, 회로 수준이 아닌 상위 수준에서 하드웨어를 모델링하기 위한 언어임
     * 모델을 작성하고 이를 검사할 수 있는 통합 개발 환경(IDE)을 제공
     * 엔지니어들이 가장 많이 사용하는 도구는 TLC 모델 검사기이며, 증명 검사기도 제공
     * TLA+는 수학에 기반하며 어떤 프로그래밍 언어와도 유사하지 않음
     * 대부분의 엔지니어는 TLA+보다 PlusCal을 통해 시작하는 것이 더 쉬움
     * TLA+ 모델은 일반적으로 ""스펙(Specification)""으로 불림. 아래 소개에서는 모델이라고 부름

PlusCal

     * PlusCal은 알고리듬, 특히 병렬 및 분산 알고리듬을 작성하기 위한 언어
     * 의사코드 대신 테스트 가능한 정확한 코드로 알고리듬을 작성하는 데 사용됨
     * 간단한 프로그래밍 언어처럼 보이며, 병행성과 비결정성을 표현할 수 있는 구조를 제공함
     * 수학적 수식을 표현식으로 사용할 수 있어 매우 표현력이 높음
     * PlusCal 알고리듬은 TLA+ 모델로 변환되며, TLA+ 도구로 검증 가능
     * 프로그래밍 언어처럼 보이므로 배우기 쉬우나, 복잡한 모델 구조화에는 TLA+가 더 적합

모델이란 무엇인가

     * 컴퓨터와 네트워크는 연속적인 물리 법칙을 따르지만, 이들의 동작은 이산적 사건의 집합으로 모델링하는 것이 자연스러움
     * 실제 시스템을 완벽히 묘사하는 모델은 없으며, 모델은 특정 목적을 위한 시스템의 일부 측면을 묘사함
     * TLA+는 상태 기반 모델링 언어로, 시스템의 실행을 상태들의 순서로 표현함
     * 사건은 연속된 두 상태 쌍으로 표현되며 이를 '단계(step)'라 부름
     * 시스템은 가능한 모든 실행을 설명하는 행동들의 집합으로 모델링됨

코드 수준 이상의 모델링

     * TLA+는 코드 수준 이상의 시스템 모델링에 사용됨
     * 예를 들어, 유클리드 알고리듬은 코드가 아닌 절차로서 최대공약수(GCD)를 계산하는 방식으로 설명 가능함
          + 변수 x를 M, y를 N으로 설정함
          + x와 y 중 작은 값을 큰 값에서 반복적으로 뺌
          + x와 y가 같아질 때까지 반복하고, 그 값이 GCD임
     * 이러한 설명은 변수 타입이나 예외 처리 등의 세부사항을 생략하며, 본질적인 알고리듬 개념만 표현함
     * 코딩에만 집중할 경우 좋은 알고리듬을 찾기 어려움 → 추상적 사고가 필요함
     * 대부분의 프로그래머는 고수준 모델 없이 코딩을 시작하며, 이로 인해 설계 오류가 발생함
     * TLA+는 코드의 동작과 방법을 명확하게 기술할 수 있는 고수준 모델 언어임
     * 복잡한 시스템일수록 단순화가 중요하며, 이는 코드 기술이 아니라 고차원 사고를 통해 달성됨
     * 한 산업 프로젝트에서, TLA+ 모델링으로 실시간 운영체제의 코드 크기를 10분의 1로 줄인 사례가 있음
     * 모델링은 설계 오류를 사전에 찾는 데 효과적이며, 테스트나 코드 수정보다 신뢰성 높음

병렬 시스템 모델링

     * 병렬 시스템은 동시에 작동하는 여러 컴포넌트(프로세스)로 구성됨
     * 분산 시스템은 공간적으로 분리된 프로세스들이 메시지를 통해 통신함
     * TLA+는 전체 시스템 상태를 전역 상태로 모델링함
     * 40년 이상의 경험에 따르면, 분산 시스템을 전역 상태 기반으로 모델링하는 것이 가장 일반적으로 유용함

상태 기계(State Machine)

     * TLA+는 다음 두 요소로 행동 집합을 정의함:
          + 초기 조건: 가능한 시작 상태 지정
          + 다음 상태 관계: 가능한 단계(연속된 상태 쌍) 지정
     * 이 두 조건을 만족하는 행동들의 집합이 모델임
     * 이러한 모델은 상태 기계(state machine)라 불림
     * 유한 상태 기계(finite-state machine)는 상태 수가 유한한 상태 기계임
     * 튜링 기계는 상태 기계의 예로, 결정적 튜링 기계는 상태마다 다음 상태가 최대 하나임
     * 프로그래밍 언어의 의미를 정확히 설명하는 실용적인 방법은 상태 기계로 변환하는 운영 의미론임
     * 다음 상태 동작은 발생 가능한 단계만 지정하며, 반드시 발생해야 한다는 것을 의미하지 않음
     * 단계의 필수 발생을 명시하려면 공정성 조건(fairness property)을 추가해야 함
     * 공정성 없이도 오류(commission)를 찾는 데 충분하지만, 누락 오류(omission)는 검출되지 않음
     * 대부분의 경우 오류는 commission이 많으며, 초보자는 초기 조건과 다음 상태 관계 작성부터 시작해야 함

속성 검증

     * 시스템이 원하는 대로 동작하는지를 확인하기 위해 모델을 작성함
     * 모델이 모든 가능한 행동에 대해 특정 속성을 만족하는지 TLA+ 도구로 검증 가능함
     * 예: 99%의 초기 상태에서 동작이 정상 종료되더라도, 모든 행동이 정상 종료되어야 함을 검증함
     * 가장 일반적인 속성은 불변 속성(invariance property)으로, 모든 상태에서 항상 참이어야 함
     * 공정성 조건이 있는 모델은 생존 속성(liveness property)도 검증해야 함 → 예: 실행이 반드시 종료됨
     * 더 복잡한 속성은 상태 기계로 표현 가능하며, 다른 상태 기계가 이를 구현하는지를 검증 가능함
     * TLA+에서는 상태 기계와 속성의 형식적 구분 없이 수학식으로 동일하게 표현됨
     * 한 상태 기계가 다른 상태 기계를 구현한다는 것은 해당 수식이 논리적으로 포함됨을 의미함
     * 실제로는 대부분 불변성과 간단한 생존 속성만 검사하지만, 더 복잡한 개념을 이해하는 것도 코드 오류 방지에 도움됨

TLA+ 언어 자체

     * TLA+는 수학 기반 언어이며 프로그래밍 언어처럼 보이지 않음
     * 프로그래머는 수학 표현보다는 프로그래밍 언어에 익숙하기 때문에 처음에 어렵게 느낄 수 있음
     * 하지만 실제로는 수학이 프로그래밍 언어보다 더 표현력이 뛰어남
     * 예: GCD를 두 수를 나누는 최대의 양의 정수라고 정의할 수 있음 (계산 방법 생략 가능)
     * 수학적 정의는 목적에 필요한 핵심만 남기고, 불필요한 구현 세부사항을 추상화할 수 있음
     * 절차화는 추상화를 제공하지 않으며, 단지 다른 위치에 코드를 숨길 뿐임
     * PlusCal은 TLA+ 입문에 적합하며, 숙련자도 간단한 모델에는 PlusCal을 선호함
     * 하지만 수학적으로 사고하고 고수준 모델링을 하려면 TLA+ 자체를 익히는 것이 중요함

   https://cacm.acm.org/research/… aws에서 잘 쓰고 있죠.

   코딩은 프로그래밍이 아니에요
   이 글에서 언급되길래 찾아봤습니다.

   저도 이 글에서 처음 봐서 찾아보고 있었네요
"
"https://news.hada.io/topic?id=19962","구글, Gemini 2.5 출시 ","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           구글, Gemini 2.5 출시

     * Gemini 2.5는 복잡한 문제 해결을 위해 설계된 가장 지능적인 추론 기반 AI 모델
     * 최초 릴리스인 Gemini 2.5 Pro Experimental은 다양한 AI 벤치마크에서 최고 성능을 기록함
     * 특히 LMArena 순위에서 큰 격차로 1위를 차지함
     * 기존 모델과 달리 응답 전에 스스로 사고 과정을 거치는 구조로 설계되어 정확성과 성능이 향상됨

AI에서의 '사고' 능력이란?

     * 단순한 분류나 예측을 넘어서, 정보 분석, 논리적 결론 도출, 맥락 이해, 의사 결정 등 고차원적인 인지 능력을 포함함
     * 이를 위해 DeepMind는 강화 학습, Chain-of-Thought 프롬프트 기법 등을 활용해 AI의 추론 능력을 연구해왔음
     * 기존의 Gemini 2.0 Flash Thinking 모델에서 한 단계 더 발전된 성능을 보여줌

앞으로의 방향

     * Gemini 2.5를 통해 향상된 기반 모델과 후처리 기법을 결합하여 새로운 성능 수준 달성
     * 향후 모든 Gemini 모델에 이 사고 능력을 기본 탑재하여, 더 복잡한 문제 해결과 고도화된 에이전트 지원 가능하게 할 예정임

Gemini 2.5 Pro 소개

     * Gemini 2.5 Pro Experimental은 지금까지 개발된 모델 중 가장 복잡한 작업 수행에 뛰어난 성능을 보임
     * 인간 선호도를 기준으로 평가하는 LMArena에서 큰 격차로 1위를 차지
     * 코딩, 수학, 과학 벤치마크에서도 뛰어난 성능을 보임
     * 현재 Google AI Studio 및 Gemini 앱에서 사용 가능하며, 곧 Vertex AI에서도 제공 예정
     * 향후 요금제가 도입되어 더 높은 호출 제한으로 확장 가능한 서비스 가능 예정

향상된 추론 성능

     * 복잡한 논리 문제 해결에서 최고 수준의 벤치마크 성적 기록
     * 추가적인 비용이 드는 테스트 기법(예: 다수결 투표) 없이도 우수한 성능 유지
     * GPQA, AIME 2025 등의 수학·과학 문제에서 선도적인 성능
     * 수백 명의 전문가가 설계한 고난이도 추론 테스트 'Humanity’s Last Exam'에서 도구 없이 18.8%라는 업계 최고 성적 기록

고급 코딩 성능

     * 코딩 성능이 Gemini 2.0 대비 크게 향상됨
     * 웹앱 생성, 에이전트형 코드 작성, 코드 변환 및 수정에 뛰어난 능력
     * SWE-Bench Verified 평가에서 맞춤형 에이전트 사용 시 63.8% 달성
     * 단 한 줄의 프롬프트로 실행 가능한 비디오 게임을 생성하는 예시도 있음

Gemini 모델의 강점 계승

     * Gemini 2.5는 기존 Gemini 모델의 강점인 멀티모달 처리 및 긴 컨텍스트 창을 그대로 유지함
     * 1백만 토큰 컨텍스트 창 지원 (곧 2백만으로 확장 예정)
     * 텍스트, 오디오, 이미지, 비디오, 전체 코드 저장소 등 다양한 정보 소스를 종합적으로 처리 가능
     * 개발자 및 기업 사용자는 Google AI Studio, Gemini Advanced, Vertex AI 등을 통해 실험 및 테스트 가능

   claud,gpt4.5를 압도하는데 grok3 를 여러번 시도할때를 이기지는 못하네.
   grok3 대단하다.

   Google AI Studio에 Gemini 2.5 Pro가 나오면서 기존에 있던 Gemini 2.0 Pro들은 모두 사라졌네요.. 무료로 쏠쏠하게 잘 쓰고 있었는데 좀 아쉽습니다. Gemini 2.5 Pro는 분당 2회 제한에 하루에 50번 까지만 호출할 수 있는 제약이 좀 큰 것 같네요.

        Hacker News 의견

     * LLM을 사용하여 소설과 같은 긴 글을 작성할 때 가장 큰 문제 중 하나는 세부 사항을 제공하면 모델이 지나치게 신경질적으로 반응하는 것임
          + 예를 들어, 서사 판타지의 사랑 관심사 프로필을 제공하면, 주인공이 거의 항상 3페이지 이내에 그들과 만나는 상황이 발생함
          + 이는 비논리적인 전개이며, 이를 변경하려는 시도는 효과가 없음
          + 현재 모델은 19페이지를 생성한 후에도 정상적인 전개를 보여주며, 많은 세부 사항을 포함하고 있음
          + 매우 인상적임
     * 수학 퍼즐을 사용하여 다양한 모델을 벤치마크로 사용해 왔음
          + 이 퍼즐은 컴퓨터로 해결하는 데 약 3일이 걸렸으며, 수학 전공자는 손으로 하루 만에 해결했음
          + Gemini 2.5는 이 퍼즐을 처음으로 해결한 모델이며, 이는 LLM이 수학적 추론에서 인구의 95% 이상보다 뛰어나다는 것을 의미함
          + 퍼즐은 세 사람이 원형으로 서 있고, 각 사람의 머리 위에 양의 정수가 떠 있으며, 두 수의 합이 세 번째 수와 같음
          + 첫 번째 사람은 자신의 수를 모른다고 하고, 두 번째 사람도 모른다고 하며, 세 번째 사람도 모른다고 함
          + 다시 첫 번째 사람에게 물었을 때, 그는 65라고 답함
          + 세 수의 곱은 무엇인지 묻는 퍼즐임
     * 오디오 전사 및 복잡한 사진에서 생물 주위에 경계 상자를 그리는 작업에서 매우 잘 수행했음
          + 자전거를 타는 펠리컨을 그려주기도 했음
          + 관련 노트는 링크에서 확인 가능함
     * 벤치마크에서 전례 없는 방식으로 최고 성과를 기록했음
          + 높은 품질과 명확한 결과를 보여주지만, 약간 느린 편임
          + Google이 다시 큰 성과를 내고 있음
     * Gemini 2.5 Pro는 aider polyglot 리더보드에서 73%의 점수로 SOTA를 기록했음
          + 이전 Gemini 모델보다 큰 도약을 보여줌
          + 효율적인 diff-like 편집 형식을 효과적으로 사용한 첫 번째 Gemini 모델임
     * 이러한 발표는 템플릿처럼 보이기 시작했음
          + 최첨단 모델
          + X, Y, Z와의 벤치마크 비교
          + ""더 나은"" 추론
          + 훌륭한 모델일 수 있지만 반복되는 텍스트는 흥미를 떨어뜨림
     * Gemini 2.5는 크게 향상된 기본 모델과 개선된 후처리를 결합하여 새로운 성능 수준을 달성했음
          + 앞으로는 이러한 사고 능력을 모든 모델에 직접 구축하여 더 복잡한 문제를 처리하고 더 많은 능력 있는, 상황 인식 에이전트를 지원할 것임
          + 인터넷에 연결되어 있으며, 필요할 때 추론 모델로 작동함
          + 최근 출시된 캔버스 모드를 이 모델에 지원할 수 있기를 바람
     * Dart 라이브러리의 버그 원인을 식별하기 위해 LLM에 전체 코드베이스와 버그 설명을 제공하는 테스트 케이스를 사용했음
          + 약 360,000개의 토큰을 포함함
          + 한 달 전 주요 모델에서 시도했지만, 이 모델만이 올바른 수정을 식별했음
     * Gemini를 사용할 계획이라면, 다음과 같은 주의 사항이 있음
          + 기밀 정보나 리뷰어가 보거나 Google이 사용할 수 있는 데이터를 입력하지 말 것
          + Google AI의 품질 향상 및 제품 개선을 위해 인간 리뷰어가 대화를 읽고 주석을 달며 처리함
          + 이 과정에서 개인 정보 보호를 위해 대화를 Google 계정과 분리함
     * 2.0 모델이 아직 오래되지 않았는데, 이름에 +0.5가 붙은 이유가 궁금함
          + 마케팅 때문인지, 새로운 모델 구조를 나타내는 것인지, 2.0 기반의 더 많은 훈련 데이터인지, 새로운 서비스 인프라인지 궁금함
          + *.5 명명법이 처음 등장했을 때 다소 어리석다고 느꼈음
          + OpenAI가 3.5를 출시했을 때 이미 4를 준비 중이라고 했으며, ChatGPT에 더 적합하도록 3을 조정 중이라고 했음
          + Anthropic이 Sonnet 3, 3.5, 3.5 (new), 3.7로 모델을 명명한 것이 이 명명법의 최악의 사례라고 생각함
          + semver, 날짜 기반(""Gemini Pro 2025""), 의미 있는 문자와 숫자 조합(예: 4o - ""Omni"")을 선호함
"
"https://news.hada.io/topic?id=19941","23andMe 매각을 위한 파산 신청","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          23andMe 매각을 위한 파산 신청

        Hacker News 의견

     * 23andMe는 오랫동안 교착 상태에 있었음
          + CEO는 회사의 실질적인 통제자로, 49%의 의결권을 가지고 있음
          + 그녀는 회사를 비공개로 전환하려고 시도 중임
          + 작년 8월, 주당 $8로 모든 주식을 매입하겠다고 제안했으나 이사회에서 거부함
          + 새로운 이사회를 구성하고 주당 $2.53로 다시 제안했으나 거부됨
          + 이번 달에는 주당 $0.4로 세 번째 시도했으나 또 거부됨
          + 한편, 23andMe는 매 분기 $50M의 손실을 보고 있었음
          + 문제를 해결하지 못해 이사회는 파산 절차에 들어가기로 결정함
          + 23andMe가 기업 지배 구조의 악몽에서 벗어나기를 바람
     * 개인적으로 서비스를 사용하지 않았더라도 가까운 친척이 사용했다면 이미 상당한 양의 유전자 정보를 가지고 있을 것임
          + ""shadow profiles""라는 개념을 데이터 모델의 일부로 유지함
          + 예를 들어, 유전적 친척이 업로드한 데이터를 기반으로 부계 하플로그룹을 추론함
          + 그들의 데이터가 잘못된 손에 들어가지 않기를 바람
          + 이는 그들의 가장 가치 있는 자산이며, 생각보다 훨씬 큰 문제임
     * 금요일에 캘리포니아 법무장관이 소비자에게 데이터에 대한 경고를 발행했음
          + 이는 회사가 곧 파산할 것이라는 신호였음
     * 사생활 문제는 있지만, ""발가락 길이 비율: 두 번째 발가락이 더 길 가능성 있음""을 알려줌
          + 내려다볼 필요도 없었음
          + 나쁜 생각일 수도 있었지만, 디스토피아적 미래에 대비해 DNA를 쉽게 얻을 수 있는 상황을 상상함
          + 피를 뽑을 때 그들이 그것으로 무엇을 하는지 보는가?
          + 중요한 것은 우리가 싸우는 법률이지, 2022년에 인터넷 회사에 침을 보냈는지 여부가 아님
          + 어쨌든 데이터를 삭제할 것임
     * 23andMe에 가입한 것을 후회함
          + 좋은 아이디어가 아니어서가 아니라, 미래에 DNA 복사본이 남아 이상한 SF 세계에 빠질까 걱정됨
          + 바이러스나 다른 방법으로 특정 타겟이 될 수 있음
          + 중요한 인물이 될 가능성은 없지만, 개인 데이터가 작은 텍스트 파일로 남아 있는 것이 사생활 침해처럼 느껴짐
          + 파산 후 누가 이 데이터를 살지 모름
          + 23andMe에서 DNA 데이터와 계정이 삭제되면 정말로 모든 백업과 시스템에서 삭제되는지 궁금함
          + 익명 계정 사용 가능함
     * 이미 데이터를 다운로드하고 삭제했음
          + 새로운 구매자가 사람들의 유전적 데이터를 헐값에 살 수 있다는 것이 놀라움
     * 수학/CS 분야의 성공적인 사람들이 생명공학에 적용하는 데 어려움을 겪음
          + 수학/CS 배경을 가진 우리 중 약 12명이 기술을 버리고 생의학으로 전환했음
          + 대부분의 시도가 실패했음
     * DNA 사이트에 참여한 적은 없지만, 이모가 거의 전체 가족 트리를 입력했음
          + 계정을 만들지 않고 자신을 제거할 수 있는 방법이 있는지 궁금함
     * 책임을 지고 어제 데이터를 삭제했으며, 이제 회사는 파산 신청을 했음
     * CEO가 회사를 비공개로 전환하려고 했다고 생각했음
          + 독립 이사회가 사임하게 만든 원인이었음
"
"https://news.hada.io/topic?id=19917","Show GN: 세로토닌: 마음을 위한 AI","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Show GN: 세로토닌: 마음을 위한 AI

   세로토닌은 마음을 위한 AI 입니다.
     * AI 회고 / 일기: 아침에 하루를 준비하거나, 저녁에 하루 일과를 정리해볼 수 있습니다.
     * AI 친구 / 서포트 그룹 (Support Group): 나와 공통점을 가진 AI 친구들에게 정서적인 지원을 받을 수 있습니다.
     * 감정분석 및 데이터: 일기를 작성하거나, AI 친구들과 대화를 하거나, 감정 체크인 기능을 사용하면 내 감정, 감정과 관련된 요인들이 기록됩니다.
     * 숨쉬기 운동 (Breathwork): 스트레스를 감소시키고 집중력을 강화하거나 불안을 줄이는 데에 사용할 수 있는 다양한 숨쉬기 운동들이 포함되어 있습니다.
     * 명상: 주기적인 명상은 스트레스와 불안을 감소시키며 집중력과 기억력을 강화하고, 명상의 종류에 따라서는 이타적인 마음을 기를 수 있습니다.

   세로토닌은 행복 호르몬으로 많이 알려져 있는데요, 실제로 행복한 삶을 살기 위해서는 단순히 순간적으로 기분이 좋은 특정한 행동이 아닌 장기적으로 좋은 습관들과 (잠, 운동, 음식, 몰입 등) 인간관계를 만들어야 하죠.

   보편적일수도 있고, 나에게만 해당할 수도 있는 그런 행동과 습관들을 하나씩 찾아갈 수 있도록 도와주는 제품을 만들어보려고 해요.

   Mindfulness / Breathwork 관련 자료
     * A Bibliometric and Visualization Analysis of Mindfulness and Meditation Research from 1900 to 2021
     * Effect of breathwork on stress and mental health: A meta-analysis of randomised-controlled trials

   AI가 감정적 보조가 될 수 있는지에 대한 접근

   Third-party evaluators perceive AI as more compassionate than expert humans
"
"https://news.hada.io/topic?id=19963","OpenAI, 4o 이미지 생성 기능 공개 ","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        OpenAI, 4o 이미지 생성 기능 공개

     * OpenAI는 이미지 생성이 언어 모델의 핵심 기능 중 하나여야 한다고 오랫동안 믿어왔고, 이러한 비전을 바탕으로 가장 정교하고 강력한 이미지 생성기를 GPT‑4o에 통합함
     * GPT‑4o의 이미지 생성은 단순히 아름다운 이미지를 넘어 실제로 유용하고 가치 있는 결과물을 만들어냄
     * 정밀하고 정확하며, 포토리얼리즘 수준의 고품질 이미지 생성이 가능함
     * 멀티모달 기능이 기본으로 탑재되어 있어 언어, 이미지, 문맥을 함께 활용한 시각 콘텐츠 제작이 가능함

유용한 이미지 생성 기능

     * 인간은 고대 벽화부터 현대의 인포그래픽까지 시각적 이미지를 사용해 정보를 전달하고 설득하며 분석해왔음
     * 기존의 생성 모델들은 환상적이거나 인상적인 이미지를 만들 수 있지만, 실용적인 정보 전달용 이미지는 어려워했음
     * GPT‑4o의 이미지 생성은 로고나 다이어그램처럼 의미 전달에 정확한 이미지 생성에 강점을 가짐
     * 텍스트 정확한 렌더링, 사용자 대화 맥락 활용, 업로드된 이미지 기반 생성 등 고도화된 기능을 포함함
     * 이러한 기능은 사용자가 원하는 이미지를 더 정확하게 만들 수 있게 도와줌

향상된 이미지 생성 능력

     * 온라인 이미지와 텍스트의 결합 분포를 학습하여 이미지와 언어, 이미지 간의 관계를 이해함
     * 훈련 후 보정 과정을 거쳐 시각적 유창성이 높아지고, 유용하고 일관성 있는 이미지 생성 가능함

텍스트 렌더링 기능

     * 이미지는 수천 개의 단어를 담을 수 있지만, 위치에 맞는 텍스트 몇 개가 의미를 강화시킬 수 있음
     * GPT‑4o는 이미지에 정밀한 기호나 텍스트를 결합해 시각적 커뮤니케이션 도구로 활용 가능함

대화형 이미지 생성

     * GPT‑4o는 이미지 생성을 본연의 기능으로 통합하여, 대화 흐름 속에서 이미지 생성과 수정 가능함
     * 예: 게임 캐릭터 디자인 시 외형을 지속적으로 유지하면서 반복 수정 가능함

지시사항 정확한 반영

     * GPT‑4o는 자세한 프롬프트를 정확히 반영함
     * 타 시스템은 약 5-8개 객체까지 처리 가능하지만, GPT‑4o는 최대 10-20개 객체를 일관성 있게 생성 가능함
     * 객체 속성 및 관계 표현을 더 정확하게 유지함

맥락 기반 학습

     * 사용자가 업로드한 이미지를 분석해 해당 이미지의 세부 정보를 이미지 생성에 반영함

세계 지식과의 연결

     * GPT‑4o는 텍스트와 이미지 간의 지식을 연결하여 더 스마트하고 효율적인 이미지 생성이 가능함

포토리얼리즘과 다양한 스타일

     * 다양한 이미지 스타일로 훈련되어 현실감 있는 이미지 생성과 스타일 변환 가능함

모델의 한계점

     * 완벽한 모델은 아님
     * 초기 출시 이후 사용자 피드백과 데이터 기반으로 지속적인 개선 예정임

안전성 확보 노력

     * 게임 개발, 역사 탐구, 교육 등 유익한 창작 활동을 장려하면서도 강력한 안전 기준 유지
     * 부적절한 이미지 생성을 방지하기 위해 철저한 정책 적용 중임
     * C2PA 및 내부 검색 도구를 통한 투명성 확보
          + GPT‑4o가 생성한 모든 이미지에는 C2PA 메타데이터 포함되어 출처를 명확히 함
          + 내부 검색 도구를 활용해 기술적 속성을 바탕으로 이미지 출처 확인 가능함
     * 부적절한 이미지 차단
          + 아동 성적 이미지나 딥페이크 등 정책 위반 이미지 생성 요청을 차단함
          + 실존 인물이 포함된 이미지에 대해서는 더 강화된 제한 적용
          + 누드, 폭력적 이미지에 대한 철저한 사전 차단 시스템 운영
     * 추론 기반의 안전성 강화
          + 인간이 작성한 정책 명세서를 기반으로 작동하는 추론 기반 LLM을 훈련함
          + 정책의 모호함을 파악하고 해결하기 위해 사용되었으며, 멀티모달 기술과 결합해 입력 텍스트와 출력 이미지 모두 정책 기준에 맞도록 조정함

이용 가능

     * 오늘부터 Plus, Pro, Team, Free 사용자에게 기본 이미지 생성기로 제공됨
     * Enterprise와 Edu는 곧 지원 예정
     * Sora에서도 사용 가능하며, 기존 DALL·E 모델은 별도 GPT로 접근 가능함
     * API를 통한 이미지 생성 기능은 몇 주 내로 개발자에게 제공 예정
     * 사용자는 원하는 이미지 설명만으로 생성 가능하며, 비율, 색상(hex 코드), 배경 투명 여부 등도 지정 가능함
     * 고정밀 이미지 생성으로 인해 렌더링 시간은 최대 1분 소요될 수 있음

   아직 free에서는 안보이는 것 같은데 Plus, Pro, Team에만 열린거죠?

   Pro에서는 채팅창 아래에 ... 눌러보면, ""이미지 만들기 (업데이트됨)"" 이렇게 되어 있는데 이거인듯 하네요.
   그런데 Best of # 는 안 나오던데 적용이 안된건지 된건지 헷갈리네요.

        Hacker News 의견

     * 새로운 이미지 생성 방식이 토큰을 사용하여 확산 대신 픽셀 공간에서 추론을 수행함
          + 예를 들어, 빈 틱택토가 있는 노트패드를 그리게 하고 첫 번째 수를 두게 한 후, 사용자가 수를 두는 방식으로 진행할 수 있음
          + 그림 스타일을 변경하거나 ""낮을 밤으로 바꾸기"", ""모자 씌우기"" 등 정보 보존 번역도 가능함
          + 모델의 해상도가 제한적이지만, 이 분야의 발전으로 앱을 이미지로 단계별로 설계하고 코드를 작성할 수 있는 가능성이 있음
          + 모델이 외부 이미지에서 ""추론""을 계속할 수 있어, 원래 생성물이 좋지 않아도 개선 가능함
          + 모델이 빨라지면, LLM 이벤트에 기반하여 앱의 다음 프레임을 생성하는 진정한 생성 UI를 상상할 수 있음
          + 확산 모델도 이와 유사한 작업을 더 빠르게 수행할 수 있음
     * 4o Image Generation 소개: 가장 진보된 이미지 생성기임
          + Google의 Gemini 2.5: 가장 지능적인 AI 모델임
          + Gemini 2.0 소개: 가장 능력 있는 AI 모델임
          + 이러한 트렌드가 사라지고 Apple이 효과적인 것을 사용하여 다른 회사들이 새로운 용어를 복사하기를 바람
     * 왜 o1과의 벤치마크를 추가하지 않는지 궁금함
     * OpenAI의 GPT-4o Image Generation 라이브 스트림은 느리며, 이미지당 약 30초가 소요됨
          + Sam Altman은 ""느리지만 생성된 이미지가 가치 있다""고 설명함
          + 확산 접근 대신, 원래 DALL-E와 유사하게 이미지 토큰을 생성하고 디코딩함
          + Google의 Gemini는 몇 초 만에 이미지를 생성하고 편집할 수 있음
          + 아직 API가 없으며, 느림으로 인해 경쟁사의 $0.03+/이미지보다 비용이 더 많이 들 것으로 예상됨
     * 시도해본 결과, 딸의 생일 초대장을 한 번에 생성할 수 있었음
          + 원하는 요소와 스타일을 정확히 맞춤
          + 날짜, 장소 등 세부 정보를 추가하도록 요청했을 때도 잘 수행함
          + 이전 모델은 절반도 못 따라왔음
     * 과포화된 CG/만화 스타일이 아닌 것이 만족스러움
     * 주어진 프롬프트가 4o 또는 Dall-E에 의해 처리되었는지 확인할 방법이 있는지 궁금함
          + 현재 프롬프트는 여전히 후자에 의해 처리되는 것 같음
          + 장기 계획은 4o로 완전히 이동하고 Dall-E를 별도의 탭으로 이동하는 것임
     * 와인 잔 테스트에서 여전히 실패함
     * ""Best of 8"" 태그가 붙은 많은 이미지가 얼마나 선택된 것인지 궁금함
          + 세 개의 무료 이미지 중 두 개는 인상적이었고 하나는 실패함
     * 새로운 모델로 반복 편집의 예시가 있음
          + 이전 모델보다 훨씬 나아졌지만 여전히 손가락이 너무 많거나 팔이 너무 많은 몸을 생성함
"
"https://news.hada.io/topic?id=19955","독일 의회, Git Contribution 그래프로 투표 결과를 표시 ","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 독일 의회, Git Contribution 그래프로 투표 결과를 표시

     * 정치적 결정은 모든 사람이 이해할 수 있어야 한다고 믿음
     * 정치적 논의가 종종 폐쇄된 환경에서 이루어지는 시대에, 더 많은 투명성을 제공하는 플랫폼 제공 목표
     * Bundestag(독일 연방의회)의 기명 투표 결과에 쉽게 접근할 수 있는 기능 제공
          + 누가 어떻게 투표했는지
          + 어떤 입장을 정당과 의원이 가졌는지 확인 가능
     * 시민들도 동일한 주제에 대해 의견을 표현하고 토론할 수 있는 공간 마련

시민 참여의 의미

     * 이 플랫폼의 설문조사 결과는 대표성이 없을 수 있음
          + 자발적으로 참여한 사람만 응답
     * 그럼에도 불구하고, 더 많은 사람들이 자신의 의견을 표현하고 토론에 참여하는 것이 중요하다는 믿음 기반
     * 핵심 목표는 정보에 기반한 토론 공간 제공
          + 정치적 결정에 대한 이해
          + 다양한 시각의 습득
          + 자신의 생각을 표현하고 나눌 수 있는 공간 조성

왜 참여해야 하는가?

     * 민주주의는 소통을 통해 유지됨
     * 정치적 결정이 어떻게 이뤄지는지 이해하는 것이 중요함
     * 개인의 의견이 통계 수치가 아닌 대화의 일부로서 의미를 가짐
     * 함께 정치 과정을 더 잘 이해하고, 시민 간의 대화를 활성화할 수 있음

함께 만들어가는 플랫폼

     * 정보를 얻고, 토론에 참여하며, 자신의 관점을 공유할 수 있는 공간 지향
     * 다양한 시각을 모아 정치적 프로세스를 더 잘 이해할 수 있는 플랫폼 구축 목표

FAQ

     * 연방의회 투표에 대한 데이터는 어디서 나오나요?
          + 우리의 데이터는 독일 연방의회의 공식 의사록과 문서에 근거합니다. 우리는 정보가 정확하고 완전하게 입력되었는지 확인합니다. 오류가 발생할 경우, 어떠한 제안이나 수정 사항도 알려 주시면 감사하겠습니다.
     * 이 플랫폼은 정치적으로 중립적입니까?
          + 네, 우리는 엄격한 정치적 중립을 고수하고 있습니다. 우리는 정보를 객관적으로 제시하며 정치적 입장에 대한 추천이나 평가를 하지 않습니다. 우리의 목표는 영향력이 아닌 투명성입니다.
     * 플랫폼은 어떻게 자금을 조달하나요?
          + 이 플랫폼은 현재 민간 자금으로 운영되고 있으며, 상업적 목적이 없는 프로젝트입니다. 현재 운영 비용은 관리 가능한 한도 내에 있습니다. 우리는 독립성을 유지하기 위해 의도적으로 정당이나 이익집단으로부터 기부금을 받지 않습니다. 앞으로 우리는 중립성과 성실성을 보장할 수 있는 투명한 자금 조달 모델을 검토하고 있습니다.
     * 투표에 어떻게 참여할 수 있나요?
          + 투표에 참여하려면 당사 플랫폼 계정이 필요합니다. 등록 후 개별 주제에 대한 투표를 하고 토론에 참여할 수 있습니다.
     * 왜 등록을 해야 하나요?
          + 등록은 양질의 투표를 보장하고 중복 투표를 방지하기 위한 것입니다. 귀하의 이메일 주소와 전화번호 또는 휴대전화 번호를 확인함으로써 귀하가 진짜 사용자인지 확인합니다. 사기를 완전히 배제할 수는 없지만, 사기를 예방하는 것은 훨씬 더 어렵습니다.
     * 앱에서는 어떤 데이터가 수집되나요?
          + 등록 시, 계정 확인을 위해 이메일 주소와 휴대전화 번호를 수집합니다. 또한, 인구 통계 데이터(나이, 성별, 주 등)를 장치에 로컬로 저장할 수 있는 옵션도 있습니다. 이러한 인구 통계 데이터는 귀하의 투표와 함께 익명으로만 전송되며, 귀하의 계정과 연결되거나 당사 서버에 영구적으로 저장되지 않습니다.
     * 투표는 정말 익명인가요?
          + 네, 투표는 완전 익명입니다. 투표 결과는 개인 데이터와 별도로 저장되고 집계됩니다. 아무도 – 심지어 우리 팀도 – 여러분이 개별 문제에 대해 어떻게 투표했는지 알 수 없습니다.
     * 다른 사용자와 투표 주제에 대해 논의할 수 있나요?
          + 네, 각 투표마다 토론 공간이 있습니다. 우리는 이 곳을 민주적인 교류와 다양한 관점을 위한 중요한 공간으로 봅니다. 우리는 서로 존중하고 객관적인 상호작용을 촉구합니다. 건설적인 비판과 타당한 주장은 토론을 풍요롭게 하는 반면, 개인적인 공격과 획일적인 비난은 공유된 대화를 해칩니다.
     * 제가 투표 주제를 제안할 수 있나요?
          + 현재 우리는 공식적인 연방의회 투표만 다루고 있습니다. 하지만, 커뮤니티 기반 투표를 위해 사용자가 직접 주제를 제안할 수 있는 기능을 구현하기 위한 초기 고려사항이 이미 있습니다. 그러면 이것은 공식 투표와 명확히 구별될 것입니다. 이 새로운 기능의 개발 상황은 계속해서 알려드리겠습니다.
     * 플랫폼의 추가 개발에 어떻게 기여할 수 있나요?
          + 여러분의 피드백과 개선 제안을 환영합니다! 이메일이나 소셜 미디어를 통해 직접 문의해주세요. 기술에 정통한 사용자도 GitHub 저장소를 통해 개발에 기여할 수 있습니다.

   이게 그냥 찬반만 표시하는 사이트인거지, git으로 찬반 투표를 하는 건 아닌거죠? github 레포에 가봐도 저 사이트의 소스만 있는 것 같고요.

   네 그냥 표시만 그런거고, 투표는 사이트에 가입해서 인증하고 해야하는 것 같네요.
   요약이 투표 안건들만 나오는 것 같아서 About 페이지의 요약으로 교체하였습니다.

        Hacker News 의견

     * GitHub에 마크다운 형식으로 법률을 포함한 저장소가 있으며, 의회에서 제안한 실제 변경 사항에 대해 PR을 사용한 경험이 있음
          + 커밋에는 적절한 날짜가 있어 git blame을 통해 법률의 변경 사항을 추적할 수 있음
          + 안타깝게도 현재는 유지 관리되지 않음
     * Git과 GitHub를 혼동하지 말아야 함. GitHub는 미국의 독점 기업에 속함
     * GitHub가 대중화한 기여 캘린더 외에 무엇이 ""Git""인지 궁금해하는 의견이 있음
     * 정부가 Git 기반으로 운영되어 모든 결정과 기여가 온라인에서 투명하게 추적될 수 있기를 바라는 의견이 있음
          + 예를 들어, 미국에서는 예산 한도 위기와 관련하여 양당이 정부 셧다운을 막기 위해 법안을 추진하는 경우가 있음
          + 실제로는 로비로 인해 특별 이익 집단을 위한 다양한 조항이 포함된 수천 페이지의 문서가 통과됨
          + 대중은 누가 언제 어떻게 이러한 조항을 추가하는지, 양당 합의가 실시간으로 어떻게 이루어지는지 알아야 함
     * 독일 의회의 투표를 Git 기여 그래프로 해석한 경험을 공유하는 의견이 있음
     * 법률 텍스트를 단순히 Git에 추가하는 것은 거의 쓸모없다는 의견이 있음
          + 상업적 법률 데이터베이스와 비교하여 교차 참조가 필요함
          + 법률에 ""관련 기관이 인증을 발급한다""는 구문이 있을 때, ""관련 기관""을 지정하는 정부 명령으로 연결되는 하이퍼링크가 필요함
          + 법률 변경이 계획될 경우, 텍스트에 ""9월 1일에 변경 예정""이라는 메모가 필요함
          + GitHub는 원시 문서를 저장하는 데 사용될 수 있지만, 실제로 법률 질문에 대한 답을 찾는 데는 쓸모없음
          + GitHub에서 법률을 읽는 것은 구문 강조 및 탐색 없이 소스 코드를 읽는 것과 같음
     * <a href=""https://abstimmung.eu/git/2024"" rel=""nofollow"">abstimmung.eu</a>의 일부 투표 결과가 오해를 불러일으킬 수 있음
          + 투표는 결정 추천(Beschlussempfehlung)에 관한 것이며, 이는 때때로 원래 요청(Antrag)을 부정함
     * 법률에 VCS의 기능을 더 많이 적용하면 좋겠다는 의견이 있음, 예를 들어 git blame과 git log
     * Bundestag가 최근에 관리자로 승진했는지 궁금해하는 의견이 있음
     * 정부 데이터 집계기가 더 많아지기를 바라는 의견이 있음
          + 많은 사람들이 정부가 공개적으로 접근할 수 있는 자료가 얼마나 많은지 모름
          + 20년 된 자바 애플릿에 묻혀 있기 때문일 가능성이 있음
          + 비슷한 자원이 있는지, 선호하는 자원이 있는지 궁금해하는 의견이 있음
"
"https://news.hada.io/topic?id=19932","SeL4 마이크로커널 소개 [PDF]","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          SeL4 마이크로커널 소개 [PDF]

     * seL4는 OS 마이크로커널로, 최소한의 코드로 커널 모드를 실행해 하드웨어 자원을 제어하고 보안을 강화함
     * L4 마이크로커널 계열에 속하며, 1990년대 중반부터 개발됨
     * 하이퍼바이저로 동작 가능하여 리눅스와 같은 게스트 OS 실행 지원
     * 세계 최초로 기능적 정확성이 입증된 OS 커널로, 코드 수준에서의 수학적 증명이 완료됨
     * 세밀한 접근 제어를 위해 Capability(역량) 기반 보안 모델 사용

seL4의 구조 및 하이퍼바이저 기능

     * 모놀리식 커널 vs 마이크로커널
          + 모놀리식 커널(Linux 등): 커널 코드가 방대해 보안 취약점이 많음 → 약 2000만 줄의 코드 (20M SLOC)
          + 마이크로커널(seL4): 최소한의 커널 코드 사용 → 약 1만 줄의 코드 (10K SLOC)
          + 커널 크기 축소 → 보안 강화 및 공격 표면 감소
     * seL4는 하이퍼바이저 역할 수행
          + VM에서 리눅스 같은 완전한 게스트 OS 실행 가능
          + 각 VM은 독립적으로 실행되며 상호 간섭 불가능 → 강력한 격리 보장
          + 보호된 프로시저 호출(PPC) → VM 간 보안 통신 가능

seL4의 검증 및 보안 모델

     * 기능적 정확성 검증
          + seL4는 코드 수준에서 수학적으로 기능이 정확함을 증명
          + 커널의 모든 동작이 사양에 맞게 동작함을 보장
     * 이행 검증(Translation Validation)
          + 컴파일러에서 생성된 바이너리 코드가 원래의 C 코드와 정확히 일치하는지 증명
          + 자동화 도구 체인을 통해 실행
     * 보안 속성 검증
          + 기밀성: 명시적으로 허용된 경우에만 데이터 접근 가능
          + 무결성: 명시적으로 허용된 경우에만 데이터 수정 가능
          + 가용성: 명시적으로 허용된 경우에만 리소스 사용 가능

Capability 기반 보안 모델

     * Capability란?
          + 특정 객체에 대한 접근 권한을 부여하는 보안 토큰
          + 객체 참조 및 접근 권한을 함께 인코딩
          + 세부적인 접근 제어 가능 → 최소 권한 원칙(Principle of Least Privilege, POLA) 적용
     * Capability의 장점
          + 세밀한 접근 제어 → 권한 최소화 가능
          + 권한 위임(Delegation) 및 권한 취소 가능
          + 강력한 보안 모델 → 전통적인 접근 제어 모델(ACL)보다 우수
     * 혼동된 대리인 문제 해결
          + 전통적인 ACL 기반 시스템에서는 보안 상태가 주체의 보안 ID에 따라 결정됨
          + seL4에서는 Capability가 직접 보안 권한을 결정 → 명확한 권한 제어 가능

실시간 시스템 및 혼합 중요도 시스템 지원

     * 실시간 시스템 지원
          + seL4는 우선순위 기반 스케줄링 지원
          + 모든 커널 작업의 최악의 실행 시간(WCET) 분석 완료 → 하드 실시간 보장
     * 혼합 중요도 시스템(Mixed-Criticality System, MCS) 지원
          + 스케줄링 컨텍스트 기반으로 CPU 자원 할당 및 격리
          + 높은 우선순위를 가진 작업이 CPU를 독점하지 않도록 제어
          + 임계 작업과 비임계 작업을 동시에 실행 가능

성능 및 효율성

     * 최고 성능의 마이크로커널
          + 성능이 중요한 경우에도 보안을 저하시키지 않음
          + 시스템 호출 및 IPC 비용이 최소화됨 → 경쟁 시스템 대비 5배 이상 빠름
     * 경쟁 시스템 대비 우수한 성능
          + Fiasco.OC: seL4 대비 약 2배 느림
          + Zircon: seL4 대비 약 9배 느림
          + CertiKOS: seL4 대비 약 5배 느림

실세계 적용 및 사이버 레트로핏

     * 실제 사용 사례
          + Boeing의 ULB(무인 헬리콥터)에서 성공적으로 적용됨
          + 보안 강화 및 시스템 안정성 증가 확인
     * 기존 시스템의 점진적 보안 강화(Incremental Cyber Retrofit)
          + 기존 시스템을 VM에서 실행하면서 점진적으로 모듈화
          + 보안 강화 및 성능 저하 최소화

결론

     * seL4는 기능적 정확성, 보안, 성능이 입증된 세계에서 가장 안전한 마이크로커널임
     * 검증된 보안 모델과 혼합 중요도 시스템 지원으로 다양한 분야에서 실용적으로 사용 가능
     * 기존 시스템의 보안 강화 및 성능 향상 가능 → 보안 및 성능의 균형을 이룬 혁신적인 마이크로커널
"
"https://news.hada.io/topic?id=19958","AI의 주요 가치는 R&D보다 광범위한 자동화에서 발생함","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    AI의 주요 가치는 R&D보다 광범위한 자동화에서 발생함

     * 일반적으로 AI의 경제적 가치는 연구 및 개발(R&D) 자동화를 통해 창출될 것이라는 관점이 널리 퍼져 있음
          + Dario Amodei는 AI가 생물학, 신경과학, 경제학 R&D에 긍정적인 영향을 줄 것이라고 주장함
          + Demis Hassabis는 AI가 모든 질병을 치료하고 에너지 문제를 해결하는 등 R&D를 통해 사회에 기여할 것이라고 설명함
          + Sam Altman은 AI가 반도체처럼 모든 산업에 영향을 줄 수 있지만, 과학적 진보에 미치는 영향이 가장 클 것이라고 언급함
     * R&D가 장기적인 경제 성장에 기여하지만, 그 기여도가 과대평가됨
          + 미국 노동 통계국(BLS)에 따르면 민간 R&D 지출은 1988~2022년 동안 총 요인 생산성(TFP) 성장률의 0.2%/년에 불과함
          + 공공 R&D 지출은 전체 R&D 지출의 약 25%를 차지하며, 총 TFP 성장에 대한 R&D의 기여도는 약 0.4%/년임
          + 노동 생산성 성장의 약 20% 만이 R&D에 의해 발생하며, 나머지는 자본 축적, 관리 개선, 학습 효과 등에 기인함
     * R&D 작업의 대부분은 단순한 논리적 추론이 아닌 복합적 능력을 요구함
          + 예: 에이전시, 멀티모달 처리 능력, 장기적 일관성 등
     * 연구자 업무를 완전 자동화할 수 있을 정도의 AI 능력은 대부분의 다른 경제 부문에서도 자동화가 가능하다는 것을 의미함 → 더 큰 경제적 가치 창출 가능

AI의 주요 경제적 가치는 광범위한 노동 자동화에서 발생할 것

     * AI의 경제적 가치에 대한 두 가지 주장
          + ✅ R&D 자동화가 연간 경제 성장률을 몇 퍼센트 이상 높일 수 있다
               o 기술이 R&D를 완전히 자동화할 수 있다면 상당한 경제적 가치 창출 가능
               o 경제 성장에 의미 있는 기여 가능성 높음
          + ❌ AI의 가장 큰 경제적 가치는 R&D 자동화에서 발생할 것이다
               o R&D는 가치 있지만, AI의 경제적 성장 동력의 핵심이 되지는 않을 것
               o AI가 인간 성능을 초과한 이후에도 R&D 자동화가 가장 중요한 경제적 가치 창출 요인이 될 가능성 낮음
     * R&D의 실제 경제적 가치 측정
          + 미국 노동 통계국(BLS) 데이터에 따르면:
               o 1988~2022년 동안 총 요인 생산성(TFP) 성장률: 0.8%/년
               o 민간 R&D 기여도: 0.2%/년 → 전체 TFP 성장률의 약 25%
               o 노동 생산성 성장률: 1.9%/년 → R&D 기여도는 약 **20%**에 불과
          + 공공 R&D 지출은 전체 R&D 지출의 약 25% 차지
               o 공공 R&D의 외부 효과와 민간 R&D의 외부 효과가 상쇄됨
               o 결과적으로 총 R&D 기여도는 0.4%/년 수준
     * 자본 축적과 생산성 성장의 관계
          + 자본 축적이 노동 생산성 성장의 약 50% 차지
          + 나머지 성장은 관리 개선, 학습 효과, 지식 확산 등에서 발생
          + 미국 경제에서 자본 축적과 R&D 투자의 비율:
               o 연간 자본 투자: 5조 달러
               o 연간 민간 R&D 투자: 1조 달러
               o 자본 투자는 R&D 투자보다 약 5배 많음
     * 노동의 산출 탄력성(0.6)이 R&D의 산출 탄력성보다 약 5배 높음
          + 노동 자동화는 경제적으로 더 큰 기여 가능성 보유
          + 현재 경제에서 가장 큰 비용을 차지하는 항목(노동)을 자동화하면 경제적 가치 극대화 가능
          + 노동 자동화로 발생한 초과 산출은 다시 자본에 재투자되어 추가 성장 가능
     * R&D 성장 효과가 과소평가되었다는 주장도 존재
          + R&D의 외부 효과나 중복 연구로 인한 마찰이 반영되지 않았을 수 있음
          + 그러나 Bloom et al. (2020) 의 연구에 따르면:
               o R&D 투자에 따른 산출 탄력성은 0.3으로 자본과 비슷하고 노동의 절반에 불과
     * 결론적으로, 현재 경제 성장은 주로 R&D가 아닌 다른 요인에서 발생

AI R&D 자동화만으로는 AI 발전을 극적으로 가속화하기 어려움

     * AI R&D의 경제적 가치는 기대만큼 크지 않을 수 있지만, AI가 자체 R&D를 자동화하면 중요한 영향을 미칠 가능성이 있음
          + 만약 AI가 자체 소프트웨어 R&D 프로세스를 자동화할 수 있다면 소프트웨어 단독 특이점(software-only singularity) 이 발생할 수 있음
          + 고정된 컴퓨팅 자원을 기반으로 AI 연구자가 스스로 알고리즘을 개선하고, 이를 통해 더 많은 AI 연구자를 생성해 추가적인 소프트웨어 발전 가능
     * 아이디어를 찾는 데 드는 비용이 얼마나 빨리 증가하는지가 핵심 변수
          + 연구자 노력만으로 다수의 소프트웨어 R&D 성과를 달성할 수 있다는 가정이 필수적이나, 이는 사실이 아닐 가능성 높음
          + 더 현실적인 모델은 연구 성과가 인지적 노력 + 데이터의 상호 보완에 의해 발생하는 경우임
     * AI는 현재 실험 기반 컴퓨팅 성능 및 소프트웨어 발전 속도가 연간 약 3~4배로 빠르게 증가하고 있음
          + 실험 기반 데이터를 통해 소프트웨어 발전이 이루어지고 있음 → 데이터가 연구자 노력의 중요한 보완재일 가능성
     * 두 입력(인지적 노력 + 데이터)이 상호 보완적이라면 컴퓨팅 자원이 병목 현상을 유발할 수 있음
          + 결국 더 많은 GPU 확보 및 생산을 위해 물리적 작업이 필요해질 가능성
          + 이는 AI가 반도체 공급망 및 경제 전반에 광범위하게 배치되어야 함을 의미
     * 보완성이 얼마나 강한가에 따라 소프트웨어 단독 특이점의 지속 가능성이 결정됨
          + 다른 산업에서는 보완성이 일반적으로 강함 → AI R&D에서도 강할 가능성 높음
               o 예: Oberfield와 Raval(2014) 의 연구에서 미국 제조업에서 자본과 노동의 대체 탄력성은 0.7
               o 이는 소프트웨어 단독 특이점이 효율성 개선에서 1배 미만에서 끝날 가능성이 높음을 시사함
     * 현재까지 프로그래밍 자동화 및 연구 장비 자동화에도 과학적 진보가 급격히 가속화되지 않음
          + 전문 라이브러리 개발 → 프로그래밍 작업 자동화
          + LLM 도구를 통한 코딩 가속화 → 부분적인 효과에 그침
          + 물리적 실험 장비 자동화 → 급격한 과학 발전 없이 점진적 개선만 발생

R&D 완전 자동화에는 매우 폭넓은 능력이 필요함

     * 과학자의 업무는 표면적으로는 아이디어 생성, 가설 설정, 데이터 분석, 코딩, 수학적 추론 등 추상적 추론 작업이 중심처럼 보일 수 있음
          + 따라서 추상적 추론이 가능한 모델이 등장하면 연구자 업무가 빠르게 자동화될 수 있다는 예상이 나옴
          + 하지만 실제로는 연구자 업무가 단순한 추론 작업보다 훨씬 복합적인 능력을 요구함
     * 의료 과학자 업무 예시
          + 독성 물질 처리, 약물 효과 평가, 질병 연구 설계 및 수행, 세포 샘플 분석 등은 단순 추론이 아니라 복합적 기술 및 전문 장비 사용이 필요
          + 약물 용량 표준화, 의료 및 실험 절차 지도, 논문 작성, 연구 보조금 신청 등은 상대적으로 추론 기반 자동화 가능성이 높음
          + 의료 과학자의 주요 업무 중 상위 5개 작업에서 추론만으로 자동화 가능한 것은 1개에 불과
          + 전체 14개 작업 중 6개만이 추상적 추론만으로 자동화 가능하다고 판단됨
     * 연구자 업무의 핵심은 단순한 추론이 아니라 다음과 같은 복합적 능력을 포함함:
          + 기술적 장비 조작 → 복잡한 실험 장비 사용 능력
          + 팀워크 → 인간 연구팀과의 협업 및 조정 능력
          + 장기적 실행 능력 → 장기간에 걸쳐 복잡한 프로젝트 수행
          + 물리적 환경 조작 → 실험 및 실습에서의 물리적 조작 능력
     * AI가 연구자 업무에 요구되는 모든 복합적 기술을 습득하기까지는 상당한 시간이 소요될 것
          + 따라서 일반 노동 자동화가 연구자 업무 자동화보다 먼저 이루어질 가능성이 높음
          + AI가 과학적 돌파구를 먼저 이룬 뒤 다른 산업으로 확산될 것이라는 가정은 현실성이 낮음
          + 더 현실적인 시나리오는 AI가 먼저 광범위한 노동 자동화를 이루고, 이후 과학 및 기술 발전이 가속화되는 것임
     * AI가 과학 발전을 가속화하더라도 이는 연구자 대체가 아니라 연구 인프라 구축 자동화를 통해 이루어질 가능성이 높음
     * R&D 자동화는 현재 경제 성장에서 차지하는 비중이 크지 않기 때문에 AI는 비-R&D 작업 자동화를 통해 경제적 성장을 주도할 가능성이 높음

AI의 도약은 광범위하고 두드러지게 발생할 가능성이 높음

     * AI의 경제적·기술적 영향이 본격화되기 이전부터 AI 자동화는 광범위하고 두드러진 형태로 나타날 가능성이 높음
     * 광범위함(Diffuse) → AI 자동화는 특정 R&D 직군에 국한되지 않고 경제 전반에 폭넓게 영향을 미칠 것
     * 두드러짐(Salient) → AI의 영향은 대부분의 사람들이 명확히 인식할 정도로 크고, 노동 시장에 대규모 혼란을 초래할 가능성이 높음
     * AI의 주요 경제적 효과는 R&D 자동화가 아니라 광범위한 자동화에서 발생할 것
          + AI가 세계에 미치는 혁신적 효과는 명시적인 R&D 자동화에서 발생하지 않을 가능성이 높음
          + 오히려 광범위한 노동 자동화가 경제 및 기술 발전의 주요 원동력이 될 것
     * AI 도약의 현실적 시나리오
          + 1. AI의 작업 범위 확장
               o AI는 점진적으로 수행 가능한 작업 범위를 확장할 것
               o 이 과정은 주로 컴퓨팅 인프라 확장에 의해 주도될 가능성이 높음
          + 2. 경제 전반에서 광범위한 노동 자동화 진행
               o AI는 점점 더 다양한 노동 작업을 자동화할 것
               o 결과적으로 경제 성장 가속화로 이어질 것
          + 3. 대규모 노동 시장 변화 발생
               o AI가 경제적·기술적 돌파구를 만들기 전에 이미 노동 자동화의 물결이 발생할 것
               o 이 과정에서 노동 시장이 근본적으로 재편되고 AI에 대한 대중 인식이 변화할 것
          + 4. 광범위한 비-R&D 작업 자동화가 성장의 주요 원동력 역할
               o AI가 경제 및 기술 성장을 가속화하더라도 이는 비-R&D 작업 자동화를 통해 발생할 것
               o R&D 자동화는 성장에서 차지하는 비중이 상대적으로 작을 가능성이 높음
     * ""일반 자동화 폭발"" 시나리오
          + AI 도약은 ""천재들이 연구소에서 R&D 성과를 폭발적으로 내는 형태""가 아닐 가능성이 높음
          + 대신 AI 도약은 광범위한 자동화 폭발의 형태를 띨 것
          + 즉, 특정 분야의 성과가 아니라 AI의 전반적인 자동화 범위와 규모가 성장의 주요 동력이 될 것

주요 시사점

     * 가까운 미래에는 AI 연구소가 일반 작업 자동화에 집중하는 것이 더 수익성이 높을 가능성이 큼
          + 예: 인터넷 탐색, 상업용 소프트웨어 운영, 일반 사무직 업무 수행 등
          + 생물학 및 의학 연구 보조와 같은 고도의 추론 모델 개발보다 일반 작업 자동화가 더 큰 경제적 가치 창출 가능성 높음
          + 따라서 AI 성능을 평가할 때 R&D 성과보다 일반 작업 수행 능력을 추적하는 것이 더 중요할 수 있음
     * AI가 세계에 혁신적 영향을 미칠 때까지 대중의 AI에 대한 인식이 크게 변화할 가능성이 높음
          + AI의 경제적 성장 및 인간 수명 연장 같은 성과가 나타나기 전에 이미 노동 자동화로 인한 대규모 혼란이 발생할 가능성 높음
          + 따라서 현재의 AI에 대한 대중 인식이 장기적으로 유지될 것이라고 가정하는 것은 위험함
     * AI가 인간의 모든 작업을 한 번에 대체할 가능성은 낮음 → 점진적 자동화 예상
          + AI는 수년에 걸쳐 인간의 작업을 점차적으로 자동화할 가능성이 높음
          + AI R&D 자동화로 인해 갑작스러운 초지능 폭발이 일어날 것이라는 시나리오보다 점진적인 전환이 더 현실적
          + AI가 특정 작업에서 인간을 초월해도 다른 보완적 작업에서는 여전히 인간이 우위를 점할 가능성 높음
     * AI는 결국 인간의 대부분의 경제적 활동에서 우위를 점할 것
          + 그러나 이는 수십 년에 걸친 점진적 자동화 이후에 발생할 가능성이 높음
          + 경제 성장 가속화는 R&D 자동화보다 일반 작업 자동화에서 더 큰 기여를 할 것

   https://freederia.com/%ed%94%84%eb%a1%ac%ed%94%84%ed%8a%b8-%ea%b0%a4%e… r&d자동화 테스트중입니다. 쉽지는 않겟지만 먼미래는 아닐겁니다.

        Hacker News 의견

     * 기술 낙관주의가 정말 우울하게 느껴지는 사람이 있는지 궁금함. 기술이 인간을 대체하는 것과 관련된 이유 외에도, 실현 가능성이 낮은 과대광고에 흥분할 수 없다는 점에서 우울함을 느낌
          + 사회에 실질적인 이익이 없는 것처럼 느껴짐
     * 현재 거의 300개의 댓글 중에서 제약 프로그래밍(CP)을 언급하는 사람이 없다는 점이 놀라움. CP는 확률적 데이터 기반 AI의 결정론적 형제임
          + 14개의 작업 중 6개만이 추상적 추론만으로 수행할 수 있다고 추측함. 의료 과학자들에게 가장 중요한 작업 중 하나만이 추상적 추론에만 의존한다고 분류됨
          + 대부분의 중요한 작업은 기술적 기술, 다른 사람들과의 정교한 조정, 전문 장비 사용, 긴 맥락 능력, 복잡한 다중 모드 이해를 요구함
          + 14개의 R&D 작업 중 거의 모든 작업은 추상적 추론을 가진 데이터 기반 AI에 적합하지 않으며 CP로 해결 가능함
          + 현대 논리, 최적화, 제약 프로그래밍의 창시자는 Geoffrey Everest Hinton의 할아버지인 George Boole임
     * 이 기사는 여기서 모든 신뢰를 잃음
          + ""1988년 이후 미국의 노동 생산성 성장의 20%만이 R&D 지출에 의해 주도됨""이라는 주장은 Jeff Dean의 순자산이 그의 프로그래밍 기술이 아니라 은행 계좌의 자본 심화에 기인한다고 말하는 것과 같음
          + 저자들은 추상적인 수준에서 개념을 다루고 있으며, 그들이 말하는 것과의 접촉을 잃음
     * 2015년의 기술 배포에 관한 고전을 읽지 않았다면 읽어볼 가치가 있음
          + 우리는 여전히 GenAI의 탐색 단계에 있는 것처럼 느껴지지만, ML은 배포 단계에 있는 것처럼 보임
     * 전형적인 실리콘밸리의 주장은 R&D가 ""복잡""하고 다른 모든 것이 ""단순""하다는 것임
          + 10년 전 AI가 수학/코드를 99%의 인간보다 더 잘할 수 있지만, 도어대시에서 핫도그를 주문하는 것이 최첨단이고 거의 불가능하다고 말하면 놀랄 것임
          + ""일반적인"" 작업이 더 가치 있다는 것에 동의하지만, 이러한 작업이 쉽게 자동화될 수 있다는 주장은 무지에 기반한 관점임
          + RPA는 10년 이상 존재했지만 많은 작업에 사용되지 않음. AI도 마찬가지이며, 데이터에 대한 대규모 무제한 액세스가 없으면 자동화되지 않을 것임
     * 그들은 R&D와 일반 자동화 중 어느 것이 더 많은 이익을 얻을 것인지 논쟁하고 있음. 이에 대한 논쟁의 의미가 무엇인지 의문임
          + 진행 중인 발전(예: alphafold)과 R&D 투자, 비율, 과거 추정 영향 등의 역사적 통계에서 답을 추론하려는 시도 사이의 단절이 이상함
          + AI 자체와 지속적인 돌파구가 R&D임
     * 산업 혁명과 농업 혁명이 다시 일어나는 것과 같음. 노동의 광범위한 자동화는 사회적 향상이 아니라 자본의 향상을 가져올 것임
          + 노동을 AI로 대체하는 것을 통해 ""사회적 혼란""을 인용하지만, 문제를 정부가 해결해야 할 문제로 치부함
          + 노동을 제거하면 누가 그들의 제품을 구매할 것인지, 어떤 수입으로 구매할 것인지 의문임
          + 자본은 소비에서 벗어나 더 높은 목표로 문명을 완전히 재구성해야 하지만, 이는 현재 그들이 이익을 얻고 있는 권력과 부의 구조를 무너뜨리는 것을 의미함
     * 생산 요소의 상대적 가치 문제임. AI가 인간 노동의 상대적 가치를 기계, 원자재, 토지와 비교하여 증가시킬 것인지 감소시킬 것인지에 대한 문제임
          + 노동의 중간 상대적 가치는 특히 지식 노동자에게서 감소할 것이라는 직감이 있음
          + 규제된 직업에서 보호받는 것이 중요함
     * 이 기사에 전적으로 동의하며, 과거에는 비용/보상 계산이 의미가 없었던 많은 기회가 있음
          + Excel VBA의 보편성을 생각해보면, 여전히 대부분에게는 고급 기술로 간주될 것임
     * 기술 낙관주의자들은 중산층과 빈곤층의 마음에 있는 질문에 답해야 함
          + AI가 대량으로 일자리를 대체하는 미래에 대해 어떻게 기술 낙관주의자가 될 수 있는지 의문임
          + AI에 의해 대량 해고될 때 임대료나 세금을 어떻게 지불할 것인지 의문임
          + UBI는 임대료 상승, 임대료, 육아비, 세금 등과 함께 여기서 작동하지 않으며, 너무 비현실적이고 이상적임
          + AI 시대에 새로운 일자리가 창출될 것이라는 서사가 있지만, AI가 일자리를 창출하는 것보다 더 빠르게 대체할 것이라고 생각함
          + 기술 낙관주의자들은 부유한 투자자 계층이며, 그들의 서사를 추진하는 것에 투자되어 있음
"
"https://news.hada.io/topic?id=19940","트럼프 행정부의 실수로 받은 전쟁 계획 문자","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        트럼프 행정부의 실수로 받은 전쟁 계획 문자

     * 트럼프 행정부의 실수로 전쟁 계획을 받음
          + 2025년 3월 15일 오후 2시경, 미국이 예멘의 후티 목표를 폭격하고 있다는 소식이 전해짐
          + 필자는 첫 폭탄이 터지기 두 시간 전, 국방장관 피트 헤그세스가 전쟁 계획을 문자로 보내 알게 됨
          + 계획에는 무기 패키지, 목표, 시간에 대한 정확한 정보가 포함되어 있었음
     * 이야기의 시작
          + 이 이야기는 2023년 10월 하마스가 남부 이스라엘을 침공한 직후 시작됨
          + 후티는 이란이 지원하는 테러 조직으로, 이스라엘과 국제 해운을 공격하여 글로벌 무역에 혼란을 초래함
          + 2024년 동안 바이든 행정부는 후티 공격에 효과적으로 대응하지 못했으며, 트럼프 행정부는 더 강력한 대응을 약속함
     * 저자 소개
          + 제프리 골드버그는 _The Atlantic_의 편집장 및 _Washington Week With The Atlantic_의 진행자임

        Hacker News 의견

     * 무능함과 부주의함의 놀라운 사례임. 이러한 운영상의 실수가 어떻게 발생했는지에 대한 투명성을 기대하기 어려움
          + 오전 11시 44분, ""Pete Hegseth""라는 계정이 Signal에 ""TEAM UPDATE""를 게시함. 이 업데이트의 내용은 미국의 적이 읽었다면 미국 군사 및 정보 요원을 해칠 수 있었을 것임. 특히 중동과 중앙사령부의 책임 지역에서
          + Signal 채팅 그룹이 실제임을 깨달았고, 그룹에서 나가면 자동 알림이 생성자 ""Michael Waltz""에게 전송됨을 이해함. 아무도 내가 있는 것을 눈치채지 못했고, 내가 왜 나갔는지에 대한 질문도 받지 않음
     * Waltz는 Signal 그룹의 일부 메시지를 일주일 후, 일부는 4주 후에 사라지도록 설정함. 이는 연방 기록법 위반 가능성을 제기함. 공식 행위에 대한 문자 메시지는 보존되어야 할 기록으로 간주됨
          + Signal을 사용한 이유가 기록 보존을 피하기 위한 것일 수 있음
     * Jeffrey Goldberg라는 이름의 사람이 NatSec 팀에 있을 가능성이 있음. Signal의 UI/UX 문제일 수 있음 (연락처 목록에 두 명의 Jeffrey Goldberg가 있을 때 구분하지 못하는 것)
     * Jeff Goldberg가 이 소스를 공개한 것이 놀라움. 채널을 최대한 오래 유지할 것이라 예상했음
          + 다른 더 나은 채널이 있을 수도 있음
          + 이 사람들은 정말 멍청함. 이를 긍정적으로 해석할 방법이 없음
     * 승인되지 않은 수신자에게 승인되지 않은 채널로 기밀 자료를 보내는 일반 공무원은 연방 교도소에서 20년형임
          + 지위가 있는 공무원이 같은 일을 하면 가벼운 처벌을 받음. 창피함
     * Hegseth가 Houthi 목표에 대한 공격 세부 사항을 그룹에 보냈을 때 ""우리는 현재 OPSEC에서 깨끗함""이라고 작성함. 믿기지 않음
     * 이 사건이 어떻게 주요 뉴스가 아닌지 이해할 수 없음
     * 독일 Taurus 유출 사건이 떠오름. Cisco Webex를 사용한 대화에서 영국과 미국 군사 요원의 우크라이나 주둔 및 Taurus 미사일 사용 가능성을 논의함
     * Signal과 같은 서드파티 앱이 이러한 유형의 통신에 사용되는 것이 이상함. 미친 것 같음
"
"https://news.hada.io/topic?id=19930","Cursor (AI IDE)는 어떻게 동작하는가","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Cursor (AI IDE)는 어떻게 동작하는가

     * AI 코딩 도구인 Cursor, Windsurf, Copilot의 내부 작동 방식을 이해하면 복잡한 코드베이스에서 생산성을 높이고 일관된 성능을 확보할 수 있음
     * 많은 사람이 AI IDE의 한계를 이해하지 못하고 전통적인 도구처럼 다루다가 성능 문제를 경험함
     * 이 글에서는 Cursor의 내부 작동 방식, 시스템 프롬프트, 그리고 코딩 및 Cursor 규칙 최적화 방법을 설명함

LLM에서 코딩 에이전트로

  대형 언어 모델 (LLM)

     * LLM은 기본적으로 다음 단어를 예측하는 방식으로 작동함
     * 프롬프트를 제공하면 LLM이 자동 완성으로 응답 생성
          + 초기 디코더 기반 LLM (예: GPT-2)은 완성될 결과를 얻기 위해 특정 프롬프트 작성이 필요했음
          + 프롬프트 엔지니어링은 모델을 '속여서' 원하는 답을 유도하는 기술임
     * 명령 튜닝 (Instruction Tuning) 도입 후 사용 편의성이 향상됨
          + “Foo 메서드를 리팩토링하는 PR 작성해줘” 같은 명령이 바로 실행됨
          + 실제로는 자동 완성 프로세스의 확장 버전임
     * 도구 호출 (Tool Calling) 추가됨
          + 모델이 파일 읽기, 쓰기, 명령 실행 같은 작업 수행 가능
          + 예: read_file('index.py') → 클라이언트가 파일 내용 제공 → 모델이 작업 진행

  에이전트 기반 코딩

   Cursor 같은 AI IDE는 복잡한 래퍼 구조를 사용해서 구성:
     * VSCode 포크 → 오픈 소스 기반에서 시작
     * 챗 UI 추가 및 적합한 LLM 선택 (예: Sonnet 3.7)
     * 코딩 에이전트용 도구 구현
          + read_file(full_path: str)
          + write_file(full_path: str, content: str)
          + run_command(command: str)
     * 프롬프트 최적화
          + ""너는 전문가 코더임"", ""추측하지 말고 도구 사용"" 등 명령 추가
            → 단순히 위 단계를 구현하면 실제로는 동작하지만 문법 오류, 환각, 일관성 부족 문제 발생 가능

에이전트 기반 코딩 최적화 전략 및 팁

     * 좋은 AI IDE를 만들기 위해서는 LLM이 잘하는 작업을 파악하고, LLM의 한계에 맞춰 프롬프트와 도구를 신중하게 설계해야 함.
          + 주 작업을 단순화하고, 서브 작업에 더 작은 모델을 사용하는 방식이 효과적임
          + 복잡한 작업을 분산 처리해 성능 및 일관성 개선 가능
     * 사용자 컨텍스트 추가 (@file 사용)
          + 사용자는 이미 적절한 파일이나 컨텍스트를 알고 있을 가능성이 높음
          + @file 구문 추가 → 전체 파일 또는 폴더 내용을 포함시켜 컨텍스트 제공
          + 팁: @folder/@file 사용 적극 권장 → 명확한 컨텍스트 제공으로 응답 속도 및 정확도 개선
     * 코드 검색 최적화
          + 코드 검색은 복잡할 수 있으며, 특히 의미 기반 검색(예: ""인증 코드 위치"")이 어려움
          + 코드베이스를 벡터 저장소(Vectorstore) 에 인덱싱 → 검색 시 LLM이 자동으로 필터링 및 재정렬
          + 팁: 코드 주석 및 문서 중요 → 임베딩 모델 성능 강화
               o 파일 상단에 해당 파일의 목적, 의미, 수정 시점 설명 추가
     * 파일 작성 최적화
          + 완벽한 코드 작성은 어렵고 비용이 많이 듦
          + 전체 파일 대신 의미적 차이(Semantic Diff) 생성 → 수정된 코드 조각만 제공
          + 의미적 차이를 기반으로 별도의 적용 모델이 실제 파일 작성 → 구문 오류 수정
          + 팁: 적용 모델에 직접 프롬프트 명령 불가 → 전체 파일 제공으로 제어 강화
          + 팁: 적용 모델은 대형 파일 편집 시 속도가 느려지고 오류 발생 가능 → 파일 크기를 500 LoC 이하로 유지
          + 팁: 린터(linter) 피드백은 매우 중요한 신호 → 강력한 린터 도입 필수
               o 컴파일 및 타입 언어가 제공하는 피드백 활용 가능
          + 팁: 고유한 파일 이름 사용 → page.js 대신 foo-page.js, bar-page.js 등 구체적인 이름 사용
               o 문서에서 전체 파일 경로 제공 → 수정 도구의 모호성 제거
     * 에이전트 특화 모델 사용
          + 일반적인 코드 작성 모델이 아닌, 에이전트 특화 모델 사용 권장
          + Anthropic의 모델이 Cursor 같은 IDE에서 뛰어난 성능을 보이는 이유임
          + 팁: 단순히 코드 작성이 아니라 에이전트 기반 IDE에 최적화된 모델 선택
               o WebDev Arena 리더보드에서 모델 성능 확인 가능
     * 셀프 수정 도구 사용 (고급 전략)
          + ""apply_and_check_tool"" → 비싼 린터 실행 + 헤드리스 브라우저에서 콘솔 로그 및 스크린샷 수집
          + MCP(Model Context Protocol) → 에이전트 자율성과 컨텍스트 제공 강화

Cursor 시스템 프롬프트 상세 분석

     * Cursor의 최신 프롬프트(March 2025)는 MCP 기반 프롬프트 주입 기법을 통해 추출됨
          + Cursor의 프롬프트 엔지니어들은 다른 AI IDE와 비교해도 뛰어난 프롬프트 작성 능력을 보유하고 있음.
          + 프롬프트 구조를 분석하면 코드 생성 성능 및 에이전트 아키텍처 설계 능력을 개선 가능
     * 주요 프롬프트 요소 및 의미
          + ""<communication>"", ""<tool_calling>"" 등 태그 사용
               o Markdown 및 XML 태그를 혼합 사용 → 사람이 읽기 쉽고 LLM이 처리하기 용이함
          + ""powered by Claude 3.5 Sonnet""
               o 모델 일관성 강화 → LLM이 실행 중인 모델에 대해 잘못된 정보 제공 방지
          + ""the world's best IDE""
               o LLM이 오류 발생 시 다른 제품 추천 방지
          + ""we may automatically attach some information…follow the USER's instructions…by the <user_query> tag.""
               o 사용자 프롬프트를 직접 전달하지 않고 특수 태그에 포함시켜 혼동 방지
          + ""Refrain from apologizing""
               o 불필요한 사과 방지 (Sonnet 모델의 특징 보완)
          + ""NEVER refer to tool names when speaking""
               o 도구 이름을 언급하지 말라는 명령 추가 → 하지만 실제 모델에서 무시되는 경우 발생
          + ""Before calling each tool, first explain""
               o 도구 호출 전 상태 설명 → 사용자 경험 개선
          + ""partially satiate the USER's query, but you're not confident, gather more information""
               o 과도한 자신감으로 인한 조기 응답 방지 → 추가 정보 요청 유도
          + ""NEVER output code to the USER""
               o 직접 코드 출력 금지 → 도구를 통해서만 코드 생성 허용
          + ""If you're building a web app from scratch, give it a beautiful and modern UI""
               o 단일 프롬프트로 매력적인 웹 앱 생성 유도 (데모 목적)
          + ""you MUST read the the contents or section of what you're editing before editing it""
               o 코드 수정 전 컨텍스트 읽기 강제 → 문맥 인식 강화
          + ""DO NOT loop more than 3 times on fixing linter errors""
               o 수정 루프 제한 → 무한 루프 방지
          + ""Address the root cause instead of the symptoms.""
               o 문제의 증상이 아닌 근본 원인 수정 유도
          + ""DO NOT hardcode an API key""
               o 보안 강화를 위한 명령 → 하드코딩 방지
          + ""codebase_search"", ""read_file"", ""grep_search"", ""file_search"", ""web_search""
               o 코드 작성 전 올바른 컨텍스트 확보를 위한 다양한 검색 도구 제공
          + ""One sentence explanation…why this command needs to be run…"" 요구
               o 도구 인수 처리 시 논리 강화 → 프롬프트 개선 기술 적용
          + ""reapply"" 도구는 ""Calls a smarter model to apply the last edit""
               o 마지막 수정 사항을 더 고급 모델에서 재적용 → 수정 품질 개선
          + ""edit_file"" 도구는 ""represent all unchanged code using the comment of the language you're editing""
               o 수정되지 않은 코드를 주석으로 표시 → 수정 모델 작동 정확성 강화
     * 프롬프트 캐싱 활용
          + 시스템 프롬프트 및 도구 설명은 정적 상태로 유지
          + 코드베이스나 사용자에 따른 맞춤 설정 없음 → 프롬프트 캐싱으로 비용 및 처리 속도 개선 가능

Cursor 규칙 효과적으로 작성 및 사용하기

     * Cursor 규칙 작성의 정답은 상황에 따라 다를 수 있지만, 프롬프트 작성 경험 및 Cursor 내부 구조에 대한 이해를 기반으로 몇 가지 유용한 팁을 제공함
     * 규칙은 단순한 명령이 아니라 백과사전형 지침으로 작성하는 것이 중요함.
     * 규칙 작성의 핵심 개념
          + LLM은 규칙 목록의 이름과 설명을 바탕으로 fetch_rules(…) 호출
          + 규칙은 시스템 프롬프트에 추가되지 않고 필요할 때 참조됨
          + 따라서 명령이 아닌 백과사전식 설명 방식이 효과적임
     * 규칙 작성 시 피해야 할 사항
          + 정체성(identity) 정의 금지
               o ""너는 TypeScript 전문가임"" 같은 설명 금지
               o LLM은 이미 내장된 프롬프트로 정체성을 알고 있음 → 충돌 위험
          + 시스템 프롬프트 덮어쓰기 시도 금지
               o ""주석을 추가하지 마라"", ""질문 후 코드 작성해라"" 등 명령 → 내부 도구 사용 혼란 유발
          + 부정적 명령 금지
               o ""하지 마라""보다 ""해라"" 같은 긍정 명령이 LLM에 더 효과적
               o 긍정 명령 예제: ""파일 수정 시 전체 컨텍스트 확인 후 수정""
     * 규칙 작성 시 권장 사항
          + 명확하고 직관적인 규칙 이름 및 설명 작성
               o 코드베이스에 대한 최소한의 정보만으로도 규칙 적용 가능해야 함
               o 중복 규칙 작성 가능 → 검색 정확도 향상
          + 규칙은 백과사전식으로 작성
               o 구체적 명령보다 상황 및 목적에 대한 설명 제공
               o 필요 시 코드 파일을 연결해 문맥 강화 가능
          + Cursor를 사용해 규칙 초안 작성
               o LLM은 다른 LLM을 위한 컨텍스트 작성에 강함
               o 예: ""@folder/ 자주 수정되는 코드 경로와 정의에 대한 Markdown 파일 생성""
          + 규칙 과다 작성은 지양
               o 너무 많은 규칙은 비효율적이며 비직관적인 코드베이스를 의미함
               o 이상적인 코드베이스는 에이전트가 최소한의 규칙으로 작업 가능해야 함
     * 효과적인 규칙 작성 사례
          + ✅ 규칙 명령:
               o ""파일 수정 전 전체 컨텍스트 읽기""
               o ""서버 코드 수정 시 인증 코드 로직 확인""
               o ""에러 발생 시 원인 먼저 수정""
          + ❌ 규칙 명령 (피해야 함):
               o ""주석을 삭제하지 마라""
               o ""수정 전 나에게 질문해라""
               o ""불필요한 코드 수정하지 마라""
     * 규칙 작성의 핵심 전략
          + 규칙은 명령이 아니라 상황 설명으로 작성
          + 직관적인 이름 및 설명 사용 → 최소한의 규칙으로 최대한의 성능 확보
          + 구체적인 명령보다 상황 설명 및 코드 연결 강화

결론

     * VSCode의 포크에서 시작해 오픈 소스 기반 프롬프트 및 공개 모델 API를 사용한 Cursor가 100억 달러(약 13조 원) 에 가까운 가치 평가를 받은 것은 놀라운 일임
          + Cursor는 현재 ""래퍼 배수(wrapper multiple)"" 기준으로 6배 가치 평가를 받고 있음
     * Cursor는 최적화된 프롬프트 및 강력한 도구 호출 시스템 덕분에 강력한 성능 제공
     * Cursor가 자체 에이전트 모델을 개발할 가능성은 낮음
          + 대신 Anthropic이 Claude Code와 Sonnet 기반의 경쟁 제품을 출시할 가능성이 높음
     * 핵심 인사이트
          + 코드베이스, 문서화, 규칙을 올바르게 설정하는 것은 앞으로도 중요한 기술이 될 것임
          + AI 코딩 도구의 최적화 전략을 이해하면 생산성 및 정확성 강화 가능
          + Cursor가 제대로 작동하지 않는다면 사용 방식의 문제일 가능성이 큼

     ""Cursor가 작동하지 않는다면, 사용법을 다시 점검해야 함.""

   적용해봐야겠네요

     Cursor를 사용해 규칙 초안 작성
     LLM은 다른 LLM을 위한 컨텍스트 작성에 강함

   재미있네요. 역시 같은 물을 먹어서일까요?

   통찰이 녹아있네요. 감사합니다.
     * Cursor 시스템 프롬프트 상세 분석 - 인상적입니다.
     * 앤트로픽이 AI IDE를 출시할 가능성이 있다니 벌써부터 기대가 됩니다.
"
"https://news.hada.io/topic?id=19862","웹 디자인에서 Breadcrumb(브레드 크럼)는 죽었습니다","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   웹 디자인에서 Breadcrumb(브레드 크럼)는 죽었습니다

     * 웹은 더 이상 선형 구조가 아님
          + 브레드크럼은 과거 계층적 웹사이트 구조에서 유용했음
               o 복잡한 기업 사이트, 전자상거래 플랫폼, 정보 저장소 등에서 유용
               o 사용자가 현재 위치를 쉽게 파악하고 뒤로 이동할 수 있도록 도움
          + 그러나 현대 웹은 동적이고 비선형적으로 변화함
               o 단일 페이지 애플리케이션(SPA), **프로그레시브 웹 앱(PWA)**의 등장
               o 계층 구조가 아닌 상황별 탐색과 개인화된 경험이 중요해짐
          + 정적인 브레드크럼은 현대 웹에서 더 이상 적합하지 않음

사용자 여정: 회고적이 아닌 예측적 접근

     * 브레드크럼은 사용자가 어디에 있었는지를 보여주는 데 초점
     * 현대 사용자 여정은 미래에 어디로 갈지 예측하는 데 초점
          + Spotify, Netflix, Amazon 등은 사용자의 행동을 바탕으로 다음 동작을 예측
          + AI 기반 탐색은 사용자 개개인의 선호도에 맞춘 콘텐츠 제공
          + 브레드크럼은 정적이며 사용자에게 새로운 경로를 제시하지 못함

성능 및 모바일 우선 디자인 고려

     * 모바일 우선 디자인에서 브레드크럼은 공간 차지와 성능 저하의 원인
          + 모바일 화면에서 브레드크럼은 공간 낭비
          + 사용자는 고정 내비게이션 바, 페이지 내 필터링, 동적 콘텐츠 추천을 더 선호
     * 제로 클릭 탐색과 무한 스크롤 트렌드가 확산
          + 사용자가 클릭 없이 자동으로 관련 콘텐츠를 제공받는 방식 선호
          + 브레드크럼은 클릭 중심의 구식 탐색 모델에 불과함

사용자 기대: 즉각적 만족감 요구

     * 사용자는 즉각적인 결과와 간편한 경험을 기대
          + Google, Amazon, YouTube 등은 검색과 추천에 최적화됨
          + 브레드크럼은 사용자의 사이트 구조 이해를 돕지만, 이는 사용자 요구에 부합하지 않음
     * 검색 우선 패러다임으로 전환
          + 대부분의 사용자는 검색창에서 직접 탐색 시작
          + 검색 및 내부 탐색이 브레드크럼보다 효율적

브레드크럼 이후의 대안: 적응형 디자인 솔루션

  1. 상황별, 동적 내비게이션

     * 사용자 행동 및 선호도에 따라 내비게이션이 실시간으로 적응
     * 스마트 적응형 탐색 시스템 필요

  2. 검색 중심 인터페이스

     * 예측 검색, 의미 기반 검색 등 검색 기능 강화
     * 사용자는 원하는 정보를 빠르게 찾을 수 있어야 함

  3. AI 기반 탐색 시스템

     * AI를 통해 사용자 행동 분석 및 콘텐츠 추천
     * 관련 콘텐츠를 자동으로 표시해 사용자의 클릭 수 최소화

  4. 미니멀리즘 및 직관적 탐색

     * 복잡한 다단계 메뉴 대신 단순하고 직관적인 설계
     * 고정 내비게이션 바, 스마트 메뉴, 필터, 상황별 페이지 내 내비게이션 제공

결론: 브레드크럼을 버리고 미래로 나아갈 때

     * 브레드크럼은 과거의 솔루션이었지만 현대 웹 환경에서는 무용지물
     * 개인화된 AI 기반 탐색 및 동적 사용자 경험이 새로운 탐색 트렌드
     * 사용자의 기대에 부응하는 속도, 단순성, 상황 인식형 내비게이션이 미래의 핵심
     * 브레드크럼은 이제 과거의 유물이 되었으며, 현대 웹 디자인은 적응형 탐색으로 전환해야 함

   또 관이야??

   웹 기술이 아무리 진보해도… 그걸 쓰는 게 “사람”은 2차원 - 기껏해야 3차원이 한계입니다.
   그래서 브레드크럼은 여전히 유용하고 앞으로도 그럴거라고 생각합니다. “사람“이 볼 웹이라면 말이죠.

   ??? is dead.
"
"https://news.hada.io/topic?id=19888","Apple, Siri를 되살리기 위해 AI 임원진을 개편","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Apple, Siri를 되살리기 위해 AI 임원진을 개편

     * 애플은 인공지능(AI) 노력을 재정비하기 위해 경영진을 개편하고 있음.
     * 팀 쿡 CEO는 AI 책임자인 존 지안안드레아의 제품 개발 능력에 대한 신뢰를 잃고, Vision Pro 창조자인 마이크 록웰을 새로운 역할로 이동시킴.
     * 록웰은 소프트웨어 책임자인 크레이그 페더리기에게 보고하며, Siri는 지안안드레아의 지휘에서 완전히 벗어남.

Siri의 문제와 해결

     * Siri는 새로운 기능 출시 지연으로 어려움을 겪고 있으며, 이는 iPhone 16의 주요 판매 포인트였음.
     * 록웰은 기술적 경험이 풍부한 임원으로, Siri의 문제를 해결하기 위해 선택됨.
     * 그는 Vision Pro의 개발을 이끌었으며, AI를 미래의 장치에 더 깊이 통합하는 데 도움을 줄 수 있음.

AI 관리 변화의 배경

     * Siri는 여러 명의 책임자를 거쳤으며, 록웰이 새로운 리더로 임명됨.
     * 지안안드레아는 여전히 회사에 남아 있으며, AI 관련 연구와 기술을 감독함.
     * 록웰은 Siri를 더 개인화된 음성 비서로 개편할 아이디어를 제안해 왔음.

Vision Pro와 AI의 통합

     * 록웰은 Vision Pro 개발 시 Siri를 주요 제어 수단으로 고려했으나, 현재는 손과 눈을 통한 제어에 주력하고 있음.
     * 애플은 Vision Pro에 Apple Intelligence를 도입하기 위해 노력 중이며, 이는 4월에 visionOS 소프트웨어 업그레이드의 일환으로 출시될 예정임.

        Hacker News 의견

     * John Giannandrea(JG)가 Google Assistant를 운영했을 때 성과가 좋지 않았음. JG가 Apple AI의 수장이 되었을 때 놀랐음. 이 분야에서 잘된 점을 찾기 어려움. 더 깊은 이야기가 있는 것 같음
     * Craig Federighi는 발표와 유머에 능하지만, Apple의 소프트웨어 품질에 대한 이해가 부족하다고 생각함. Siri를 그의 관리 하에 두는 것이 좋은 생각인지 의문임. Siri는 10년 넘게 거의 쓸모가 없었음. Apple 외부에서는 기대가 없음. 이 유출은 중요해 보임. Apple은 유출한 임원을 해고하고 금전적 벌금을 부과할 것임
     * Google Maps의 경험이 최근 2년간 나빠져서 Apple Maps를 사용하기 시작했음. Apple Maps의 발전에 놀랐음. Siri의 사용자 경험이 나쁜 이유는 모르겠지만, AI 제품에서 OpenAI나 Google보다 더 잘할 수 있는 회사는 Apple이라고 생각함
     * John ""JG"" Giannandrea는 2018년 Apple의 AI/ML 부문을 이끌기 위해 고용되었음. Mike Rockwell은 2015년 Dolby Labs에서 Apple로 고용되어 Apple Vision의 R&D 및 제품 그룹을 이끌었음. Siri 조직이 Giannandrea의 범위에서 Rockwell의 관리 하로 이동 중임. Apple은 AI/ML 조직을 구축했지만 성공적인 제품으로 이어지지 못했음
     * 10년 전 Apple/Siri에서 데이터 과학자로 일했을 때, 시스템이 규칙 기반이라는 것에 충격을 받았음. 팀과 함께 통계적 학습 모델을 도입하려 했지만 실패했음. 몇 년 후에도 시스템은 여전히 규칙 기반이었음. 새로운 아이디어에 대한 유연성이 부족했음
     * 미래가 어떤 순서로 도래하는지는 종종 놀라움. 1960년대에는 로봇이 논리에 능하고 공감 능력이 부족할 것으로 예상했음. 2025년에도 로봇 공학의 발전은 느림. Siri와 음성 UI의 병목 현상은 예상치 못한 곳에 있음. 음성 인식은 좋아졌지만, 좋은 UI가 없음
     * Steve Jobs의 소통 스타일과 세부 사항에 대한 주의력에 대한 이야기가 있음. Steve는 전화기를 물탱크에 던져 공기 방울을 보고 여전히 사용되지 않은 공간이 있다고 주장했음. Apple에서 이런 세부 사항에 주의를 기울이고 변화시킬 수 있는 사람이 있는지 궁금함
     * Siri는 간단한 질문에도 50% 이하의 유용성을 보임. 아이들과 함께 차 안에서 Siri에게 질문할 때마다 농담을 함. Siri가 왜 이렇게 나쁜지 이해할 수 없고, Apple이 더 일찍 조치를 취하지 않은 것이 부끄러움
     * Apple은 소프트웨어 전반에 걸쳐 큰 변화가 필요함. AI는 문제의 한 예시일 뿐이며, 더 깊은 문제가 있음. 하드웨어는 훌륭하지만 소프트웨어가 발목을 잡고 있음. OS API, SDK, 개발 도구, WatchOS, 확장성, Shortcuts, AI 활용 등 전체 스택을 재고해야 함. Siri라는 이름을 버리고 새로운 AI를 도입해야 함. 소프트웨어 품질과 테스트 접근 방식을 개선해야 함
"
"https://news.hada.io/topic?id=19850","fd - `find`의 간단하고 빠르며 사용자 친화적인 대체제","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   fd - `find`의 간단하고 빠르며 사용자 친화적인 대체제

     * fd는 파일 시스템에서 항목을 찾기 위한 프로그램으로, 기존 find 명령어보다 간단하고 빠르며 사용자 친화적인 대안임
          + find의 모든 기능을 지원하지는 않지만, 일반적인 사용 사례에 대해 합리적인 기본값 제공
     * 윈도우,맥,리눅스
     * 직관적인 문법: fd PATTERN 형식으로 간단하게 사용 가능 (find -iname '*PATTERN*'보다 간편함)
     * 정규 표현식 및 glob 패턴 지원
     * 병렬 디렉토리 탐색으로 빠른 성능 제공
     * 파일 유형에 따른 색상 강조 (ls와 유사)
     * 병렬 명령 실행 지원
     * 스마트 대소문자 구분: 기본적으로 대소문자 무시, 대문자 포함 시 대소문자 구분
     * 숨김 파일 및 디렉토리 기본적으로 무시
     * .gitignore 패턴 기본적으로 무시
     * 명령어 이름이 find보다 50% 짧음

사용법

     * 현재 디렉토리에서 패턴이 포함된 항목 검색 fd netfl
     * 정규 표현식을 사용한 검색 가능 fd '^x.*rc$'
     * 특정 디렉토리에서 검색 fd passwd /etc
     * 현재 디렉토리 아래의 모든 파일 목록 재귀적으로 리스팅 fd
     * 특정 파일 형식 검색 가능 (-e 옵션 사용) fd -e md
     * 정확한 파일명 검색 가능 (-g 옵션 사용) fd -g libc.so /usr
     * 숨김 파일 및 무시된 파일 포함 검색 (-H, -I 옵션 사용) fd -H pre-commit fd -I num_cpu
     * 파일 이름이 아닌 전체 경로에서 검색 (-p 옵션 사용) fd -p '.*/lesson-\d+/[a-z]+.(jpg|png)'
     * 검색된 각 결과에 대해 명령 실행 (-x) fd -e zip -x unzip
     * 모든 검색 결과를 하나의 명령에 전달 (-X) fd -g 'test_*.py' -X vim
     * 자리 표시자(Placeholder) 구문
          + {}: 검색 결과 전체 경로
          + {.}: 파일 확장자 제외 경로
          + {/}: 파일명
          + {//}: 부모 디렉토리
          + {/.}: 파일명에서 확장자 제외
     * 특정 디렉토리 또는 파일 제외 가능 (-E 옵션 사용) fd -H -E .git
     * .fdignore 파일을 만들어 전역 제외 패턴 설정 가능
     * 검색된 파일 삭제 가능 (-X rm) fd -H '^\.DS_Store$' -tf -X rm

주요 명령어 옵션

     * -H: 숨김 파일 및 디렉토리 포함 검색
     * -I: .gitignore 및 .fdignore 무시
     * -p: 전체 경로에서 검색
     * -e: 특정 확장자 검색
     * -x: 검색 결과에 명령 실행
     * -X: 모든 검색 결과를 하나의 명령에 전달
     * -E: 특정 파일 또는 디렉토리 제외

성능 비교 (Benchmark)

     * 750,000개 디렉토리와 400만 개 파일에서 검색 테스트 결과
          + find 성능: 약 19.9초
          + fd 성능: 약 854.8ms
     * find보다 23배 빠름

다른 프로그램과의 통합

     * fd 검색 결과를 fzf에서 표시 가능 export FZF_DEFAULT_COMMAND='fd --type file'
     * fd 출력 결과를 rofi에서 메뉴로 표시 fd --type f -e pdf . $HOME | rofi -dmenu
     * 출력 결과를 트리 구조로 표시 fd | tree --fromfile
     * 검색 결과를 xargs에서 사용 가능 fd -0 -e rs | xargs -0 wc -l

   neovim plugin 중에서 fd 사용하는 녀석이 있어서, 설치했다가 지금까지 쓰고 있네요 ㅎㅎ.

        Hacker News 의견

     * Alfred workflow를 출시했음. 사용자 정의 디렉토리를 검색하는 데 fd를 많이 사용함. 매일 사용하며 매우 훌륭함
          + Hyperfine도 과소평가된 훌륭한 도구임
     * sharkdp의 팬임. 매일 사용하는 멋진 소프트웨어를 만들어줘서 고마움
          + bat, fd, hexyl, hyperfine을 사용함
          + 잘 보상받는 엔지니어들이 매달 $10씩 기부하면 인터넷이 더 나아질 것임
          + 많은 훌륭한 도구들이 있으며, 이를 지원하는 생태계를 만들어야 함
     * fd, bat, numbat, hexyl, hyperfine을 빠르게 설치하고 스크린샷을 Terminal Trove에서 볼 수 있음
          + fd, bat, numbat, hyperfine, hexyl의 링크 제공
          + 설치와 스크린샷 확인 가능
     * fd와 rg의 플래그가 일치했으면 좋겠음. 예를 들어, fd와 rg 모두 --type 플래그가 있지만 의미가 다름
          + fd는 파일/디렉토리/심볼릭 링크 등을 의미하고, rg는 파일 MIME 타입을 의미함
          + fd에는 --extension 플래그가 있지만 rg에는 없음
          + 두 도구의 사용이 높은 상관관계를 가지므로 유사한 이름의 플래그가 유익할 것임
     * 새로운 Rust 도구를 사용하지 않는 이유는 원래 도구의 옵션을 기억하기 어려워서임
          + ripgrep을 VS Code에서 사용하지만 명령줄에서는 grep을 사용함
          + 도구가 작동하기만 하면 어떤 언어로 작성되었는지는 상관없음
          + GNU Stow는 Perl로 작성되었지만 좋아하는 Unix 도구 중 하나임
          + Rust 도구가 드롭인 대체품이라도 수동으로 설치하지 않을 것임
          + 사용자로서 속도 개선과 메모리 안전성은 중요하지 않음
          + Go 같은 다른 언어도 메모리 안전성을 보장하며, 커뮤니티 참여도 높음
          + Rust가 구세주라는 서사에 완전히 설득되지 않음
          + macOS나 Ubuntu가 Rust 대체품으로 교체해도 워크플로우에 지장이 없다면 불만 없음
     * Terminal Trove를 가끔씩 확인해야 함
          + 자주 사용하는 도구의 쉬운 대체품을 찾을 수 있음
          + find는 fd로, time은 hyperfine으로, grep은 ripgrep으로 대체 가능
          + asciinema를 .gif로 변환하는 t-rec, 수동으로 커밋 생성하는 koji 등
     * fd를 사용해볼 예정임. find의 인수 사용법을 기억하기 어려워서 find . | grep what_i_am_looking_for를 주로 사용함
          + xargs와 통합된 동작이 마음에 듦
          + fd가 symlink 디렉토리 탐색을 어떻게 처리하는지 찾지 못했음
     * 매일 fd를 많이 사용하며 새 기기에 기본 설치함
          + find를 오랫동안 사용했지만 편리한 사용성은 아님
          + 최근 대체 유틸리티 트렌드에 100% 동의함
          + 원래의 유연성을 모두 유지하지 않을 수도 있지만 일반적인 경우에 사용하기 훨씬 쉬움
     * 기본적으로 많은 폴더를 무시하는 것이 불편함
          + 시스템 어디에 있는지 알고 싶을 때 find를 사용함
          + fd에 무시하지 않는 옵션이 있지만 기억하지 못해 find로 돌아감
     * 새로운 Rust CLI 도구를 좋아하지만 fd는 tar와 ln처럼 사용법을 기억하기 어려움
          + 누구의 잘못도 아님
          + 항상 매뉴얼을 다시 읽어야 함
          + GNU find의 특이점에도 불구하고 더 잘 기억됨
"
"https://news.hada.io/topic?id=19877","자바의 체크드 예외 재고찰: 저평가된 타입 안전성 기능","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     자바의 체크드 예외 재고찰: 저평가된 타입 안전성 기능

  주요 내용 요약

     * 자바의 체크드 예외가 커뮤니티에서 널리 비판받는 기능임에도 타입 안전성 측면에서 뛰어난 장점 보유.
     * Rust의 Result<T, E>나 Haskell의 Either a b와 개념적으로 유사한 타입 안전성 메커니즘 제공.
     * 체크드 예외가 메서드 시그니처에 잠재적 실패 가능성을 명시적으로 표현하여 타입 시스템을 통한 오류 처리 강제.

  체크드 예외의 장점

     * 컴파일 타임에 예외 처리 여부 확인을 통한 타입 안전성 제공.
     * 메서드 시그니처에 throws 절로 예외 가능성을 명시하여 API 계약의 일부로 만듦.
     * 선언만 하면 자동으로 예외가 전파되는 편리한 메커니즘 제공.
     * Rust와 달리 매 호출마다 ? 연산자 같은 추가 구문 불필요.

  체크드 예외의 문제점

     * 콜 체인에서 과도한 보일러플레이트 코드 발생.
     * 자바 8 이후 도입된 람다와 스트림 API 등 함수형 프로그래밍과의 호환성 부족.
     * 인터페이스에 새 예외 추가 시 호환성 깨짐으로 인한 API 진화 어려움.
     * 예외를 무시하는 안티패턴 조장 가능성.

  개선 제안

     * 람다가 체크드 예외를 선언할 수 있도록 함수형 인터페이스 개선.
     * throws 절에 제네릭 예외 타입 지원 추가.
     * 함수형 컨텍스트에서 체크드 예외를 더 잘 다룰 수 있는 API 확장.
     * Optional<T> 및 Stream<T> API와의 더 나은 통합.

  다른 언어와의 비교

     * Rust: Result<T, E>와 ? 연산자를 통한 명시적 오류 처리 메커니즘 제공.
     * Kotlin: 모든 예외를 언체크드로 만들었으나 runCatching과 같은 함수형 구조 제공.
     * Scala: Try[T], Either[A, B] 등의 모나딕 타입을 통한 함수형 오류 처리 지원.

  결론

     * 체크드 예외는 자바의 오해받은 혁신적 기능으로 재평가 필요.
     * 완전히 포기하기보다 현대적 자바 기능과 잘 어울리도록 개선하는 것이 바람직함.
     * 기존 패러다임 유지하면서 실용적 문제 해결 방향으로 발전 가능성 존재.
     * 타입 안전성과 코드 간결성, 유연성 사이의 균형점 찾기 중요.

   이미 십수년간 얘기했던 논쟁을 반복하는 느낌이 들었어요. Exception도 Type만큼의 가치가 있다는 주장같고, 저는 Type으로 충분하다는 대답을 해보고 싶습니다.
"
"https://news.hada.io/topic?id=19947","Quadlet: Podman 컨테이너를 systemd로 실행하기","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Quadlet: Podman 컨테이너를 systemd로 실행하기

     * Quadlet은 Podman 컨테이너를 systemd 서비스로 실행할 수 있게 해주는 도구임. 이는 서버 재부팅 후 백그라운드에서 자동으로 컨테이너를 시작하는 데 유용함.
     * 기존에는 podman generate systemd 명령어를 사용했으나, 이제는 Quadlet로의 마이그레이션이 권장됨.

  기존 방법

     * 컨테이너를 생성하고, systemd 서비스 파일을 생성한 후, 해당 파일을 적절한 디렉토리로 이동하여 서비스를 활성화해야 했음.
     * 이 과정은 명령어가 길고 반복적이며, 수동으로 파일을 수정해야 하는 불편함이 있었음.

  문제점

     * 기존 방법은 복잡하고 유연성이 부족했음.
     * Docker Compose의 편리함과 비교했을 때, 수동으로 많은 작업을 해야 했음.

  Quadlet

     * Quadlet을 사용하면 .container 파일을 생성하여 컨테이너를 관리할 수 있음.
     * [Container] 섹션을 통해 이미지, 포트, 볼륨, 환경 변수를 설정할 수 있음.
     * [Service] 섹션에서 컨테이너 재시작 정책을 설정할 수 있음.
     * [Install] 섹션에서 부팅 시 자동 시작을 설정할 수 있음.

  더 나은 점

     * 하나의 파일로 모든 설정을 관리할 수 있으며, systemd의 모든 옵션을 사용할 수 있음.
     * 설정 파일 작성이 스크립트 작성보다 쉬움.
     * 종속성을 쉽게 관리할 수 있음.

  종속성

     * 앱 컨테이너가 데이터베이스 컨테이너에 의존하는 경우, [Unit] 섹션에서 Requires와 After 옵션을 사용하여 종속성을 설정할 수 있음.

  파일이 너무 많을까?

     * 여러 파일로 나누는 것이 복잡성을 줄일 수 있음.
     * 관련된 파일들을 그룹화하여 관리할 수 있음.

  이미지 업데이트

     * AutoUpdate=registry 옵션을 사용하면 podman auto-update 명령어로 이미지 업데이트 및 컨테이너 재시작이 가능함.
     * latest 태그 사용은 위험할 수 있으므로, 구체적인 버전 태그 사용을 권장함.

  podman-compose에 대해

     * podman-compose는 Compose 파일을 Podman과 systemd로 변환하는 스크립트지만, 장기적인 대안으로는 적합하지 않음.
     * Quadlet은 Podman의 무데몬 설계와 더 잘 맞음.

  추가 자료

     * Quadlet에 대한 더 깊은 이해를 위해 podman-systemd.unit 매뉴얼 페이지를 읽어볼 것을 권장함.
     * Quadlet은 컨테이너뿐만 아니라, pod, 네트워크, 볼륨도 관리할 수 있음.
     * systemd 유닛 파일 작성에 익숙하지 않다면 systemd.unit과 systemd.service 매뉴얼 페이지도 참고할 것.
     * podlet은 Podman 명령어 또는 Compose 파일에서 Quadlet 파일을 생성하는 데 도움을 줄 수 있는 도구임.

        Hacker News 의견

     * Quadlet은 Docker Compose의 대안으로, ""생산 환경과 유사한 환경에서 상호 의존적인 컨테이너를 실행""하는 데 유용함. 그러나 개발 환경에서는 덜 유용함
          + Docker Compose는 데이터베이스, Redis, OpenSearch 등의 종속성을 쉽게 관리할 수 있음
          + Quadlet은 파일을 ~/.config/containers/systemd에 두어야 하므로 프로젝트와의 격리가 어려움
          + 많은 개발자들이 여전히 Docker를 사용하며, Podman을 사용하려면 수동으로 설정을 추가해야 함
          + 개발을 위한 Docker Compose의 대안이 필요하지만, Quadlet은 적합하지 않음
     * Quadlet을 발견하고 Atomic OS와 루트리스 Quadlet을 기반으로 홈랩을 구축했으며, 이를 강력히 추천함
          + systemd 소켓 활성화를 사용할 수 있어 Traefik을 자동으로 활성화할 수 있음
          + 루트리스 설정에서 소스 IP를 보존하는 유일한 방법임
     * Quadlet은 Podman에서 나온 최고의 도구 중 하나이며, 컨테이너 기반 작업에 관심 있는 사람들에게 추천함
          + 컨테이너를 시스템 서비스처럼 다룰 수 있어 편리함
          + Docker의 대안으로 Quadlet을 사용하면 더 깔끔한 설정이 가능함
          + 로컬 개발 환경에서는 Docker Compose의 대안이 아니며, Podman 팀도 이에 대해 큰 관심이 없음
     * Docker Compose의 편리함 때문에 많은 사람들이 Docker에서 Podman으로 전환하는 것을 주저함
          + Quadlet은 Docker Compose의 대안으로 Podman을 사용할 수 있게 해줌
          + Docker를 그리워하지 않을 것이며, 루트리스 컨테이너 실행의 보안성을 누릴 수 있음
     * Podman-Compose가 ""유지 관리되지 않음""이라고 언급되었지만, Podlet도 비슷한 상태임
          + Podlet은 Docker Compose의 많은 기능을 지원하지 않으며, 여러 yaml 파일을 쌓는 것을 지원하지 않음
     * Podman의 업스트림이 Debian/Ubuntu에 대한 저장소를 제공하지 않아 불편함
          + Docker Compose로 돌아가게 되었음
     * openSUSE MicroOS를 사용하여 Podman 컨테이너를 systemd/quadlet 하에서 실행하게 되었으며, 현재 설정에 만족함
          + Podman Compose는 사용하기 불편했으며, Quadlet이 더 나은 선택임
     * systemd와 Podman의 통합을 좋아함
          + Docker Compose는 여전히 경쟁력이 있으며, Quadlet은 프로젝트 디렉토리를 복잡하게 만들 수 있음
     * Quadlet이 Hacker News의 첫 페이지에 올라온 것이 흥미로움
          + Kubernetes YAML을 사용하여 이동성이 높음
     * Quadlet은 컨테이너를 일반 시스템 서비스처럼 사용할 수 있게 해줌
          + 루트리스 컨테이너의 UX는 이 개념과 잘 맞지 않음
          + 루트리스 Quadlet을 시스템 세션 내에서 실행할 수 있기를 바람
"
"https://news.hada.io/topic?id=19981","Debian Bookworm 라이브 이미지 재현 가능성 확보","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Debian Bookworm 라이브 이미지 재현 가능성 확보

     * Debian bookworm 라이브 이미지 완전 재현 가능
          + Debian 개발자 Roland Clobus가 Reproducible Builds 메일링 리스트에 짧은 공지를 통해 Debian 12.10 (""bookworm"")의 라이브 이미지가 이제 100% 재현 가능함을 발표함
          + 재현 가능한 라이브 이미지와 Debian Live 관련 정보는 Debian 위키에서 확인 가능함
     * 저작권 정보
          + © 2025, Eklektix, Inc.의 저작권 소유
          + 댓글과 공개 게시물은 작성자에게 저작권이 있음
          + Linux는 Linus Torvalds의 등록 상표임

        Hacker News 의견

     * 엄청난 노력임. 몇 년 전만 해도 꿈같은 이야기였음. 관련된 모든 사람들, 특히 이 노력을 주도한 사람들에게 축하를 보냄
     * 빌드의 재현 가능성을 어떻게 달성하는지 이해가 안 됨: 파일 메타데이터, 예를 들어 생성/수정 타임스탬프는 어떻게 되는지? 그것들을 위조하는지? 아니면 이러한 데이터가 중요하지 않다고 여겨지는지 (다른 메타데이터를 가진 두 파일이 동일한 내용을 가지고 있을 때 해시했을 때 동일한 체크섬을 가져야 한다고 생각하는지)?
     * Debian의 빌드 인프라스트럭처도 재현 가능한지? 누군가 Debian 패키지 바이너리에 악성 코드를 주입하려면 (소스에 주입하지 않고) 빌드 인프라스트럭처(컴파일러, 링커 및 그 주변에 작성된 래퍼 코드)를 타겟으로 해야 할 것 같음
          + 또한, 다른 누군가가 이러한 이미지를 컴파일하고 있는지, Debian 컴파일 서버가 손상되지 않았다는 증거가 있는지?
     * 재현 가능한 빌드의 중요성은 무엇이며, 일반적인 배포와 어떻게 다른지?
     * 놀라운 소식임. 잘했음
     * 이것은 큰 이정표임
     * 이 주제에 대해 초보자임. 빌드가 재현 불가능할 수 있는 방법은 무엇인지? 즉, 빌드 프로세스의 어떤 부분이 비결정적 출력을 반환할 수 있는지? 사람들이 타임스탬프 같은 것을 빌드에 넣고 있는지?
     * 좋음, 이러한 라이브 이미지는 Debian 기반 ""불변 OS"" 워크플로의 기초가 될 수 있음
     * 이러한 라이브 이미지가 cloud-init을 준비하고 있는지? 메모리 내 cloud-init 라이브 iso는 어디서든 불변 인프라에 완벽해 보임
"
"https://news.hada.io/topic?id=19926","Show GN: Laravel AI Translator: 더 강력해진 라라벨 기반 (혹은 Crowdin) 프로덕트의 AI 번역 시스템","                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Show GN: Laravel AI Translator: 더 강력해진 라라벨 기반 (혹은 Crowdin) 프로덕트의 AI 번역 시스템

   이전에 소개시켜드린바가 있지만, 새로운 기능을 업데이트 하고 리팩토링 작업을 하게 되어 공유합니다.

   저는 글로벌 게임 데이터 서비스 OP.GG를 창업하고 운영중입니다.

   저희는 15개 국어가 넘는 언어를 서비스중인데, 그동안 사람 번역가를 이용하면서 몇 달간 일정이 미뤄진다던가, 번역 업체들이 몰래 기계 번역기를 이용하여 번역을 해서 오는 어뷰징을 당한다던가, 번역 퀄리티가 너무 낮다던가 하는 일들을 많이 겪으면서 새롭게 구상한 프로젝트입니다.

   이 프로젝트는 3개 이상의 언어를 번역할 때 사람에게 맡기는 것 보다 훨씬 빠르게 (수분 내), 그리고 최상의 퀄리티는 아니지만 최소한 중간 이상의 퀄리티를 보장하기 위해서 AI기술을 사용해서 만들어봐야겠다는 목표로 만들기 시작했습니다. 목표는 사람 번역이 90점이고 구글 번역기가 30점이라면, 이 번역기는 80점을 만드는 것이 목표입니다. 그리고 LLM의 발전에 따라, 1-2년 내 90점 이상까지도 바라볼 수 있을 것 같습니다. 물론 비용은 사람보다 훨씬 낮습니다.

   주요 고려된 기능들은 다음과 같습니다.
     * 가능한 많은 연관 String 을 AI 요청시 컨텍스트에 포함하여 번역의 일관성과 단어 사용의 일관성을 높힙니다. 소스 언어의 스트링과, 타겟 언어의 이미 번역된 스트링을 컨텍스트에 포함합니다. [신규기능]
     * 소셜 번역 플랫폼이자 외주를 쉽게 맡길 수 있는 업체들이 연동되어 있는 번역 플랫폼인 CrowdIn 을 이용하신다면, CrowdIn 의 프로젝트도 번역할 수 있는 기능이 숨어있습니다. 라라벨과 전혀 연관 없는 프로젝트셔도 활용하실 수 있습니다. 문서에는 없지만, 저희 내부용으로 개발했습니다. (명령어: ai-translator:translate-crowdin) [신규기능]
     * LLM이 지원하는 전세계 모든 언어 설정 가능
          + 나만의 언어 기능 추가 가능. 북한 문화어, 레딧 용어등이 README.md 에 예제로 제시되어 있음.
     * Claude, OpenAI 지원 (단, Claude 모델 사용이 퀄리티가 높아서 추천드림)
          + Claude 3.7 Deep Thinking 지원 [신규기능]
     * 라라벨 로컬리제이션 기능중 복수 처리 (Plural) 지원
     * 언어를 똑똑하게 번역하도록 함
          + 문장인지, 단어인지 구분하여 번역함
          + Key 를 보고 가능한 개발자의 의도에 맞게 번역함 (따라서 key 를 매우 명확하게 잘 표현해주셔야함)
     * 각 언어와 프로젝트별로 컨텍스트를 추가하여, 프로젝트를 번역할 때 훨씬 더 자연스럽게 번역할 수 있도록 함 (핵심)
          + 그냥 번역을 시키는 것 보다 AI에게 이 프로젝트의 어떤 특정 단어는 어떤 것을 의미하는지 명확하게 알려주는 것이 퀄리티 향상에 매우 중요합니다.
          + 예를들어 영어로 'Champion' 이라는 단어를 사용할 때, 한국어로 번역할 때는 '챔피언'이라고 번역을 해야하고, 중국어로 번역할 때는 英雄(영웅) 으로 번역한다던가 하는 것을 알려주면 훨씬 더 자연스럽게 번역합니다.

   Prompt 작성에 대한 공부를 하시는 분이라면 이 폴더에 방문하셔서 제가 만든 프롬프트를 둘러보세요. 그리고 더해주시고 싶으신 아이디어가 있으면 Pull Request 를 부탁드립니다.

   laravel 공식 문서들도 가능할까요?

   좋은 프로젝트 소개 감사합니다.
   혹시 docker 이미지를 제공해주시면 사용이 더 편리할 것 같습니다

   LLM API 를 이용하면 비용이 꽤 높을 수 있어서 입력값에 대해 비용 예측 기능도 있으면 좋겠습니다.

   north korean 이 번들 제공되어 있는게 재밌네요 옵지 유저로서 응원합니다

   초창기 부터 다국어 제공에 노력하셨던거 같은데 응원드립니다.
"
"https://news.hada.io/topic?id=19943","Triforce - 애플 실리콘 노트북용 빔포머","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Triforce - 애플 실리콘 노트북용 빔포머

     * Triforce는 Apple Silicon 노트북의 마이크로폰 배열을 위한 Minimum Variance Distortionless Response 적응형 빔포머를 구현
     * 지원되는 모델: 맥북 프로/에어 M1 이상의 모델들
     * 위의 Apple Silicon 노트북들은 삼각형 또는 직선으로 배열된 마이크로폰을 가짐
     * Apple은 사용자 공간에서 적응형 빔포머를 구현하여 배경 소음에서 원하는 신호를 분리하려고 함
     * 빔포밍이 없으면 배열은 너무 민감하고 전방향성이어서 유용하지 않음
     * macOS 외부에서 유용하게 사용하려면 빔포머가 필요함
     * 지원 모델 리스트
          + MacBook Pro 13"" (M1/M2)
          + MacBook Air 13"" (M1/M2)
          + MacBook Pro 14"" (M1 Pro/Max, M2 Pro/Max)
          + MacBook Pro 16"" (M1 Pro/Max, M2 Pro/Max)
          + MacBook Air 15"" (M2)

  Expectation management

     * DSP 관련 주제, 특히 광대역 적응형 빔포밍에 대한 접근 가능한 문헌을 찾는 것은 매우 어려움
     * 이 프로젝트는 1학년 공학 수학 수준의 지식과 웹페이지 및 PDF에서 얻은 원칙을 바탕으로 한 빔포머 시도임
     * 현재 Apple의 구현을 능가할 것으로 기대하지 말아야 함
     * 개선을 위한 패치는 언제나 환영함

  알려진 제한 사항

     * nalgebra는 명시적인 SIMD 최적화를 수행하지 않으며, LLVM 자동 벡터화를 의존함
     * 행렬 수학 루틴의 성능과 효율성이 좋지 않음
     * 추가적인 계산 부담 때문에 광대역 분해를 수행하지 않음
     * SIMD/NEON 지원이 없으면 실시간 오디오 플러그인으로는 너무 느림
     * 출력은 모노만 지원함
     * 스테레오 출력을 가짜로 만들기 위한 추가 행렬 처리는 계산적으로 너무 부담스러움

        Hacker News 의견

     * 20년 전, Toshiba Tablet PC 변환형 모델에 빔 형성 마이크 배열이 있었음. 소프트웨어로 녹음 방향을 지정할 수 있었음
          + 강의에서 유용했으며, 교수 방향으로 빔을 조정하여 녹음할 수 있었음
          + 이후로 이런 기능을 본 적이 없음
     * 미완성된 석사 논문은 스마트폰의 마이크를 활용하여 3D에서 스피커를 위치 및 분리하는 것에 관한 것이었음
          + 기기 간 샘플링 속도가 약간 다름
          + 소비자용 마이크의 스펙트럼 특성이 다양함
          + 소리는 모든 곳에서 반사되며, 특히 콘크리트 벽에서 두드러짐
          + 자동차는 쉽게 접근할 수 있는 무향실과 유사함
          + 가우시안의 푸리에 변환은 가우시안이며, 이는 주파수 추정에 유용함
     * Apple Silicon Mac에서 Linux를 실행하는 데 많은 작업이 필요함을 깨달음
          + 내장 마이크는 거의 사용되지 않음
          + Apple의 모든 것이 간단하지 않음
     * 저렴한 노트북 하드웨어에서도 소프트웨어 DSP 기술로 놀라운 결과를 얻을 수 있음
          + Asahi의 오디오 작업이 일반 노트북에도 적용 가능함
          + Bankstown 베이스 하모닉 합성 플러그인과 컨볼루션 EQ를 사용하여 인상적인 결과를 얻음
     * SIMD 최적화에 대해 faer를 고려할 수 있음
          + pulp 라이브러리 경험은 좋지 않았으나, 주로 선형 대수 연산 가속화가 목표라면 잘 될 것임
          + Rust SIMD에 관한 블로그 게시물과 팟캐스트가 예정되어 있음
     * Apple Silicon 노트북의 마이크 배열에 대한 질문
          + M2/M3 모델에 유사한 마이크 배열이 있는지 또는 테스트되지 않았는지 궁금함
          + Linux와 MacOS에서 지원되는지 여부에 대한 의문
     * Apple이 스피커와 마찬가지로 마이크에서도 너무 복잡하게 접근하는 것 같음
          + MBP 사용자로서 스피커 구현에 감명받았음
          + 드라이버 배열 외에는 지식이 없지만, 작은 스피커에서 성능을 끌어내기 위한 트릭을 사용하고 있는 것 같음
     * 최신 Asahi Linux 진행 보고서에 대한 일반적인 논의
          + PDM 마이크는 매우 전방향적이고 민감함
          + 빔 형성이 필요함
          + 스피커 출력에 대한 이전 작업이 마이크 입력에 재사용됨
          + PipeWire와 WirePlumber 덕분에 마이크용 DSP 체인을 연결하는 것이 간단했음
     * 다른 제조업체도 쉽게 마이크 배열을 구축할 수 있도록 구현되면 좋겠음
"
"https://news.hada.io/topic?id=19897","Calibre 8.0 릴리즈 - e북 리더 & 관리자 ","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Calibre 8.0 릴리즈 - e북 리더 & 관리자

     * Calibre는 전자책 관리 및 변환을 위한 강력한 도구로, 다양한 장치 및 형식을 지원하며, 지속적인 업데이트를 통해 사용자 경험을 개선
     * 폴더 연결 기능 : 특정 폴더를 USB 장치처럼 인식 가능. Chromebook 등에서 USB 장치가 폴더로 표시될 때 유용
     * 목차 편집기 개선 : 여러 개의 선택된 항목을 동시에 이동 가능
     * 계층형 데이터 입력 개선 : 이름 입력 시 접두사 모드에서 점(.) 이후의 접두사도 일치 가능
     * macOS 아이콘 스타일 수정 : 애플의 최신 권장 스타일에 맞게 Dock 아이콘을 흰색 프레임으로 표시
     * 다크 모드: 스크롤바의 가시성을 높이고 모서리를 둥글게 처리하여 개선
     * 책 세부정보 옵션 추가 : 저자 검색 링크 숨기기 옵션 추가 및 컨텍스트 메뉴에서 표지를 다운로드할 수 있는 옵션 추가
     * 새로운 뉴스 소스: Linux Weekly News, Spectator, Economist 등 다양한 뉴스 소스 추가
     * Kobo 지원 강화 : KEPUB 형식 파일을 네이티브로 편집, 보기 및 변환 가능하며, Kobo 장치에 넣을때 Epub을 KEPub으로 자동 변환

   우와 이게 8버전까지 나왔군요.

        Hacker News 의견

     * 이 애플리케이션은 정말 마음에 듦. 인터페이스를 ""현대적""으로 만들려 하지 않고, 이상한 아이콘이나 큰 사각형을 사용하지 않음. 빠르게 시작하고 빠르게 작동하며, 구독을 구매하거나 어디에 등록하거나 서비스를 연결하라고 권장하지 않음. 완벽하게 제 역할을 함
          + 매년 이런 애플리케이션이 줄어들고 있지만, 여전히 SumatraPDF나 KeePassXC 같은 것들이 있음
     * Kobo 지원이 크게 개선됨. Calibre는 이제 KEPUB 형식 파일을 원활하게 편집, 보기, 변환할 수 있음. Kobo 장치로 책을 보낼 때 EPUB을 KEPUB으로 자동 변환함
          + 개선된 Kobo 지원을 보니 좋음
     * 이 앱을 정말 사랑함. 수백 권의 전자책과 PDF 책으로 구성된 디지털 라이브러리를 관리함. 개발자인 Kovid Goyal은 매우 응답이 빠름. 포럼에서 여러 번 연락했는데, 질문에 답하고 버그를 빠르게 수정함. 매주 업데이트를 출시하는 것 같음
          + Zotero와 Calibre는 디지털 책과 읽을 자료를 관리하는 데 가장 중요한 도구임
     * Calibre는 처음부터 사용해왔는데, 재미있는 점은 항상 업데이트가 있다는 것임. 거의 매일 하나씩 출시하는 것 같음
     * Kindle iOS 애플리케이션을 5-6년 동안 사용해왔지만, 지난달 Calibre를 통해 모든 Kindle 책을 아카이브하고 DRM을 제거하여 로컬에 저장함. Amazon 덕분에 더 빨리 이렇게 하게 됨
          + 하지만 오늘날 iOS에서 이 책들을 어떻게 소비하는지 궁금함. 간단하고 방해되지 않는 iOS 전자책 리더를 아직 찾지 못했음. 추천하는 사람 있음?
     * Calibre는 Docker 컨테이너에서 사용하는 것이 가장 좋음. 한 번 설정하고 나면 잊어버림
          + NAS의 디렉토리에 책을 넣고, Calibre가 그것들을 가져가도록 하고, Calibre-web로 실제 처리를 함
     * Calibre는 놀라운 프로그램이지만, 한 가지 큰 불만이 있음: 기본 설정에서는 메인 애플리케이션과 전자책 리더가 단순히 보기만 해도 원본 파일을 수정하려고 함 (현재 페이지를 저장하기 위해)
          + (자출판된) ePub이 이런 성가신 북마크 태그로 오염되는 것을 본 적이 있음. 그 결과 Calibre가 무작위 페이지에서 열리게 됨 (아마도 편집자나 저자가 출판하기 전에 닫은 페이지일 것임)
          + VLC가 모든 오디오나 비디오 파일에 현재 재생 위치를 저장한다고 상상해보라. iTunes도 사용자가 메타데이터를 적극적으로 편집하지 않는 한 그렇게 하지 않음. 원본 파일에 대해 그다지 배려하지 않았음
          + 반면에 Calibre는 라이브러리 관리자 보기에서 명시적으로 편집한 후에도 실제 메타데이터 업데이트를 ePub 파일에 자동으로 전파하지 않음 – 보통 사용자 의도가 명확한 곳임... (책 소스 편집기를 열고 닫을 때는 아무것도 건드리지 않아도 메타데이터를 매번 다시 씀. 기본 설정에서 저장할 때가 아니라 열 때마다!)
          + 가장 화가 나는 것은 이러한 결정들이 모두 일부 설정으로 무시될 수 있다는 것임 – 기본값이 내가 기대하는 것과 정반대라는 것만 빼면. (리더는 기본적으로 쓰기를 하지 않아야 함, 하지만 꼭 해야 한다면 메타데이터 편집기도 그래야 함)
     * 항상 UI에 대한 많은 불만이 있음. Calibre에 대해 항상 말하는 것은: Calibre를 <i>사랑</i>하고, 그 사용자 인터페이스를 <i>두 배로 사랑</i>함. 약간 신비롭지만 현대 UX의 헛소리가 없음
     * 저자가 여전히 자신의 종속성을 유지하는 것에 대해 이상한가? 이 프로그램을 사용한 지 오래됨
     * 여전히 자신의 디렉토리 구조를 명확히 사용할 수 없음
"
"https://news.hada.io/topic?id=19883","Retro Boy - Rust로 작성된 Game Boy 에뮬레이터, 웹에서 플레이 가능","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Retro Boy - Rust로 작성된 Game Boy 에뮬레이터, 웹에서 플레이 가능

     * 정확한 CPU/오디오 에뮬레이션으로 cycle-accurate한 게임보이 에뮬레이터
     * wasm-pack을 사용해 Rust 코드를 WebAssembly로 변환 → 웹에서 실행 가능
     * Web Audio API 및 HTML Canvas 사용하여 오디오 및 그래픽 처리
     * 로컬 스토리지 사용 → 배터리 지원 MBC 카트리지의 RAM 데이터 유지 가능

주요 특징

     * 정확한 CPU 에뮬레이션 → JSON CPU 테스트 통과
     * 정확한 오디오 에뮬레이션
     * 그래픽 에뮬레이션 → 스캔라인 기반 렌더러 사용
     * MBC1, MBC3, MBC5, HuC1 지원 → 다양한 카트리지 호환
     * RTC(Real Time Clock) 지원 → MBC3 카트리지에서 시간 기반 게임 작동 가능
     * 게임샤크(GameShark) 및 게임지니(GameGenie) 치트 코드 지원
     * 배터리 백업 카트리지는는 로컬 스토리지에 RAM 데이터 저장 가능
     * 웹 프론트엔드
          + React/TypeScript + Material UI
          + 전체 화면 모드 지원
          + 게임 일시정지 및 재개
          + 모노크롬 및 컬러 모드 선택 가능
          + 사용자 지정 키 매핑 지원
          + 치트 코드 활성화 및 관리 가능
          + 모바일 친화적 반응형 디자인

        Hacker News 의견

     * 이 프로젝트는 정말 멋있음. 오디오 에뮬레이션에 몇 가지 문제가 있지만, Gameboy 에뮬레이션에 대해 오랜만에 생각해 보았음. Rust와 WASM이 데스크톱 환경에 제한되었던 애플리케이션을 보여주는 데 큰 역할을 하고 있음
          + NES 에뮬레이터를 wasm-bindgen을 사용하여 비슷한 방식으로 구현했음
          + 홈브루 작업을 하고 링크를 공유하면 브라우저에서 바로 작동하는 것이 정말 멋있음
     * 최근 Aliexpress에서 £50에 레트로 게임 핸드헬드를 구매했음. Gameboy부터 SNES, PlayStation 1까지 플레이 가능하며, N64와 Dreamcast도 약간 가능함
          + 다양한 옵션이 있으며, 품질은 기대에 못 미칠 수 있지만, 여행 중에 Steam Deck을 구매할 수 없는 상황에서 매우 만족스러움
          + 다양한 커스텀 펌웨어와 앱을 설치할 수 있음
          + USB C 충전 문제를 주의하고, 작은 약한 충전기를 구매할 것을 권장함
     * Gameboy 개발에 관심 있는 사람들을 위한 링크와 지원 문서 목록
          + Gameboy Dev: 링크
          + PanDocs (기술 참조): 링크
          + Gameboy 기술 참조 문서 (gekkio): 링크
          + Game Boy Development Kit 2020 (GBDK-2020) 리부트: 링크
          + GBDK-2020 Github: 링크
          + GBDK-2020 예제: 링크
          + GBDK 쇼케이스 (홈브루 소프트웨어): 링크
          + 홈브루 허브: 링크
          + Neil Young 앨범 (Silver & Gold) Gameboy 카메라로 제작된 커버 이미지: 링크
     * GB/GBC/GBA는 VT102가 그리드 셀 소프트웨어에 해당하는 것과 같음. 데모 씬은 계속 발전하고 있으며, 칩튠은 하드웨어를 여전히 사랑하고 있음
          + GBA용 소프트웨어를 작성하는 것은 작은 현대 ARM 마이크로컨트롤러를 타겟팅하는 것과 비슷함
          + 다양한 에뮬레이터가 있으며, 각각 다른 측면에 집중하고 있음
          + 완벽한 에뮬레이션, 성능 최적화, 메모리 검사 및 치트 코드 제공 등 다양한 기능을 제공함
     * 에뮬레이터의 원작자로서, 이 작은 취미 프로젝트가 많은 관심을 받는 것에 놀랐음. 지원에 감사함
     * 7살 때 Kirby와 Final Fantasy Adventure를 아버지의 Windows 95 노트북에서 플레이하기 위해 no$gbemulator를 압축 해제하는 방법을 배웠던 기억이 남
     * Rust로 작성된 Game Boy 에뮬레이터를 더 많이 보는 것이 정말 좋음. 특히 브라우저 지원이 있는 프로젝트가 멋있음
          + afterplay.io라는 브라우저 기반 레트로 게임 플랫폼을 개발 중임
          + 다양한 시스템을 지원하며, 브라우저에서 완전히 실행되고 저장 상태, 클라우드 동기화, Capacitor를 통한 모바일 지원을 제공함
          + 네트플레이, 링크 케이블 지원, RTC 조작, 사용자 정의 가능한 터치 컨트롤 등 재미있는 기능도 있음
     * 웹 페이지를 Android 앱으로 추가할 수 있는 웹사이트를 처음 발견했음. 이를 무엇이라고 부르며, 웹 애플리케이션을 설치 가능한 앱으로 만드는 방법을 알고 싶음
     * Rust로 유사한 GB 에뮬레이터를 개발했음
          + 라이브러리: 링크
          + 웹/wasm 백엔드: 링크
     * 친구가 10년 전에 했던 유사한 프로젝트가 생각남: 링크
"
"https://news.hada.io/topic?id=19867","프론트엔드 트레드밀(러닝머신)","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            프론트엔드 트레드밀(러닝머신)

     * 많은 프론트엔드 팀이 프론트엔드를 새로 작성하면 성공할 것이라고 확신함
          + 하지만 프론트엔드 프레임워크 선택은 장기적인 제품 개발에서 가장 중요하지 않은 기술적 결정임
          + 프레임워크 선택에 시간을 낭비하는 것은 비효율적임
     * 프레임워크는 5년 안에 구식이 될 가능성이 높음
          + 프론트엔드 커뮤니티는 빠르게 변화하기 때문에 프레임워크는 자주 업데이트되거나 새 버전으로 대체됨

스마트한 프로덕트 팀의 접근 방식

     * 똑똑한 제품 팀은 프레임워크를 바꾸는 대신 현재 프레임워크에 대한 깊은 이해를 추구함
     * 프레임워크 변경은 함정임
     * 현재 사용하는 도구를 깊이 이해하고, 작업에 방해가 되지 않도록 하는 것이 중요함

구직 엔지니어를 위한 조언

     * 특정 프레임워크에 강한 선호가 있다면, 그것을 기준으로 일자리를 찾을 것
     * 기존 팀에 들어가서 프레임워크 변경을 설득하려 하지 말 것
          + 이는 팀에 큰 비용과 혼란을 초래함

프론트엔드 기술 비용을 줄이는 방법

     * 기본 웹 기술에 집중해야 함
     * 복잡한 추상화 계층을 줄이고, 웹 플랫폼의 기본 기능을 재학습해야 함
     * 이를 통해 장기적으로 더 나은 가치 제공 가능
          + 핵심 웹 기술에 가까운 상태를 유지하면 새로운 엔지니어를 쉽게 채용할 수 있음
          + 대규모 코드 리팩토링 없이도 생산성 유지 가능

엔지니어의 장기적인 경력 관리 전략

     * 핵심 웹 기술을 깊이 이해하면 장기적인 경력 가치가 높아짐
     * React 이전에도 있었고, React 이후에도 살아남을 수 있음
     * 최신 인기 기술을 배우는 데 집중하는 것보다 기본 기술을 익히는 것이 더 유리함
     * 기술 변화로 인해 해고될 가능성은 항상 존재함
          + 특정 기술에 의존하기보다 기본기를 강화하는 것이 더 안정적임

현업에서 솔직하게 말하기 어려운 이유

     * 관리직에 있을 때는 이런 솔직한 발언이 어려움
     * 동기가 의심받거나 팀의 반발을 살 수 있음
     * 20년 이상 경험에서 얻은 교훈이므로 현실적인 조언임

프론트엔드 생태계의 문제점

     * 현재 프론트엔드 생태계는 복잡함
     * 신입 개발자가 필요한 기술을 배우기가 어려움
          + 복잡한 툴 때문에 좌절하고 있음
          + 기본적인 개발자 채용도 어려워지고 있음
     * 현재 기술 생태계에서 배운 기술은 추상화가 너무 심함
          + 기술 변화 시 큰 불리함으로 작용할 수 있음

웹의 정체와 도구의 문제점

     * 웹의 정체는 도구의 복잡성이 원인
     * 개발자들이 창의적이고 멋진 것을 만들고 싶어 하지만 도구가 방해됨
     * 기본 웹 기술 학습이 비효율적이라는 인식이 문제임

개인적인 입장

     * 필자는 오랫동안 웹 개발에 열정적이었음
     * 웹은 여전히 강력하고 독특한 플랫폼임
     * 웹 플랫폼의 기본 도구는 매우 우수함
     * 하지만 현재의 프레임워크 계층은 웹 플랫폼의 본질에 역행하고 있음

        Hacker News 의견

     * 최근 FE 코드의 빌드 시스템을 yarn에서 pnpm으로 교체하는 작업을 하고 있음
          + 백엔드 엔지니어지만 JS 작업도 많이 해왔음
          + FE 작업을 하면서 가장 답답한 점은 거의 모든 것이 사용 중단된다는 것임
          + 예를 들어, 2022년에 apollo CLI를 사용했는데, 이제는 사용 중단되어 graphql-client를 배워야 함
          + 의존성을 패치 업그레이드하려고 하면 타입 시그니처에 의존하지 않기를 바라는 수밖에 없음
          + 결국 빌드가 완료되지만, 수백 개의 사용 중단 경고가 나옴
          + FE 개발은 변화와 사용 중단을 너무 쉽게 받아들이는 것 같음
          + Rust 프로젝트에서는 4년 동안 몇 번의 작은 변화만 있었음
          + JS에서는 6개월마다 무언가를 다시 작성해야 하는 것 같음
     * FE에서 20년 가까이 일해왔고 여러 패러다임 변화를 경험했음
          + 핵심 웹 기술을 아는 것이 더 다재다능한 엔지니어가 되는 데 도움이 된다고 생각함
          + 그러나 이것이 취업 시장에서 더 매력적으로 만드는지는 의문임
          + React에 매우 능숙해야 시장 가치를 극대화할 수 있음
     * 프론트엔드 개발자가 아니지만, React를 10년 동안 사용해왔음
          + Svelte로의 이동이 있지만, React가 여전히 강력함
          + 프론트엔드 개발은 빠르게 변하지만 그렇게 나쁘지는 않음
     * 프론트엔드 프레임워크를 사용하지 않는 것이 트레드밀에서 벗어나는 방법임
          + 서버 사이드 렌더링과 필요한 경우에만 JavaScript 사용
     * LLM이 더 두드러지면서 새로운 기술에 대한 관심이 줄어들 것임
          + Bevy와 Svelte에서의 경험을 통해 새로운 도구보다 기존 도구를 선호하게 될 것임
     * Vanilla JS와 CSS의 발전으로 서버에서 템플릿 HTML과 필요한 곳에서 JS를 사용하는 것이 더 의미가 있음
          + React와 같은 프레임워크가 여전히 강력하지만, 서버에서의 UI 상태 관리가 더 쉬움
     * 프론트엔드 문제가 아니라 큰 생태계의 문제임
          + Java에서도 비슷한 상황을 경험했음
          + 백엔드에서는 새로운 언어로의 전환이 더 큰 문제임
     * 웹 개발 초기에 Svelte와 React에 대한 이야기를 들었지만, MDN을 읽고 다른 것은 무시하는 것이 좋음
     * React를 10년 넘게 사용해왔고, 프레임워크가 5년 안에 구식이 된다는 주장에 동의하지 않음
     * 20년 넘게 웹 개발을 해왔고 CHAMP 스택에 만족함
          + CHAMP는 CSS, HTML, Apache, MySQL, PHP를 의미함
          + 프레임워크를 사용하지 않고 기존 기술을 고수한 것이 만족스러움
"
"https://news.hada.io/topic?id=19896","미국 특허청(USPTO) 새 메모, 특허 괴물과의 싸움 더욱 어렵게 만들어","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               미국 특허청(USPTO) 새 메모, 특허 괴물과의 싸움 더욱 어렵게 만들어

     * 미국 특허청(USPTO)이 잘못된 특허를 보호하는 결정을 내림
          + 2월 28일 발표된 메모에서 USPTO는 inter partes review(IPR)에 대한 접근을 더욱 제한함
          + IPR은 대중이 잘못된 특허를 도전할 수 있도록 만든 과정임

IPR은 특허청의 실수를 바로잡기 위해 존재함

     * USPTO는 매년 30만 개 이상의 특허를 발급하지만, 많은 특허가 잘못 발급됨
          + 특허 심사관은 평균적으로 특허당 약 20시간을 소비하며, 중요한 선행 기술을 놓치거나 지나치게 광범위하거나 모호한 특허를 발급함
          + 의회는 이 문제를 해결하기 위해 2012년에 IPR을 도입함
          + IPR은 특허의 유효성을 선행 기술에 기반하여 도전할 수 있게 하며, 특허청의 전문 판사들이 재평가함

USPTO는 특허 도전을 막고 있음

     * USPTO는 IPR을 방어하기보다는 방해하고 있음
          + 2월 28일 메모는 ""재량적 거부""의 광범위한 사용을 재도입함
          + Apple v. Fintiv 규칙에 따라, 동일한 특허에 대한 진행 중인 지방법원 사건이 있을 경우 IPR 청원을 거부함
          + 2022년 전 USPTO 국장 Kathi Vidal은 ""특허 불가의 설득력 있는 증거""가 있는 경우 PTAB가 특허 도전을 들어야 한다고 명확히 함

재량적 거부는 특허 트롤이 시스템을 조작하게 만듦

     * 이 결정의 주요 수혜자는 특허 트롤임
          + 특허 트롤은 특허 소송을 제기하기 위해 설립된 유령 회사임
          + IPR이 점점 불가능해지면서, 특허 트롤은 더 쉽게 합의를 이끌어낼 수 있음
          + 특허 소유자는 소송을 먼저 제기하면 재량적 거부가 IPR을 막을 것을 알고 있음

의회는 대중을 보호하기 위해 IPR을 만들었음

     * USPTO는 법을 다시 쓸 수 없음
          + 의회는 약한 특허가 착취적 소송의 무기가 되지 않도록 IPR을 통과시킴
          + USPTO는 2월 28일 메모를 즉시 철회해야 함
          + 그렇지 않으면 의회가 개입하여 문제를 해결해야 함
          + IPR은 잘못된 특허에 도전할 수 있는 빠르고 저렴한 방법으로 남아야 함

        Hacker News 의견

     * 2010-2020년대에 특허 괴물과 싸운 경험이 있음. 특허 괴물은 LLC로 구성되어 있으며, 구성원은 5명 정도로 2명의 변호사, 원래 특허 소유자, 그리고 몇몇 배우자들로 이루어져 있음. LLC의 유일한 자산은 특허였음. 스크롤바나 CSS 오버플로우 관련 특허였던 것 같음. 그들은 100만 달러를 요구하며 소송을 걸겠다는 요구/중지 서한을 보냈고, 2만 5천 달러로 해결할 수 있다는 변호사의 전형적인 전화가 있었음. 창립자의 '원칙' 때문에 약간 싸웠고, 발견 과정에서 그들이 보낸 동일한 요구 서한이 약 1,000개 있었음
     * 반격하면 법률 비용이 많이 들고, 이겨도 그 비용을 회수할 수 없음. LLC의 유일한 자산이 특허이기 때문임. 이런 상황이 후퇴하는 것처럼 느껴짐
     * 산업 관련 정책이 모든 이해관계자가 목표한 정책을 얻을 수 있는 청산소처럼 작동하고 있음. 철강 산업과 같은 특정 산업은 보호무역 조치를 받고 있지만, 혁신을 막는 소송자들 때문에 우선순위에서 밀려나고 있음. 이는 정책 주도 가격 상승이 발생하는 것과 유사함. 모든 로비를 곱하면 큰 그림에서 해석할 수 있는 전부임
     * 의회는 대중을 보호하기 위해 IPR을 만들었음. 이 행정부에게는 해결해야 할 문제임. 대기업이 이제 주인이며, 그들이 소기업을 밟고 나아가기 쉽게 만들어야 함
     * 왜 우리는 앞서가는 것이 가장 유리한 방법이 되는 시스템으로 계속 나아가는가?
     * 새로운 행정부가 USPTO의 리더십을 교체했는가?
     * IPR은 모든 특허를 약화시키는 도구임. 이 기사가 말하는 것처럼 IPR이 모든 사람의 비용으로 괴물을 돕는다는 것은 악의적인 주장임. IPR을 약화시키는 것은 모든 특허 소유자가 권리를 위해 싸울 수 있도록 돕는 것임. 기술 산업이 수많은 정당한 특허를 넘어섰다는 점을 고려하면, 이것이 합리적일 수도 있고 아닐 수도 있음
     * 특허가 없어야 한다고 생각한다면 그렇게 하라. 하지만 이것은 괴물뿐만 아니라 비괴물 특허 소유자에게도 도움이 됨
     * USPTO는 미국 특허 괴물 사무소인가?
     * 비괴물을 위한 특허 풀을 만들 때가 되었을지도 모름
     * [삭제됨]
     * 공증된 LLM 모델이 필요함. LLM에 타임스탬프를 찍고 공증된 데이터베이스에 저장해야 함. 특허 소송에 휘말리면 관련 LLM을 실행하고 간단한 용어로 괴물의 주장을 재현하도록 요청해야 함
"
"https://news.hada.io/topic?id=19869","OpenAI 오디오 모델","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             OpenAI 오디오 모델

     * 개발자가 OpenAI API의 새로운 텍스트-음성 변환 모델을 시도해 볼 수 있는 인터랙티브 데모
     * 프롬프트로 음성효과, 톤, 속도, 감정, 발음, 일시 정지 등을 상세히 지정 가능

데모

     * 목소리 선택: Alloy, Ash, Ballad, Coral, Echo 등 11가지
     * 다양한 Vibe 선택: Sincere, Friendly, Noir Detective, Robot, Auctioneer 등
     * 예: Sincere
Voice Affect: Calm, composed, and reassuring. Competent and in control, instilling trust.
Tone: Sincere, empathetic, with genuine concern for the customer and understanding of the situation.
Pacing: Slower during the apology to allow for clarity and processing. Faster when offering solutions to signal action and resolution.
Emotions: Calm reassurance, empathy, and gratitude.
Pronunciation: Clear, precise: Ensures clarity, especially with key details. Focus on key words like ""refund"" and ""patience.""
Pauses: Before and after the apology to give space for processing the apology.

     * 예: Medieval Knight
보이스 효과: 깊고 명령적이며 약간 드라마틱한 느낌, 고대 영어 이야기의 웅장함을 반영
톤: 고귀하고 영웅적이며 형식적, 중세 기사와 서사적 모험의 본질을 포착
감정: 흥분, 기대, 신비로움, 운명과 의무의 진지함 결합
발음: 명확하고 신중하며 약간 형식적인 리듬, ""hast"", ""thou"", ""doth"" 같은 단어는 고대 영어 발음 패턴을 반영하여 천천히 강조
멈춤: ""Lo!"", ""Hark!"" 같은 고대 영어 구문 뒤에 멈춤, ""Choose thy path"" 같은 절 사이에 멈춤을 두어 결정의 중요성을 강조하고 청자가 퀘스트의 진지함을 반영할 수 있도록 함

        Hacker News 의견

     * 이 모델들의 가격이 ElevenLabs보다 상당히 저렴함
          + ""gpt-4o-mini-tts"" 모델의 경우, 오디오 분당 $0.015로 ElevenLabs보다 85% 저렴함
          + ElevenLabs의 ""Business"" 플랜은 월 $1100에 11,000분의 TTS 제공, 분당 10센트 청구
          + OpenAI는 11,000분의 TTS를 $165에 제공 가능함
          + 계산이 맞는지 확인 요청
     * OpenAI의 Jeff가 새로운 오디오 모델을 출시했음을 알림
          + 두 개의 음성 인식 모델과 새로운 TTS 모델 출시
          + 텍스트 에이전트를 음성 에이전트로 쉽게 전환 가능하게 하는 Agents SDK 지원
          + 질문이 있으면 알려달라고 함
     * 텍스트-음성 변환 및 음성-텍스트 변환 모델의 신뢰성 문제 언급
          + 실세계 응용에 얼마나 문제가 될지 확신하지 못함
          + 관련 노트 작성 링크 제공
     * 생성된 오디오와 함께 ""speech marks""를 얻는 방법 문의
          + AWS의 Polly TTS 서비스에서 사용되는 ""speech marks"" 설명
          + 텍스트 강조 및 립싱크에 유용함
     * 최근 대형 텍스트-음성 및 음성-텍스트 모델의 발전
          + 오프라인, 다국어 텍스트-음성 솔루션의 필요성 언급
          + Tortoise TTS는 단어를 자주 왜곡한다고 생각함
          + Acapela SDK가 유일한 데스크탑 앱 플러그인 솔루션임
          + 새로운 신경망 기반 모델이 일반 컴퓨터에서 효율적으로 작동하길 바람
     * ""vibe"" 박스에 입력한 텍스트에 따라 다양한 억양과 성격을 구현할 수 있음
          + 지능적인 운율과 억양 수준이 놀라움
          + 오디오북 녹음에 유명인만 필요할 정도로 발전함
          + 다양한 재미있는 목소리 예시 제공
     * Navy Seal copypasta를 입력했을 때의 반응
          + 안전 제어가 ""vibe"" 지시에 따라 다르게 작동함
          + NYC 택시 운전사는 문제없이 작동하며 재미있음
     * 새로운 모델의 목소리에 미세한 진동이 있어 Siri보다 못하다고 느낌
     * OpenAI의 공식 도구가 새로운 모델 발표와 연결되어 있음
     * 공식 발표에서 중요한 인용문
          + 개발자가 모델에 무엇을 말할지뿐만 아니라 어떻게 말할지를 지시할 수 있음
          + ""vibes""가 UI에서의 지시사항임
          + 새로운 모델이 미세한 차이를 더 잘 수용함
          + gpt-4o-mini-tts 오디오 출력 비용이 분당 $0.015로 실용적임
          + 더 많은 테스트를 계획 중임

   한글도 완벽하게 동작하네요.
"
"https://news.hada.io/topic?id=19849","ICE에 의해 2주간 구금된 캐나다인","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ICE에 의해 2주간 구금된 캐나다인

나는 Ice에 의해 2주 동안 억류된 캐나다인임

     * 억류 경험: Jasmine Mooney는 미국에서 일하기 위해 승인된 비자를 가지고 있었음에도 불구하고, 미국 입국 시 갑작스럽게 Ice에 의해 억류되었음. 그녀는 변호사와 언론의 주목을 받았지만, 다른 사람들에 비해 운이 좋았다고 느꼈음.
     * 억류 과정: 그녀는 캘리포니아에서 일하며 캐나다와 미국을 오가던 중, 비자 문제로 인해 억류됨. 처음에는 샌디에이고 국경에서 비자 신청을 했고, 이후 비자가 취소되어 캐나다로 돌아가야 했음. 그러나 다시 비자를 신청하러 갔을 때, 아무 설명 없이 억류되었음.
     * 억류 시설에서의 생활: 그녀는 차가운 감옥에서 다른 여성들과 함께 생활했으며, 영어를 할 수 없는 사람들과 소통하기 어려웠음. 그녀는 음식에 대한 불신으로 단식을 했고, 결국 5년간의 입국 금지를 통보받음.
     * 다른 억류자들의 이야기: Mooney는 억류 시설에서 다양한 여성들을 만나 그들의 이야기를 들었음. 많은 여성들이 비자 만료 후 체류를 연장하려다 억류되었고, 그들 중 누구도 범죄 기록이 없었음. 억류된 여성들은 가족과 떨어져 지내며, 복잡한 절차와 불확실한 상황에 좌절했음.
     * 억류의 경제적 측면: 억류 시설은 민간 기업에 의해 운영되며, 억류자 수에 따라 정부로부터 자금을 받음. 이는 더 많은 억류자를 수용할수록 더 많은 수익을 얻는 구조로, 빠른 석방에 대한 동기가 부족함.
     * Mooney의 석방: 그녀는 언론의 주목을 받으며 결국 석방되었지만, 이 과정에서 시스템의 문제점을 깨달았음. 그녀는 억류된 여성들의 강인함과 사랑을 목격하며, 이러한 경험을 통해 인류애가 가장 어두운 곳에서도 빛날 수 있음을 믿게 되었음.

        Hacker News 의견

     * ""CoreCivic""와 ""GEO Group"" 같은 회사들은 구금된 사람 수에 따라 정부 자금을 받음. 그래서 더 엄격한 이민 정책을 위해 로비를 함. ""CoreCivic""은 한 해에 ""Ice"" 계약으로 5억 6천만 달러 이상을 벌었고, 2024년에는 ""GEO Group""이 7억 6천 3백만 달러 이상을 벌었음. 더 많은 구금자가 있을수록 더 많은 돈을 벌게 됨. 이런 회사들은 사람들을 빨리 풀어줄 이유가 없음. 내가 경험한 일이 드디어 이해되기 시작했음
     * 왜 이 글이 신고되었는지 궁금함. 이 글은 미국으로 스타트업을 위해 여행하는 기업가에 관한 것임. 이는 YCombinator 창립자들에게 직접적으로 관련이 있음. HN의 핵심 창립자들에게 직접적으로 관련이 있을 뿐만 아니라, 클릭베이트나 불필요하게 자극적인 내용이 아님. 댓글 활동과 투표를 보면 많은 사람들이 관심을 가지고 있음
     * 국경 수비대가 비자를 취소할 권한을 가지는 것이 무섭고 끔찍함. 이런 권한을 경찰이나 경비원에게 줄 때, 초등학교 때의 가장 멍청한 괴롭힘꾼을 떠올려야 함. 그들이 이 권력을 사용할 것임
     * 나는 12년 동안 매달 한 번씩 미국을 여행했음. 마지막으로 간 것은 10년 전임. 국경 수비대의 끔찍한 행동 외에는 문제가 없었음. 불법 차선 변경으로 경찰에게 한 번 멈춰졌지만, 내가 가족과 함께 온 관광객임을 알자 ""조심하고 좋은 여행 되세요""라고 말했음. 이제는 미국이 더 이상 좋은 여행지가 아닌 것 같아 다시는 가지 않을 생각임. 내가 틀렸을 수도 있지만, 그렇게 희망함
     * 이 사건의 구체적인 내용은 나에게 크게 중요하지 않음. 지금은 미국 국경을 넘는 것이 무서움. 앞으로도 어떤 이유로든 미국으로 여행하지 않을 것임. 캐나다는 안전하고, 자유를 위험에 빠뜨릴 만한 미국 내의 어떤 것도 없음. 여기 머물며 미국 여행을 피하고, 미국 상품이나 서비스에 돈을 쓰지 않을 것임
     * 실직 상태에서 미국에 있는 사람을 방문했다는 이유로 5년간 입국 금지를 받았음. 내 이민 변호사는 이것이 그가 본 가장 약한 사례라고 했음. 항소가 승인되기까지 2년이 걸렸음. 이전에 TN 비자로 두 번 미국에서 일했고, 체류 기간을 초과한 적이 없었음. 그들은 단지 할당량을 채우려는 것처럼 느껴졌음. 몇 년 전에 영주권을 신청했었고, 이 사건이 발생하기 전에는 승인되었지만 처리되지 않았음
     * 이 여성에게 이런 일이 일어난 것은 불공평하지만, CBP가 절대적인 권한을 가지고 있음. 국경을 넘는 것은 무서울 수 있음. 내 친구는 GC 결혼에 대한 농담 때문에 비자가 취소되고 10년간 입국 금지를 받았음. 감옥에 갇히지는 않았지만, 미국에 다시 입국할 수 없었고, 그녀의 물건을 팔아줄 사람을 찾아야 했음. 대부분의 사람들은 시민권자이기 때문에 국경에서의 현실을 모름. 다른 나라에서는 더 심함. 내가 아는 사람은 호주 출신인데, 비자 체류 기간을 초과하면 그들을 추적해 체포하고, 호주 본토 외부의 감옥에 보내 추방될 때까지 기다리게 함. 모든 나라는 국경을 매우 엄격하게 다룸. 수정: 친구에게 물어보니 틀렸음. 그들을 체포하지만, 해상 이민자들을 위한 외부 감옥으로 보내지는 않음
     * 국경에서의 어떤 불편함이 정상적이고 필요하다고 가정하는 사람들에게 이 사건이 화나게 하더라도 그렇지 않음을 상기시키고 싶음. 현재의 국제 여권, 거주 허가, 비자, 국경 검문 체제는 겨우 100년 된 것임. 내 생애 동안 (9/11 이전) 미국-캐나다 국경은 여권 없이 운전면허증만 보여주고 신고할 것이 없다고 말하면 됐음. 국제 국경이 디스토피아적인 ""서류 확인"" 자유가 없는 지역이 되어야 한다는 철칙은 없음. 미국이 육상 국경을 엄격히 관리할 필요는 없지만, NAFTA 시민들(캐나다인과 멕시코인)이 사업 목적으로 여행할 때 방해하는 것은 특히 어리석음. 북미에서의 쉥겐 스타일 체제는 이미 오래 전에 도입되었어야 했지만, 우리는 반대로 빠르게 나아가고 있음. 개방된 국경은 세계의 기본 상태임. 여행을 방해하는 것은 특정하고 실제적인 문제에 대한
       대응이어야 함. 대신, 우리는 소수의 경찰과 사설 계약자에게 국가의 열쇠를 넘겨주었고, 그들은 우리를 더 많이 괴롭힐수록 더 많은 돈을 받음
     * 이 이야기에서 얻은 교훈은 법과 규칙이 중요하지 않다는 것임. 현장에서의 공무원이 무능하고 무지하며 당신을 경멸할 때, 불필요한 잔인함과 적법 절차의 부족이 많음
     * 어떤 여성이 내 대신 연락할 사람의 이름을 물어봤음. 이런 순간에는 더 이상 누구의 전화번호도 기억하지 못한다는 것을 깨달음. 기적적으로 최근에 친구 브릿의 번호를 외웠음. 그녀의 계정에 내 식료품 포인트를 넣고 있었기 때문임. 이런 상황에서는 나도 곤란할 것임. 이제 형제의 번호를 기억할 때임
"
"https://news.hada.io/topic?id=19967","Crabtime - Zig의 Comptime을 Rust에서 사용합시다","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Crabtime - Zig의 Comptime을 Rust에서 사용합시다

     * 컴파일 타임에 인라인 Rust 로직을 평가하여 새로운 코드를 생성하여 추가해주는 매크로
     * Procedural 매크로보다 더 많은 유연성과 성능을 제공하는 동시에 macro_rules보다 읽고 쓰기가 더 쉽고 자연스러움
     * Token Stream/Macro Fragments/Rust 코드로 Input/Output 모두 지원
     * IDE 지원, 코드 포맷팅, 인라인 정의 가능하며 가독성이 뛰어남
     * 원샷-eval : 복잡한 컴파일 타임 연산을 간단하게 처리 가능
const MY_NUM: usize = crabtime::eval! {
    (std::f32::consts::PI.sqrt() * 10.0).round() as usize
};

     * 함수형 매크로 (Function-like Macros)
          + #[crabtime::function]으로 함수형 매크로 정의 가능
          + 정의된 함수는 매크로로 변환되어 빌드 시점에 실행됨
          + 표준 #[macro_export] 속성을 사용해 매크로 내보내기 가능
     * 매크로 정의된 함수는 임시 Rust 프로젝트의 main 함수로 삽입됨
     * 컴파일 후 생성된 코드를 stdout을 통해 반환

    해커뉴스 댓글들**

     * weinzierl
          + Crabtime의 로고를 칭찬함, Rust 매크로를 쉽게 만드는 시도
          + proc_macro가 별도 크레이트가 필요한 점이 불편했는데, Crabtime이 이를 해결하는 것처럼 보임
          + 다만 Crabtime은 Zig의 comptime과는 다르게, 단순한 컴파일 타임 평가 기능의 확장판처럼 보임
          + Zig와 Rust의 큰 차이는 타입 정보 접근 가능 여부로, Zig는 가능하지만 Rust는 불가능함
          + Rust에서는 타입 정보를 얻기 위해 RustDoc 파싱 같은 우회 방법을 사용하고 있음
          + Crabtime이 타입 리플렉션 기능을 제공하지 않는 것으로 보이며, 이 기능 없이는 진정한 comptime 구현이라 보기 어려움
          + pron
               o Zig의 comptime은 문법 매크로가 아니기 때문에 더 쉽게 이해하고 디버깅할 수 있음
               o 마치 런타임에 실행되는 함수처럼 동작하며, 강력한 리플렉션과 함께 부분적으로 타입을 가진 언어처럼 작동함
               o comptime 기능 하나만으로 다른 많은 언어 기능을 대체할 수 있어서, 언어 자체가 단순해짐
               o Zig는 C 수준의 단순성을 유지하면서도 C++ 수준의 표현력을 제공함
               o 복잡한 언어에 comptime을 추가하는 것은 Zig처럼 단순함의 이점을 얻기 어려움
     * pjmlp
          + C++의 메타프로그래밍 발전을 긍정적으로 평가함
          + C++98의 템플릿 해킹에서 시작해 C++23에서는 실용적인 수준으로 발전함
          + 향후 컴파일 타임 리플렉션이 도입되면 더 나아질 전망임
          + Rust는 매크로마다 문법이 다르거나, syn 같은 외부 크레이트에 의존해야 해서 배워야 할 게 많음
     * nindalf
          + 선언적 매크로로 작성했던 벤치마크 생성 코드를 Crabtime으로 재작성하여 만족스러운 경험을 함
          + Crabtime을 사용하면서 대부분의 코드를 Rust처럼 작성할 수 있어서 가독성과 커스터마이징이 향상됨
          + 예전에는 모듈명을 매번 전달해야 했지만, 이제는 디스크에서 파일을 읽어 처리할 수 있음
          + paste!{}와 crabtime::output!{}의 사용 비교에서 후자가 훨씬 직관적이라고 평가함
          + 반복문 문법도 복잡한 매크로 패턴 대신 Rust의 for 문법을 그대로 사용 가능함
          + Crabtime 덕분에 Rust 메타프로그래밍에 대해 더 자신감을 갖게 됨
          + 이전 버전은 몇 주 전에, 새로운 버전은 이틀 전에 발표되어 사용자 수는 많지 않음
          + 이전에 작성한 매크로를 자신도 잘 이해 못했으나, Crabtime으로는 명확하게 작성하고 유지할 수 있었음
     * orman784
          + 복잡한 매크로 작성이 필요한 상황에서 macro_rules만으로는 한계를 느껴 전체 코드를 직접 작성했다고 언급
          + proc_macro 사용은 피하고 싶지만, 대개 syn, quote, proc_macro2 같은 의존성을 추가해야 해서 불만족
          + Crabtime이 이를 해결해줄 수 있을지 테스트해보고 싶음
          + 의존성 추가가 얼마나 될지는 아직 확인하지 않았지만, 가능하면 줄이고 싶음
"
"https://news.hada.io/topic?id=19899","PyTorch Internals (2019)","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        PyTorch Internals (2019)

     * PyTorch의 내부 구조에 대한 설명으로, PyTorch의 C++ 코드베이스에 기여하고자 하는 사람들을 위한 안내서
     * 이 글의 목표는 PyTorch의 텐서 라이브러리 구조 및 자동 미분(autograd) 기법을 이해하고 코드베이스에서 길을 찾는 데 도움을 주는 것임

PyTorch 텐서의 기본 구조

     * PyTorch에서 텐서는 가장 기본적인 데이터 구조임
     * 텐서는 n차원 데이터 구조로, 부동 소수점(float), 정수(int) 등과 같은 스칼라 값 저장 가능
     * 텐서는 다음과 같은 메타데이터 포함:
          + 크기(size): 텐서의 차원 정보
          + dtype: 저장된 데이터 타입 (예: float32, int64 등)
          + device: 데이터가 저장된 위치 (CPU, CUDA 등)
          + stride: 데이터의 물리적 메모리에서의 오프셋 정보
     * Stride의 역할
          + stride는 논리적 인덱스를 물리적 메모리 위치로 변환하는 데 사용됨
          + stride는 각 차원에 대해 오프셋을 설정하고 인덱스에 stride 값을 곱해 물리적 메모리 위치 결정
          + stride를 통해 새로운 텐서를 생성하지 않고 view 형태로 같은 데이터를 다른 방식으로 볼 수 있음

텐서와 저장소(Storage) 개념

     * PyTorch에서는 텐서가 실제 데이터를 직접 보관하지 않음 → 저장소(Storage)에서 데이터를 관리함
     * Tensor = 크기 + dtype + device + stride + offset 정보
     * 여러 텐서가 하나의 저장소를 공유 가능 → 뷰(View) 개념 지원
     * 저장소와 텐서의 분리 덕분에 메모리 효율적으로 사용 가능

텐서 연산의 디스패치(Dispatch) 과정

     * PyTorch에서 연산은 두 단계의 디스패치를 거침:
         1. 디바이스 타입 및 레이아웃 기반 디스패치
               o CPU 텐서 vs. CUDA 텐서에 따라 서로 다른 구현 코드 실행
         2. dtype 기반 디스패치
               o float vs. int 등 데이터 타입에 따라 서로 다른 커널 호출

PyTorch 텐서 확장 모델

     * 텐서의 세 가지 주요 확장 요소:
          + Device: CPU, GPU, TPU 등에서 메모리 할당 방식 정의
          + Layout: 텐서가 메모리에 저장되는 방식 정의 (예: 연속적 저장, 희소(sparse) 저장 등)
          + dtype: 텐서의 각 요소에 저장될 데이터 유형 정의
     * 확장 옵션:
          + PyTorch 코드를 직접 수정해서 텐서 확장 가능
          + 기존 텐서를 감싸는 래퍼 클래스 작성 가능
          + 자동 미분 중에 래퍼가 필요하면 직접 확장 필요

자동 미분 (Autograd) 동작 원리

     * PyTorch는 **역전파(reverse-mode differentiation)**를 기반으로 자동 미분 수행
     * 순전파(forward) 연산 시 그래프 생성 → 역전파 시 그래프 탐색하며 미분 수행
     * Autograd는 다음과 같은 추가 정보를 관리:
          + AutogradMeta: 텐서에 연결된 메타데이터로 역전파에 사용됨
          + 연산 결과를 기록하고 역전파 시에 미분 수행

PyTorch 코드 구조 및 파일 위치

     * PyTorch 코드베이스에서 주요 디렉토리:
          + torch/ → Python 모듈 (Python 코드)
          + torch/csrc/ → Python과 C++ 바인딩 코드, 자동 미분 엔진, JIT 컴파일러 등
          + aten/ → 텐서 연산 정의 (핵심 연산 대부분 포함)
          + c10/ → 텐서 및 저장소와 같은 코어 구조체 정의

PyTorch 연산 실행 과정

     * 예제: torch.add() 호출 시 실행 과정:
         1. Python에서 C++ 코드로 인수 변환
         2. VariableType에서 디스패치 수행
         3. Device/레이아웃 기반 디스패치 수행
         4. 최종 커널 실행

커널 작성 과정 및 도구

     * PyTorch에서 커널은 다음과 같은 단계로 작성됨:
         1. 연산 메타데이터 작성: 함수 시그니처, 지원 디바이스 및 데이터 타입 정의
         2. 입력 검증: 차원, 타입 등 입력 검증 수행
         3. 출력 텐서 할당
         4. dtype 디스패치: 데이터 타입에 따라 커널 실행
         5. 병렬 처리: CPU에서는 OpenMP, CUDA에서는 내장 병렬화 사용
         6. 데이터 접근 및 계산: TensorAccessor, TensorIterator 등 사용

주요 디스패치 매크로

     * AT_DISPATCH_ALL_TYPES → dtype에 따른 디스패치 수행
     * 다양한 데이터 타입에 대해 매크로 지원 → 성능 최적화 가능

성능 최적화 및 작업 효율 향상 팁

     * 헤더 파일 수정 최소화 → 수정 시 전체 코드 리빌드 발생
     * 로컬 개발 환경 설정 → CI 사용 시 시간 소모 최소화
     * ccache 사용 → 재컴파일 시간 절약 가능
     * 강력한 서버 사용 → C++ 컴파일 및 CUDA 빌드 시 시간 단축 가능

PyTorch 기여 가이드

     * 시작하기 좋은 기여 대상:
          + triaged 라벨이 달린 이슈 → PyTorch 개발자가 확인 완료한 이슈
          + 문서 개선 및 버그 재현 도움
          + PyTorch의 RFC(기능 제안)에 대한 의견 제시
     * PyTorch는 오픈 소스 기여자를 통해 성장해 왔으며, 커뮤니티 참여 환영
"
"https://news.hada.io/topic?id=19954","Show GN: DirectShare - 기기의 파일, 폴더들을 드래그 한번으로 공유하는 도구","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Show GN: DirectShare - 기기의 파일, 폴더들을 드래그 한번으로 공유하는 도구

   가끔 기기의 여러 파일들을 공유해야할 때 클라우드 서비스를 사용하면 업로드로 인해 시간이 많이 걸릴때가 있습니다. 이에 따라 드래그 한번으로 직접 파일 공유용 서버를 열어주는 간단한 프로그램을 만들었습니다.

  기능

     * 자동 uPnP 포트포워딩
     * 파일별 단축 URL 생성
     * 포트, 단축 URL 길이 설정 가능
     * 폴더 공유시 자동 tar 아카이브화

  사용법

   공유 할 파일들을 프로그램에 드래그하면 프로그램이 실행 되고 서버가 열립니다.
   프로그램의 로그에 생성된 단축 url로 접속하면 해당 파일을 다운로드 할 수 있습니다.
   폴더의 경우 tar 파일로 다운로드됩니다.

   예를 들어
registered foo.txt url: http://127.0.0.1:1024/xIqfLguw

   http://127.0.0.1:1024/xIqfLguw 가 foo.txt 파일을 받을수 있는 주소 입니다.

   프로그램이 위치한 폴더에 생기는 direct_share.toml 파일에서 단축 url의 주소 길이와 포트 번호를 설정 할 수 있습니다.

   UPnP 라는게 있군요
"
"https://news.hada.io/topic?id=19879","macOS에서 비밀번호 유출 및 기타 문제","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        macOS에서 비밀번호 유출 및 기타 문제

비밀번호 유출 (그리고 더 많은 것들!) macOS에서

  소개

   이 글은 Apple의 보안 업데이트에 포함된 취약점 CVE-2024-54471에 대해 설명함. 이 취약점은 macOS Sequoia 15.1, macOS Sonoma 14.7.1, macOS Ventura 13.7.1에서 패치되었음. macOS 기기를 사용하는 경우, 최신 버전으로 업데이트할 것을 권장함.

  커널이란 무엇인가?

   운영 체제에서 하드웨어와 통신하고 멀티태스킹 모델을 애플리케이션에 제공하는 코드를 커널이라고 함. macOS의 커널은 XNU로, BSD 커널과 Mach 커널의 변형을 포함하는 하이브리드 커널임.

  Mach의 역사

   Mach 커널은 1980년대와 90년대의 유닉스 전쟁과 깊이 얽혀 있음. Mach는 카네기 멜론 대학교에서 운영 체제 연구 프로젝트로 시작되었으며, NeXTSTEP 운영 체제에 사용되었고, 이는 결국 macOS의 기초가 되었음.

  왜 Mach인가?

   Mach는 유닉스 시스템 설계 및 사용의 복잡성을 줄이기 위해 개발되었음. Mach는 네 가지 기본 추상화로 구성되어 있으며, 이는 현대 macOS에서도 여전히 사용되고 있음.

  Mach의 아키텍처

    네 가지 추상화

     * 태스크: 스레드가 실행될 수 있는 환경으로, 리소스 할당의 기본 단위임.
     * 스레드: CPU 활용의 기본 단위로, 태스크 내에서 독립적인 프로그램 카운터로 작동함.
     * 포트: 메시지를 위한 커뮤니케이션 채널로, 커널에 의해 보호됨.
     * 메시지: 스레드 간 통신에 사용되는 데이터 객체의 집합임.

    태스크, 포트, 포트 권한

   포트는 커널 공간에만 존재하며, 사용자 공간에는 포트 권한으로 노출됨. 여러 태스크가 포트에 대한 전송 권한을 가질 수 있지만, 수신 권한은 하나의 태스크만 가질 수 있음.

    메시지의 구조

   각 Mach 메시지는 헤더, 선택적 설명자, 임의의 페이로드, 커널이 추가한 트레일러로 구성됨.

    전송 권한 획득 방법

   macOS에는 부트스트랩 서버가 있으며, 이는 모든 태스크가 전송 권한을 가진 포트의 수신 권한을 보유함. 클라이언트는 부트스트랩 서버에 특정 이름의 Mach 서비스에 대한 전송 권한을 요청할 수 있음.

  Mach 인터페이스 생성기 (MIG)

    소개

   MIG는 Mach 메시지 전송 및 수신을 위한 기능적 인터페이스를 생성하는 도구임. 이는 메시지 기반의 RPC 스타일 인터페이스를 제공하여 메모리 안전성을 높임.

    기술적 세부사항

   MIG는 Mach 메시지의 래퍼로, 각 함수는 루틴으로 불리며, 루틴의 집합은 서브시스템으로 불림. 서브시스템은 메시지 ID 필드에 인덱스됨.

  MIG 서버의 취약점

    MIG 서버의 보안

   MIG 서버는 메시지 발신자를 검증하지 않으면, 전송 권한을 가진 태스크가 서버의 루틴을 호출할 수 있음.

    MIG 서버 찾기

   ipsw CLI 도구를 사용하여 NDR_record 심볼을 사용하는 바이너리를 검색할 수 있음. 이는 MIG 서버와 클라이언트를 찾는 데 유용함.

  NetAuthAgent의 취약점

    NetAuthAgent 소개

   NetAuthAgent는 macOS에서 파일 서버의 자격 증명을 처리하는 데몬임. 이 취약점이 패치되기 전에는 서버의 자격 증명을 요청하면 제공했음.

    NetAuthAgent의 작동 방식

   NetAuthAgent는 macOS 키체인을 사용하여 자격 증명을 저장함. 키체인은 중앙 집중식 비밀 관리자이며, 각 항목은 자체 접근 제어 목록을 가짐.

    NetAuthAgent의 MIG 서버

   NetAuthAgent는 com.apple.netauth.user.gui라는 이름으로 부트스트랩 서버에 등록된 MIG 서버를 노출함. 이 서버는 자격 증명을 읽고 생성하며 덮어쓸 수 있는 루틴을 제공함.

  취약점의 영향

    iCloud API 토큰 노출

   이 취약점은 iCloud API 토큰을 노출시켜, 공격자가 사용자 정보를 유출하거나 다른 장치의 위치를 추적할 수 있게 함.

  Apple이 해야 했던 것

   이 글은 Apple이 이 취약점을 해결하기 위해 어떤 조치를 취했어야 했는지에 대한 논의를 포함함.

        Hacker News 의견

     * 잘 작성된 글임. Apple이 어느 정도 숨기려 했던 제로 데이 사건이 떠오름. ""빈 비밀번호를 두 번 시도""하여 root 로그인 우회가 가능했던 사건이었음. 이 사건은 2017년 또는 2018년경이었음
          + 관리자 사용자 이름을 입력하고 빈 비밀번호로 로그인 시도 시, 처음에는 비밀번호가 틀렸다는 경고가 나옴. 경고를 무시하고 두 번째로 로그인 버튼을 누르면 해당 사용자로 로그인됨
          + 이 문제는 소셜 미디어에 퍼진 후 곧 패치되었음. 여전히 큰 실수처럼 보임
          + Mac의 인증 메커니즘에 아직도 문제가 있는 것 같음. 포트 시스템이 언급된 것이 흥미로움. Mach 커널의 잘 알려지지 않은 사실임
     * ""ACLs don’t"": <a href=""https://waterken.sourceforge.net/aclsdont/current.pdf"" rel=""nofollow"">https://waterken.sourceforge.net/aclsdont/current.pdf</a>;
     * 프로세스가 다른 프로세스에 키체인 쿼리를 프록시할 수 있는 메커니즘을 노출하면 시스템 전체의 보안을 약화시킬 수 있음
          + 이는 혼란스러운 대리인 문제의 사례로 보임: <a href=""https://en.wikipedia.org/wiki/Confused_deputy_problem"" rel=""nofollow"">https://en.wikipedia.org/wiki/Confused_deputy_problem</a>;
          + 능력 기반 설계가 이러한 문제를 체계적으로 방지할 수 있어야 함
     * 기사에 사소한 수정이 있었음
          + 권한 확인은 커널의 Mach 레이어에 있지 않음
          + <a href=""https://github.com/nmggithub/wts/commit/2bdce1c0c76c7adc360e17a6a42ee547462b99d3"" rel=""nofollow"">https://github.com/nmggithub/wts/…;
          + XNU 작동 방식에 대한 사실 오류를 수정하기 위한 한 단어 변경이었음
     * 8시간이 걸렸지만 이 게시물은 이제 더 이상 첫 페이지 상위 5위가 아님 (현재 #27임, 여전히 첫 페이지에 있지만 하단임). 모든 댓글에 감사함
     * 작성자가 실제 PoC 코드를 제공하는지 궁금함. 완화 조치를 테스트하고 싶음. 예제 코드를 보았지만 불완전해 보임
          + 현실적으로 어떤 위험이 있는지 궁금함
     * 매우 흥미로운 기사임. Mach와 Darwin 커널의 제작에 이렇게 많은 이야기가 있는 줄 몰랐음
     * 현재 Mach는 macOS에서 버그의 신뢰할 수 있는 출처처럼 느껴짐. Apple이 이를 모두 잠그기 위해 열심히 노력하고 있는 것을 알고 있지만, Mach에서 완전히 벗어날 수 있는 경로가 있는지 궁금함
     * [dead]
"
"https://news.hada.io/topic?id=19975","자신을 팔고, 작업을 팔기","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             자신을 팔고, 작업을 팔기

     * 기술적으로 훌륭한 작업을 혼자서 만족하며 해냈다고 해도, 다른 사람에게 알리지 않으면 아무 의미가 없음
     * 아무도 당신의 작업을 모르게 되면, 그로 인한 이득도 없고 결국 그 작업은 사라져버림
     * 세상이 당신의 작업으로부터 이득을 얻기 위해서는, 반드시 그것을 널리 알려야 함
     * 결국 자신과 자신의 작업을 ""광고""해야 함

대부분의 뛰어난 기술자들이 놓치는 부분

     * 뛰어난 기술자들 중 많은 사람들이 작업 내용을 문서화하거나 전달하지 않음
     * 이유는 보고서 작성이 지루하고, 어렵고, 무의미하다고 느끼기 때문임
     * 그러나 아무리 훌륭한 소프트웨어를 만들었거나, 복잡한 문제를 해결했더라도, 알리지 않으면 그 작업은 무용지물임
     * 사람들이 알아줄 수 있도록 글을 써야 하고, 관심을 끌 수 있도록 표현해야 함

전달 방식이 중요한 이유

     * 화려한 효과나 애니메이션은 꼭 필요하지 않지만, 깔끔하게 정리된 프레젠테이션은 필요함
     * 맞춤법이나 문법 오류는 의미 전달에 큰 지장을 주지 않지만, 청중의 관심을 잃을 수 있음
     * 목적이 모호한 글은 독자가 핵심을 이해하기 어렵게 만듦
     * 명확하고 간결하게 작성된 글은 타인의 시간과 노력을 절약시키고, 당신의 명성을 높이는 수단이 될 수 있음

왜 기술자도 글을 써야 하는가

     * 기술자가 글쓰기 능력을 타고나지 않았다는 이유로 글쓰기를 피하면, 세상은 그들의 뛰어난 작업을 접할 수 없음
     * 결국 세상이 당신의 아이디어를 접할 수 없다면, 그것은 존재하지 않는 것이나 다름없음

창업자 또는 기업가에게는 다른 방식의 표현 수단이 존재함

     * 창업자는 자신의 작업의 결과를 직접 고객을 통해 증명할 수 있음
     * 고객이 없다면, 당신의 회사는 존재 이유가 사라짐
     * 고객이 있다면, 당신의 작업이 그만큼 가치를 인정받고 있다는 의미임
     * 하지만 여기에서도 여전히 중요한 것은 판매(Sell) 임

결국, 무엇이든 ""판매""해야 함

     * 회사의 생존은 결국 제품이나 서비스가 팔리느냐에 달려 있음
     * 세상의 다양한 기업 목적이 있을 수 있지만, 수익이 없다면 모든 목적은 무의미함
     * 여기서 말하는 ""판매""는 단순한 물건 판매 그 이상을 의미함

Richard W. Hamming이 말하는 작업의 전달과 설득의 중요성

     * ""You and Your Research""라는 강연에서, Hamming은 작업을 세상에 알리는 것이 얼마나 중요한지를 강조함
     * 단지 좋은 연구를 했다는 사실만으로는 부족하며, 그 가치를 다른 사람에게 전달하는 것이 필수적임
     * 당신의 작업은 다음 사람이 그 위에 쌓아갈 수 있는 방식으로 이루어져야 함
          + 반대로 전달이 잘 안 된 경우, 다음 사람이 당신의 작업을 처음부터 다시 해야만 하는 상황이 생김
          + 이는 연구와 개발 자원의 낭비를 초래함
     * 작업을 해냈다는 사실만으로는 충분하지 않음, 반드시 그 가치를 ""판매""해야 함
          + 과학자나 기술자에게 ""판매""라는 개념은 불편하고 어색하게 느껴질 수 있음
          + 이상적으로는 훌륭한 결과를 내면 세상이 알아봐야겠지만, 현실은 그렇지 않음
     * 모두가 바쁘기 때문에, 당신의 작업이 그들의 관심을 끌 수 있도록 잘 표현해야 함
          + 사람들은 수많은 글 중 일부만 읽음
          + 그렇기 때문에 당신의 보고서나 글은 독자가 페이지를 넘기다 멈춰서 읽을 만큼 매력적이어야 함
     * 사람들이 읽지 않으면, 아무리 훌륭한 내용도 인정받지 못하고 묻히게 됨
     * 읽히기 위해 갖춰야 할 역량
          + 명확하고 좋은 글쓰기 능력을 익혀야 함
          + 격식을 갖춘 발표를 잘 하는 법도 익혀야 함
          + 더불어, 비공식적인 자리에서의 설명도 잘 할 수 있어야 함

   공감..!

   이 글에서 주장한 것처럼 ""문서화""하는 능력은 정말 중요합니다.
   스스로의 강점을 어필하고 성과를 주장하는데 쓰일 뿐 아니라, 업무를 편하게 하고, 다른 사람에게 지시하는데도 도움이 됩니다.

   처음부터 근사한 자료, 문서를 작성할 필요는 없습니다. 단순하더라도 정리해서 문서를 작성하는 버릇을 들이는 게 중요합니다.
   저도 머리로는 알지만 잘 실천 하지는 못하고 있네요... 정말 어려운 주제입니다.

   개발 업무를 하다가, 잠시 몇년동안 기획 업무를 해본 적이 있었는데 본문의 ""판매(Sell)"" 해야 한다는 메시지가 참 와닿네요.
   아무리 열심히 준비하고 기획한 제품이라 하더라도, 주변 동료분들에게 효과적으로 설득하고 판매하지 못하면 지지를 얻을 수 없고
   결국 과제가 원할하게 앞으로 나아갈 수 없게 됩니다.

   생각한 아이디어가 있다면 그걸 주변 사람들에게 효과적으로 알려서 지지를 얻는 등의 활동도 필수적이라는 교훈을 얻었습니다.

        Hacker News 의견

     * 개인적인 규칙으로 프로젝트를 할 때마다 그에 대해 글을 쓰는 것이 있음
          + 과거에는 Twitter 스레드를 사용했으나, 현재는 블로그를 사용 중임
          + GitHub 저장소가 있는 프로젝트는 README에 설명과 스크린샷을 추가하면 됨
          + 스크린샷은 프로젝트의 보존에 중요함
          + 과거에 문서화하지 않은 프로젝트를 후회하고 있음
     * ""완전히""라는 표현이 금전적 이익을 의미하는 것 같음
          + 자신의 작업을 알리지 않으면 아무도 알지 못함
          + 작업이 판매되어야만 가치가 있는 것은 아님
          + 인간의 노력은 금전적 가치 이상을 가짐
     * 이 글에는 많은 진실이 있음
          + 대형 FAANG 회사에서 일하며 개인 작업을 공개하지 않은 것이 실수였음
          + 개인 작업을 공개하지 않으면 자신의 정체성과 권력을 잃게 됨
          + 권력은 대화적이며, 자신을 주장하지 않으면 권력을 잃게 됨
     * 기술적으로 뛰어난 작업이 개인적 만족에는 충분할 수 있지만, 그것만으로는 충분하지 않음
          + ""충분하다""는 판단의 문제임
          + 작업이 알려지지 않으면 아무도 이익을 얻지 못하고 작업은 사라짐
          + 작업은 경험과 능력에 기여함
     * 다른 사람이 자신에게 무엇을 해야 만족할지 지시하게 두지 말아야 함
          + 공유하고 싶으면 공유하고, 그렇지 않으면 자신만의 것으로 남겨야 함
     * 글쓰기 규칙:
          + 설명하고 ""판매""하지 않음
          + 설명하고 ""설득""하지 않음
          + 명확성과 간결함을 중시함
          + 주요 포인트를 앞에 제시함
     * 젊은 프로그래머에게 조언:
          + 자신의 수단 내에서 생활하고, 차액을 투자하며 독립적으로 즐기는 일을 하도록 함
     * ""판매""의 정의는 다양함
          + 친구와 가족을 위한 기술 제품/서비스를 만드는 데서 만족을 찾음
          + 창의적 연습으로 즐기며, 직장에서 사용하지 않는 기술을 통합하고 결합할 기회를 줌
     * Albert Jay Nock의 에세이 ""Isiah’s job""을 상기함
          + 대중에게 작업을 알리는 것은 중요하지만, 시간이 지나도 견디는 작업은 홍보가 필요 없음
     * 작업을 알리는 것이 반드시 작업의 완전한 이익을 의미하지 않음
          + 개인적인 호기심과 교육을 위해 프로그램을 작성하며, 이를 공개할 필요는 없음
"
"https://news.hada.io/topic?id=19884","IETF 127 보이콧 운동","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            IETF 127 보이콧 운동

IETF 127 보이콧

     * IETF 127 회의가 미국에서 열리는 것에 대한 반대 의견이 제기됨. 이는 미국의 여행 안전 문제와 관련이 있음.
     * 미국은 많은 사람들에게 이미 안전하지 않은 국가였으며, 현재는 거의 모든 여행자에게 적대적인 상태임.
     * 여러 사례가 있으며, 국경에서 억류되거나 비인간적인 조건에서 구금된 사람들이 있음. 예를 들어, 프랑스 과학자가 트럼프 행정부에 비판적인 견해를 가졌다는 이유로 추방됨.
     * IETF의 핵심 가치는 포용성임. 따라서 인종, 민족, 종교, 성별, 성적 지향, 국적, 시민권, 성 정체성에 따라 사람들을 배제하는 법률이 있는 국가에서 회의를 개최하는 것을 피해야 함.
     * RFC 8718 및 RFC 9137은 회의 장소 선택 및 취소/이전 조건을 설정함. 전쟁, 시민 불안, 공중 보건 위기 등이 회의 취소를 촉발할 수 있음.
     * 많은 사람들이 IETF 127 회의에 참석하지 않겠다는 의사를 밝히고 있으며, 이는 연대의 표시임.
     * 서명 양식을 통해 익명으로도 보이콧에 대한 지지를 표명할 수 있음.

        Hacker News 의견

     * 우리 회사는 전 세계적으로 사용되는 틈새 소프트웨어를 제작함. 북미 지역 고객을 위해 미국에서 컨퍼런스를 계획했으나, 미국의 상황을 고려하여 취소할 가능성이 높음. 멕시코와 캐나다 고객들이 편안하게 느끼지 못할 것이며, 유럽 본사에서도 마찬가지임. 대신 유럽에서 개최할 가능성이 높음
     * 20년 동안 IETF에 간헐적으로 참석해 왔음. 최근 몇 달간 미국의 상황이 충분히 불쾌했지만, 내 나라가 이런 식으로 묘사되는 것을 보게 될 줄은 몰랐음. 더욱 깊은 슬픔과 수치심, 공포를 느낌
     * RISC-V도 얼마 전 스위스로 이전함. 이런 일이 발생하는 것은 안타까운 일임. 현재 환경에서 표준 기구가 다른 나라로 이동하거나 이벤트를 이동시키고 싶어하는 것은 좋지 않음
     * 2013년과 2017년의 사례가 생각남. 이는 전혀 새로운 것이 아니며, 단지 더 많은 사람들, 특히 서구 사람들이 영향을 받고 있음
          + 외국 참석자들이 미국에서 열리는 컨퍼런스에 참석할 수 없는 것이 새로운 것이 아님. 포용성을 중시한다면, 미국에서 국제 컨퍼런스를 개최하는 것은 오랫동안 나쁜 생각이었음
     * 고맙음. 나는 미국에 있으며 이러한 조치들로 위협받고 있음. IETF의 회원은 아니지만 그들의 작업에 크게 의존하고 있으며, 연대는 의미가 있음
     * @dang 왜 이 글이 플래그 되었는지 궁금함. 정치적인 요소를 제외하더라도, 많은 사람들이 참석하지 않을 것이라는 정보는 중요함
     * 유럽 국가들이 비이진 시민들에게 미국 여행 위험에 대해 공식적으로 조언하기 시작함
     * 이 웹사이트는 미국에서의 기본 자유와 권리의 침식과 같은 매우 현실적이고 큰 문제를 일부 환상적인 문제와 혼합하고 있음. 개인적으로 과장된 표현은 실제 문제를 가볍게 만드는 역할을 한다고 생각함
     * 이것이 패러디인지 궁금함
          + 국경에서의 문제 외에도, 현재 보건복지부 장관인 Robert F. Kennedy Jr.가 ADHD 환자들을 캠프로 보낼 것이라고 말했음. 출처: Futurism
          + 실제로 그가 말한 것은 ""나는 이 수익을 전국의 농촌 지역에 있는 약물 재활 농장을 만드는 데 사용할 것임. 약물 범죄로 유죄 판결을 받거나 약물 문제가 있는 사람들은 무료로 이러한 장소에 갈 수 있게 할 것임""이라는 것임
          + Futurism을 출처로 사용할 때 발생하는 일임
     * 왜 이 글이 플래그 되었는지 궁금함. 물론 정치적인 문제이지만, 주요 인터넷 표준 개발 기구 중 하나에 대한 심각한 문제임. ""좋은 해커""들에게는 확실히 관련이 있음
"
"https://news.hada.io/topic?id=19911","엔지니어로서, 나는 침묵을 지키는 것보다 멍청하다고 불리는 게 낫다","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 엔지니어로서, 나는 침묵을 지키는 것보다 멍청하다고 불리는 게 낫다

     * 바보가 되는 것보다 침묵하는 것이 더 나쁜 이유

     ""제 자신을 드러내고 어리석은 질문을 던지는 게 실제로 제 엔지니어 경력에 도움이 됐습니다.""

바보처럼 보일까 봐 두려운가요? 당신만 그런 게 아님

     * 사고 관리 채널에서 문제가 발생했을 때, 개발자들이 즉각적으로 대응해 문제를 해결하려 함
     * 기술적인 용어가 오가며 상황이 복잡해짐
     * ""포톤 페이저가 플럭스 커패시터 문제로 작동하지 않음"" 같은 말을 들으면 이해가 안 되는데, 질문하기 두려움
     * 질문하면 바보처럼 보일까 봐 두려운 상황은 흔함

모르는 게 당연함을 깨닫기까지

     * 고객 지원 엔지니어로 일하기 시작하면서, 플랫폼과 제품 구조에 대한 기본 이해 필요
     * 문제 해결 능력은 발전했지만 플랫폼의 기술적 구조에 대한 이해 부족
     * 복잡한 문제에서 항상 부족함을 느낌

정말 내가 바보일까?

     * 문제를 해결하기 위해 질문하기로 결심
     * 온라인 강의나 자료도 많지만, 핵심은 실제 개발자들에게 직접 질문하기
     * 무지함을 인정하고 질문함으로써 배움의 기회 마련

바보인 척 하기를 자랑스럽게 여기기

     * 일상적으로 개발자와 상호작용하며 문제 해결
     * 두려움을 버리고 바보 같은 질문하기 시작
     * 처음에는 어색했지만, 대부분의 경우 사람들은 기꺼이 답해줌
     * 질문을 통해 복잡한 개념을 이해하게 됨

이해하기 시작하면서 변화 발생

     * ""이게 무슨 뜻인가요?"" 같은 기본적인 질문을 통해 복잡한 기술 개념 이해
     * 데이터 센터의 개념과 인프라 구조를 명확히 파악
     * 포톤 페이저 → 가상 머신(VM), 플럭스 커패시터 → 호스트 같은 실제 개념으로 변환 가능해짐

질문하지 않으면 발생하는 문제

     * 질문하지 않으면 문제 해결 지연 → 고객에게 부정적 영향
     * 문제 해결을 위한 기본 개념조차 이해하지 못한 채 방치될 위험
     * 회의에서도 이해하지 못하면서 모두가 침묵할 경우, 문제 해결이 지연됨
     * 질문하면 문제 해결이 더 빠르고 명확해짐

질문하는 문화를 만들기 위한 방법

     * ""바보 같은 질문""을 하는 사람이 되기
          + 질문이 자연스러워지면 다른 사람들도 쉽게 질문함
     * 비난이 아닌 교육으로 전환하기
          + 실수를 비난하기보다 이를 통해 배울 기회로 삼기
     * 동료에 대한 신뢰 쌓기
          + 바보처럼 보일까 봐 두려워하지 않고 서로를 신뢰하며 질문하기

질문이 경력 성장으로 이어짐

     * 질문을 통해 배운 지식과 경험이 커리어 전환의 기반이 됨
     * 신뢰성과 기술력 모두 강화됨
     * 질문하는 습관이 조직의 문제 해결력과 지식 공유 문화로 이어짐

바보처럼 보이기를 두려워하지 말 것

     * 모른다는 것은 자연스러운 일
     * 질문을 통해 배운 지식은 자신감으로 이어짐
     * 질문은 문제를 방지하고 성장을 돕는 핵심 도구
     * ""진심 어린 질문은 결코 바보 같은 질문이 아님""
          + 다음에 포톤 페이저 같은 문제가 발생하면 질문할 것인가, 아니면 침묵할 것인가?

   몰라서 질문하는 것만으로 해결되는 문제가 생각보다 많았어요

   예전에 썼던 글이 생각나네요.

   “질문하고 부탁할 때 저평가, 거절, 민폐의 두려움 이겨내기“
   https://news.hada.io/topic?id=8574

   개인도 두려워하지 않아야겠지만 조직도 바보같은(?) 질문을 장려하여야 한다고 봅니다.

   요즘에는 AI가 저의 바보같은 질문 상당수를 받아주고 있어서 다행입니다. 휴우~.

   엔지니어링에서 정말 중요한 덕목입니다.

        Hacker News 의견

     * '어리석은' 질문을 한다고 해고되지 않음
          + 카리스마에 따라 다름
          + 질문이 업무에 대한 신뢰를 떨어뜨리면 문제가 생김
          + 이는 기업 정치의 기본임
     * 진정으로 훈련된 관리층이 필요함
          + 제3자의 의견에 대해 부정적으로 언급하지 않음
          + 취약성을 해칠 수 있는 실수는 즉시 수정함
     * ""질문하는 사람은 잠시 바보가 되지만, 질문하지 않는 사람은 평생 바보가 됨""이라는 말이 있음
     * 팀에게 ""어리석은 아이디어가 좋은 아이디어의 씨앗이 될 수 있음""이라고 말하는 것을 좋아함
     * 어리석은 질문이 가장 중요함
          + 이는 깊은 무언가가 부족하거나, 흐릿하거나, 의심스럽거나, 잘못되었음을 의미함
          + 똑똑한 질문은 보통 표면에 있음
          + 깊이가 괜찮다고 '가정'함
     * 좋은 조언임
          + 좋은 규칙 중 하나라고 생각함
          + ""회의 시간은 소중할 수 있음"" 같은 다른 좋은 규칙과 결합되어야 함
     * 반대의 경우, 적극적으로 과잉 설명하는 것도 신뢰와 경력을 성장시키는 좋은 방법임
          + 직장에서 의사소통할 때나 코드를 작성할 때 질문을 예상하려고 노력함
          + 다른 사람들이 질문할 수 있는 공간을 열어주고, 특히 기사와 같은 상황에서 해결책을 빠르게 찾을 수 있게 함
     * ""The Stupidity Manifesto""도 참고할 수 있음
     * ""서로를 어리석게 만드는 것을 멈추자. 대신, 모두가 질문하도록 격려하자""는 말이 있음

   ""'어리석은 질문을 해도 해고되지 않는다'는 말은 맞지만,

   한국에서는 평소 행동이 어리석다고 평가받으면 업무 능력까지 의심받기 쉽습니다. 결국, 평소 처세와 이미지가 나쁘면 작은 실수나 질문도 큰 문제로 몰릴 수 있죠. 다소 아쉽지만, 적당히 유능해 보여야 인정받는 한국의 직장 문화에서 나온 현상 같습니다.""
"
"https://news.hada.io/topic?id=19949","난 내 식기 세척기를 네 멍청한 클라우드에 연결하지 않을 거야","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   난 내 식기 세척기를 네 멍청한 클라우드에 연결하지 않을 거야

     * 주말에 GE 식기세척기가 고장나서 새로운 Bosch 500 시리즈 식기세척기를 구매함. Consumer Reports에서 추천했으며, 재고가 있어서 선택함
     * 설치 후, 헹굼 사이클을 실행하려 했으나, 지연 시작 및 에코 모드와 같은 기능은 앱이 필요함을 알게 됨
     * 앱을 사용하려면 WiFi에 연결하고 Home Connect라는 클라우드 계정을 설정해야 함

구형 GE 식기세척기 문제

     * 구형 GE 식기세척기는 계획된 노후화의 예로, 5~10년 후에는 새로운 제품을 구매해야 하는 상황을 만듦
     * 전원 문제로 인해 식기세척기가 작동하지 않게 됨. 제어판 교체 비용이 비싸고, 다른 부품들도 녹슬기 시작함

Bosch 식기세척기 선택 이유

     * Bosch는 $1,000 이하의 가격대에서 가장 좋은 선택으로 보였으며, Consumer Reports에서도 높은 평가를 받음.
     * 설치가 쉬웠으며, 플라스틱 베이스와 호스 및 전선의 경로가 더 나아짐.

클라우드 요구사항

     * 새로운 터치 센서가 불편하며, 기능을 사용하기 위해 클라우드 앱이 필요함
     * 앱을 사용하려면 WiFi에 연결하고 Home Connect 계정을 설정해야 함
     * 앱 없이 기능을 사용할 수 없다는 점이 불편함

해결책 및 제안

     * 기능을 사용하지 않거나 WiFi에 연결할 수 있지만, 이는 불편함
     * Home Connect Python 라이브러리를 사용할 수 있지만, 추가적인 설정이 필요함
     * Bosch는 클라우드 없이도 기능을 사용할 수 있도록 해야 하며, 모든 기능을 제어판에서 접근 가능하게 해야 함

소비자 권리 및 제품 개선

     * 클라우드 서비스는 추가 기능으로 제공되어야 하며, 기본 기능은 로컬에서 접근 가능해야 함
     * Bosch 500 시리즈 식기세척기의 설치는 쉬웠으나, 클라우드 요구사항으로 인해 실망스러웠음

        Hacker News 의견

     * Bosch 제품을 구매한 사용자가 와이파이를 원하지 않는다고 판매원에게 말했지만, 설치 후 웹사이트를 통해 기능을 사용해야 한다는 것을 알게 됨
          + 포장을 버린 후에는 반품이 어려워졌고, Bosch에 연락했지만 계속 다른 부서로 돌려보내고 응답이 끊김
          + Bosch 식기세척기를 구매하지 말라는 경고, 웹사이트 계정이 없으면 모든 기능을 사용할 수 없음
     * Jeff가 제품을 반품했어야 한다는 의견
          + 시간이 낭비되지만, 이런 제품은 소매점에서 거부해야 함
          + 소매업체가 추가 지원 부담에 지쳐 제조업체에 요구할 것임
     * 가전제품 구매 시 인터넷 리뷰보다는 서비스 및 보증 제공자의 보고서를 읽으라는 조언
          + 간단한 제품을 선호했지만, 와이파이 기능이 있는 제품을 구매하게 됨
          + 원격으로 오븐을 예열하는 아이디어는 여전히 불안함
     * 같은 식기세척기를 구매한 사용자는 앱 요구사항이 마음에 들지 않지만, 와이파이에 연결하지 않아도 완전한 기능을 제공한다고 설명
          + 몇 가지 고급 기능을 놓치지만, 기본적인 세척 성능은 뛰어남
          + 설치 시 주의사항과 Costco 버전의 차이점 설명
     * Bosch 제품 구매를 고려하던 사용자가 이 댓글을 보고 구매를 재고하게 됨
          + 사용자 매뉴얼을 읽고 제조업체의 의도를 확인할 것임
     * 소셜 미디어에 불만을 올렸지만, 설치에 많은 시간이 걸려 반품하지 않았다는 의견
          + 불만을 제기해도 제조업체는 신경 쓰지 않음
          + 반품을 통해 경제적 타격을 주는 것이 유일한 방법임
     * Cory Doctorow의 ""Unauthorized Bread""라는 책을 읽어보라는 추천
     * Yamaha가 온라인 계정 요구를 철회한 사례
          + MusicCast 앱이 계정 등록을 요구했지만, 사용자들의 불만으로 중단됨
     * 건조기 수리 시 새로운 보드를 구매해 만족한 사례
          + 새로운 기계를 구매하지 않고 보드를 교체해 비용 절감
     * 앱 요구사항이 없는 세탁기와 건조기를 찾기 위해 많은 시간을 소비한 사용자
          + 인터넷 연결이 필요 없는 모델이 거의 없어 다음 구매 시 선택지가 없을까 걱정됨
"
"https://news.hada.io/topic?id=19961","Stoop Coffee: 간단한 아이디어가 우리 동네를 변화시킨 방법","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Stoop Coffee: 간단한 아이디어가 우리 동네를 변화시킨 방법

     * Patty와 남편 Tyler는 도시에서도 교외 같은 공동체 느낌을 만들고자 노력함
     * 처음엔 쿠키를 만들어 돌리거나 저녁 식사에 초대할까 고민했지만, 결국 주말 아침에 집 밖에서 커피를 마시기로 결정함
     * 비록 집에 현관 계단은 없었지만, 접이식 의자를 들고 나와 햇볕을 즐기며 이웃을 맞이하는 루틴을 시작함
     * 이웃들이 지나갈 때 손을 흔들고, 인사하고, 이름을 적어두며 “기억에 남는 사람들”이 되기 위해 노력함
     * 패티는 눈에 띄는 타이다이 모자도 착용해 친근한 이미지 강조

첫 번째 참여자와의 연결

     * 몇 주 후 이웃 Luke가 처음으로 다가와 인사하며 다음 커피 타임에 함께하고 싶다고 연락처를 요청함
     * Luke는 커피 모임에 처음으로 “참여한” 이웃으로, 공동체 형성의 전환점이 되었음
     * 이후 다른 이웃들과도 번호를 교환하기 시작하며 연결이 강화됨

WhatsApp 커뮤니티의 탄생

     * 커피 타임에 참여하는 사람이 늘어나자 일일이 문자 보내기가 어려워져 WhatsApp 그룹 생성
     * 단순한 알림 채널을 넘어 다양한 주제와 이벤트를 위한 WhatsApp Community로 발전함
     * 주말 커피 외에도 다른 활동(홈브루 커피 공유, 잡담 등)으로 자연스럽게 확장됨

더 큰 모임의 시작

     * 첫 번째 큰 이벤트는 블록 파티로 기획했으나, 현실적으로 팬케이크 파티로 축소
     * 스프레드시트로 역할 분담, 팬케이크 믹스와 전기 철판 준비, 전단지 100장 배포 및 전봇대에 플라이어 부착
     * 종이 초대장이 효과를 발휘해 많은 새로운 얼굴들이 모임에 참여함
     * 약 70명 이상 참여, 50명 이상의 연락처가 커뮤니티에 추가됨
     * 이후 모임은 더욱 활발해져 매주 여러 이벤트가 자연스럽게 열리기 시작함 (예: Dipsgiving, 쓰레기 줍기, TV 시청 파티, 맥주 모임 등)

현재 커뮤니티의 모습

     * 초기의 ""우리""는 이제 훨씬 더 넓은 공동체를 지칭하게 됨
     * 모임은 자율적으로 계속되고, WhatsApp 채팅도 활발하게 유지됨
     * 이웃끼리 친구가 되고 서로에게 정서적 지지, 육아, 식사 등 실질적인 도움을 주고받는 관계로 발전함
     * 여전히 성장 가능성이 크며, 새로운 사람들과 연결될 기회가 무궁무진하다는 기대감이 있음

커뮤니티를 통해 배운 점

     * 단순함의 힘: 가장 인기 있는 이벤트는 준비가 간단한 경우가 많으며, 간편하게 유지해야 지치지 않고 지속 가능함
     * 넓히기 vs. 깊이 쌓기: 새 이웃을 만나는 목적(넓히기)과 기존 관계를 강화하는 목적(깊이 쌓기)을 구분해 전략적으로 접근
     * 계절에 따른 이벤트 계획: 추운 계절엔 실내에서 깊은 관계를 쌓는 모임, 따뜻한 계절엔 야외에서 새로운 사람들과의 교류에 집중
     * 거리 공간의 재발견: 도로, 진입로 등 기존에 사용하지 않던 공간을 커뮤니티 공간으로 전환함으로써 더 많은 참여 유도
     * 공동체에 의존하기: 큰 이벤트를 혼자 감당하려 하지 않고, 서로 돕는 문화 조성. 요청하면 이웃이 기꺼이 도와줌

앞으로의 계획

     * 다른 이들도 직접 이벤트를 조직하고, 커뮤니티가 자립적으로 운영될 수 있도록 지원할 계획
     * 지역 상점들과 연결하고, 지역 정책에도 영향력을 갖기 위한 활동 시작
     * 이웃들이 중요하게 여기는 문제를 바탕으로 정책적 우선순위를 정하고, 시 정부와의 협업을 통해 작지만 실질적인 변화 시도
     * 더 많은 사람들과 연결되길 기대하며, 새로운 아이디어와 인사이트를 환영함

        Hacker News 의견

     * 남편 Tyler와 나는 교외에서만 가능한 것 같은 공동체 의식을 원했지만, 샌프란시스코에서도 이를 이룰 수 있다고 믿었음
          + 교외는 오히려 사람들이 서로 잘 대화하지 않는 곳이라는 경험이 있음
          + 그래도 따뜻한 이야기임. 도시 생활이 이런 것을 가능하게 해야 함
     * 나는 Supernuclear의 공동 저자이자 이 글의 편집자임. 블로그를 거의 5년 동안 작성했으며, 무엇이 바이럴될지 모름
          + 성인 시절을 이스탄불, 뉴욕, 샌프란시스코, 산후안에서 보냈음
          + 이스탄불에서는 이웃들이 나에 대해 너무 많이 아는 것처럼 느껴졌음
          + 하지만 집에서 5000마일 떨어진 곳에서 사람들이 내 안부를 걱정해주는 것이 위안이 되었음
          + 이웃을 아는 것은 단순히 설탕을 빌리는 것이 아니라, 정전 시 발전기를 공유하거나 이상한 점을 발견하고 확인해주는 것임
          + 이웃을 알게 되면 더 행복하고 안전해짐
     * 리치먼드에서 학교를 다녔음. 아파트에는 큰 베란다가 있었고, 여름은 매우 더웠음
          + 벽돌 건물은 열을 저장하고 천천히 방출함
          + 에어컨이 없어서 베란다 생활이 주를 이뤘음
          + 샌프란시스코에서는 이런 문화가 없었음. 큰 베란다가 거의 없고, 저녁 안개가 사람들을 집으로 몰아넣음
          + 사회 생활은 코너 술집에서 이루어졌음
     * 이 규칙이 좋음. 하지만 나는 아침에 일어나지 않아서 커피를 마실 수 없음
          + 이웃과 만나고 이야기하는 또 다른 방법은 지역 정치에 참여하는 것임
          + 지역 정치에 참여하면서 더 많은 사람들을 만났음
          + 미국 전역에서 시민 참여는 메시지 보드, 페이스북 그룹, 메일링 리스트를 통해 이루어짐
     * 정말 따뜻한 이야기임. 내 의견은:
          + 그룹이 현재 약 100명의 Whatsapp 멤버를 가지고 있음
          + 이는 필연적으로 파벌과 사회적 냉각을 초래함
          + 새로운 멤버는 메시지를 보내기가 어렵고, 기존 멤버는 알림판으로 사용함
          + 가장 좋은 그룹은 매월 한 번 이상 이벤트에 참석하지 않으면 그룹에서 제거되는 규칙을 가졌음
     * 이 글을 보고 깜짝 놀랐음. 나는 이 지역에 살고 있으며 이 공동체의 일원임
          + Patty, Tyler, Luke는 모두가 가치 있고 환영받는다고 느끼게 하는 공동체 유대를 형성했음
          + 이제는 50명 이상의 이웃을 알고 있음
     * Supernuclear Substack의 편집자 Phil임. Hacker News에서 AI를 제치고 1위를 차지할 줄 몰랐음
          + 친구나 가족이 바로 옆에 사는 것이 스툽 문화를 시작하는 좋은 방법임
          + Live Near Friends라는 회사를 시작했음
     * 몇 주 전에 이 그룹을 지나가면서 ""저 사람들에게 인사해야겠다""라고 생각했음
          + 하지만 급히 지나쳐야 했음
          + 다음번에는 꼭!
     * 사람들이 ""그냥 할 수 있다""고 말할 때, 이런 것을 의미함
          + 이 기사를 읽고 이웃과 커피를 마시고 싶은 사람은 이번 주말에 시작하길 바람
     * 외향적인 개를 키우는 것도 비슷한 영향을 줌
          + 산책할 때마다 개가 다른 개를 만나고 싶어하고, 덕분에 이웃을 알게 됨
          + 아이들과 그들의 친구들보다 더 많은 이웃을 알게 됨
"
"https://news.hada.io/topic?id=19936","Vibe 코딩과 개발자 종말론, 주니어 개발자의 성장 방향에 대한 생각","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Vibe 코딩과 개발자 종말론, 주니어 개발자의 성장 방향에 대한 생각

     * Vibe 코딩이 뜨면서 함께 ""이제 개발자는 필요없다"" vs ""그래도 아직 멀었다"" 논쟁도 활발함
     * 둘 다 일리가 있음. AI 발전 지켜보며, 프로덕 엔지니어로서 일하며 해왔던 생각을 정리했음
     * 다만 나는 AI 전문가도 아니고 그냥 개발자임. Vibe 코딩 경험도 적음. 그러나 다른 분들의 의견을 듣고 싶어서, 그리고 불안해하는 주니어 개발자 분들께 도움이 되길 바라며 글을 썼음
     __________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

직접 경험해본 Vibe: 이정도까지 vs 이정도밖에

   Vibe 코딩으로 주말동안 알까기 게임 제작해봄. 7살 딸아이랑 같이 해보려고 만듦. 90% 코딩을 프롬프트만으로 진행, 구현 시간이 비약적으로 감소함(4시간 만에 나쁘지 않은 퀄리티로 완성)

   이 과정에서 '이런 간단한 것도 못해?'라는 실망감과 '이 정도 요구사항만으로도 이렇게 훌륭하게 만들어준다고?'라는 놀라움을 번갈아 느낌. 특히 전자는 AI가 '내 말을 따르게' 하는 게 쉽지 않았기 때문이 컸음

   그러나 어쨌든 프롬프트 다듬고 기술이 더 발전한다면 '놀라움'의 비중이 훨씬 더 커질 것이고, 이게 확실하게 주니어 개발자 채용 급감을 불러올 것이라고 생각

   이 느낌을 파레토 법칙과 제품 성숙도 개념으로 얘기해보겠음

절망편: 96%의 코드는 AI가 작성할지도 모른다

   제품 성숙도를 3단계 (제로투원, 원투텐, 그 이상)으로 본다면, 제로투원 수준의 코딩 대부분이 AI로 대체 가능해졌다는 것에 충격받음

   파레토 법칙으로 보면 개발자가 제품 개발을 위해 생산하는 코드의 80%가 이 제로투원을 위한 산출물 아니었을까 생각함.
     * 아이디어를 구현하고 PMF를 찾는 과정에서 나오는 코드들. 그리고 Vibe 코딩으로 비개발자도 쉽게 제작 가능한 코드들.

   나아가 원투텐에서 필요한 80%를 잘 정의하고 쪼개서 제로투원 수준으로 처리 가능하다고 가정한다면...
     * 극단적으로는 코드 생산량의 약 96% (= 0.8 + 0.2 * 0.8) 는 AI가 대체할 수 있지 않나 하는 생각
     * Vibe 코딩을 소개한 Y Combinator 영상에서도 몇몇 창업자는 ""제품 코드베이스의 95%를 AI가 작성했다""고 말했다던데 묘하게 숫자가 맞아떨어짐

   이는 개발자 역량에 대한 기대치와, MVP 수준의 제품에 대한 기대치를 상향 평준화할 것으로 예상.
     * Bootstrap, TailwindCSS 이후 프론트엔드 개발자에게 '괜찮은 수준의 UI 스타일링'이 기본 소양으로 되어버린 것과 유사

   그렇다면 이전에는 제로투원 단계의 제품을 만드는 개발 능력만으로도 존중받았을 개발자들에 대한 채용 슬롯이 줄어드는 건 당연해 보임. 그러니 ""이제 개발자는 필요없다""는 말이 과장이 아니게 된 것....

   ...정말 그럴까?

희망편: 그래도 여전히 개발자가 할 일은 많다

  1) 시장 크기가 훨씬 커져서 할 일이 많아짐

   Vibe 코딩의 가장 큰 의의는 제품 개발의 진입장벽을 낮추는 데 있음
     * 기존에 제로투원을 위해 개발자가 손으로 해야 했던 일들의 대부분을 코딩 에이전트들이 극단적으로 적은 비용(시간/돈/사람)으로 대체.
     * 즉 개발자 없이도 아이디어 실행-검증 싸이클을 빠르게 돌릴 수 있게 됨

   따라서 이전에는 등장하지 못했던 제로투원 (또는 그 이하) 수준의 제품이 폭발적으로 많이 등장하게 될 것이고, '나도 내 아이디어를 구현해보고 싶다'는 사람들도 훨씬 더 늘어남.

   이 모든 게 '개발자가 돈을 벌 수 있는' 시장 크기를 키우는 효과를 가져올 것. 원래는 개발자들의 고객이 아니었던 사람들이 새로운 고객층으로 바뀜. 예를 들면
     * 비개발자, PM, 디자이너가 본인 아이디어를 실현할 수 있게 해주는 Vibe 코딩 교육
     * Cursor와 함께 90%는 만들었는데 완성까지는 못가고 있는 제품의 완성을 돕는 단기 외주
     * 어떻게든 만든 제품을 실제로 운영해서 지속적인 수익화로 이어지게 해주는 컨설팅
     * Vibe 코딩을 더 잘, 더 쉽게 하는 데 도움을 주는 여러가지 유료 도구 개발

   회사 밖에서 이런 일로 부수입을 얻든, 이런 일들을 하는 기업이 생기든 간에 시장 변화의 수혜는 개발자들이 가장 많이 누릴 거라고 봄

  2) 개발자가 코딩 외에도 할 수 있고 해야 하는 일이 많음

   AI가 '코딩'의 90%를 대체한다 해서 개발자 90%를 해고할 순 없음
     * 코딩이 제품 개발, 더 나아가 프로덕 엔지니어링에서 차지하는 비중이 생각보다 크지 않기 때문

   제품에 단 하나의 기능이 추가되기까지 대략 어떤 과정을 거치는지만 봐도 이렇게나 단계가 많음.
    1. 문제 인식
    2. 해결 아이디어 도출
    3. 기대효과 및 비용 예상, 개발 우선순위 결정
    4. 제품에 기능으로 녹이기 위한 기획
    5. UI/UX 디자인
    6. 아키텍처 설계
    7. 백엔드 + 프론트엔드 + 인프라 구현
    8. 코드리뷰, 자동화 테스트, QA
    9. 배포, 모니터링, 기능 홍보, A/B 테스팅
   10. 유저 피드백 수집, 운영, 개선

   Vibe 코딩은 여기서 7과 8의 일부만 대신해줄 뿐임.
     * 탁월한 프로덕 엔지니어라면 이 모든 단계에 일정 수준 이상 개입해야 함
     * 코딩을 AI가 대신해주니 나머지를 잘 하는 사람들의 가치가 오히려 커지는 것

  3) 코딩만 보더라도 여전히 유의미하게 할 일이 많음

   굳이 프로덕 엔지니어링까지 가지 않아도 할 일 많음
     * 원투텐 코딩의 마지막 몇%를 마무리할 일도 많고
     * 개발자가 스펙 설계와 구조 설계, 작업 쪼개기 등을 도와주면 Vibe 코딩에 들어가는 비용도 줄어들 것

   그리고 원투텐 이상의 제품에서는 Vibe 코딩에 한계가 많음
     * 코드베이스 커짐 -> 제한된 컨텍스트 윈도우
     * 높은 보안 수준을 지키고 성능 향상시키려면 전문가의 직접 개입 필요
     * AI가 학습 잘 하지 못했을 라이브러리나 언어로 코딩할 때도 마찬가지
     * https://news.hada.io/topic?id=19923 도 비슷한 문제를 얘기하고 있음

그러면 이제 주니어 개발자는 어떻게?

   세상이 절먕편으로 가든 희망편으로 가든 너무 빠르게 변하고 있는 건 확실함. 특히 채용의 문이 급격히 좁아지는 상황에서 주니어들이 어떻게 학습/성장하면 좋을까?

   <무엇이 탁월한 개발자를 만드는가?> 논문을 읽고, 탁월한 개발자의 5가지 핵심 역량을 이렇게 정의해봤음
     * 훌륭한 코드를 짠다
     * 근거 기반 의사결정을 연습한다
     * 동료의 효과적 의사결정을 돕는다
     * 작업의 현재 가치를 극대화한다
     * 효과적으로 꾸준히 학습한다

   이는 AI 시대에도 여전히 중요. 이걸 희망편과 엮어볼 수 있음

  1) 커지는 시장을 적극 활용하기

   나라면 이런 걸 해볼 것
     * 프롬프트 엔지니어링 공부하기
     * 새로 등장하는 AI 앱들 하나씩 찍먹하기
     * 어떻게 작업을 쪼개야 코딩 에이전트가 내 요구사항을 잘 들어주는지 공부하고 실험하기
     * 나의 작은 문제를 해결하는 앱을 Vibe 코딩으로 구현해서 배포해보기
     * 비개발자 지인이 Vibe 코딩 하고 싶다고 하면 (돈 받으며) 과외해주기
     * 지인이 구현 마무리해서 배포하고 운영하는 것도 (역시 돈 받으며) 도와줘보기

  2) 프로덕 엔지니어로서 역량 갖추기

   나라면 이런 걸 해볼 것
     * 문제 인식, 아이디어, 기획, 설계, 테스트, 운영 등 제품 전반에 관심 가지기
     * 솔로 창업가처럼 앱 제작/운영해보면 프로덕 엔지니어링 역량 자연스레 성장할 것
     * 팀 협업 통해 제품 개선 노력하면서 협업 + 프로덕 엔지니어링 역량 향상 시도

   나는 개발자 채용해서 오퍼레터 작성할 때 항상 '당신이 미니 CTO라고 생각하고 일해주기를 바란다'는 내용을 넣곤 했음
     * 적어도 당신이 맡은 프로젝트에서는 당신이 기술적 의사결정의 최종 책임자다
     * 그 프로젝트를 성공시키는 데 있어서 필요한 모든 단계에 개입하라
     * 기술적이든 비기술적이든 동료가 효과적 의사결정과 행동을 할 수 있게 도와라

  3) 개별 기술에 대해 깊이 이해하고 코딩 센스 키우기

   개별 기술을 깊이 이해하는 개발자는 꾸준히 수요가 있음. PMF를 넘어 유니콘/데카콘 기업으로 가려면 Make it Right & Fast가 필수니까.

   여기엔 왕도가 없음. (AI 도움 받으면서) 시간 투자해서 노력해야 함.
     * 프레임워크/라이브러리 내부 탐구, 역사적 맥락 이해, 오픈소스 기여, 라이브러리 직접 제작, 버그 추적/수정, 웹 표준/성능 개선 등

   동시에 좋은 코드에 대한 자신만의 기준을 세우고, 좋은 코드를 알아보는 '코딩 센스'가 더욱 중요해질 것. AI의 잘못된 Vibe를 인지하고, 멈추고, 개입해야 하기 때문.

   코딩 센스를 기르려면 의도적 수련 필요. 여기서도 시간과 노력 들여야 함
     * 좋은 코드를 많이 보고, 내가 짠 코드에 대해 AI든 시니어 개발자든 피드백을 많이 받아보고, AI나 동료가 작성한 코드를 보며 '이대로 가면 어떤 문제가 생길 것 같은지' 예상하고, 실제와 비교해보기

   어쨌든 소프트웨어 엔지니어링의 실무는 많이 변할 겁니다. 코드머신들은 경쟁력이 떨어지겠지만, 실제로 제품을 End-to-End로 만들 수 있는 엔지니어들은 살아남을 거라 저는 베팅하고 있습니다.

   키보드 치는 일이 줄어 들었지만 ai 가 만든 함정 코드 찾는 일이 추가되었어요

   굉장히 의미있고 좋은 글 감사합니다!

   오타를 냈네요. ㅠㅠ

   특히 후자는 AI가 '내 말을 따르게' 하는 게 쉽지 않았기 때문이 컸음 -> 전자는

   참고로 바이브 코딩으로 만든 게임은 이겁니다. https://www.stdy.blog/vibe-go-stone/

   스타트업에 필요한 프로덕트 엔지니어링을 깊이 이해하는 것도 좋지만, 오히려 기술을 극한까지 추구하고 갈고닦는 길도 여전히 유의미하다고 생각합니다. 간단한 웹 애플리케이션을 만드는 개발은 AI가 대체하겠지만, 누군가는 Kubernetes를 고안하고 ElasticSearch를 디자인해야 한다고 생각해요.

   그런 핵심 컴포넌트 설계자들의 수는 한정적이니까, 결국 ""개발자""라는 직군의 수요가 줄어드는 것은 맞다고 봅니다.

   댓글을 달다 보니, 제가 글에서 표현하고 싶었던 메시지가 정리되네요.

   저는 개별 기업에서는 개발자 수요는 어찌됐든 줄어들 것 같은데, '개발 업무'를 필요로 하는 기업 또는 그에 준하는 사업자/개인의 수는 훨씬 더 늘어날 것이니 개발자가 할 일은 여전히 많다고 생각했습니다.

   물론 그것들 또한 AI가 대체할 수도 있겠지만 그쯤 되면 대체 안되는 직군이 없지 않을까...

   좋은 말씀입니다!

   동의합니다. 앞으로는 AI코딩으로 할일과 인간이 할 설계, 검토로 나눠질 것 같고, 프로젝트 전체를 이해하는 AI가 나올때 까지는 공생할 것 같아요

   동의합니다! 물론 거기도 AI가 도와는 주겠지만 바이브로는 어렵지 않을까 싶어요.
"
"https://news.hada.io/topic?id=19890","Lightpanda - AI와 자동화를 위한 헤드리스 브라우저","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Lightpanda - AI와 자동화를 위한 헤드리스 브라우저

     * AI 에이전트, LLM 훈련, 웹 스크래핑 및 테스트를 위한 오픈소스 헤드리스 브라우저
          + 크롬보다 9배 낮은 메모리 사용량, 11배 빠른 실행 속도
     * Javascript 실행 지원, 웹 API 지원, Playwright 및 Puppeteer와 호환 가능 (WIP)
     * Chromium, Blink 또는 WebKit 기반이 아니라서 가벼움
     * Zig 기반의 저수준 시스템 프로그래밍으로 성능 최적화
     * 렌더링 제외, 성능 중심 설계 → 빠르고 가벼운 실행 가능

주요 기능 구현 상태 : 현재 Beta

     * HTTP 로더
     * HTML 파서 및 DOM 트리 (Netsurf 라이브러리 기반)
     * Javascript 지원 (v8)
     * 기본 DOM API 지원
     * Ajax 지원 : XHR API, Fetch API
     * DOM 덤프 → 페이지 구조 및 콘텐츠 추출
     * 기본 CDP(Chrome DevTools Protocol) /websockets 서버 → Puppeteer 및 Playwright와 호환

     웹 API 지원은 현재 진행 중이며 시간이 지나면서 점차 향상될 예정임

   bun 이후로 zig 에서 물건이 또하나 나왔나보군요. 렌더링 엔진은 자체제작일까요? rust 라면 서보를 쓰겠구나 할텐데

   렌더링 제외 브라우저 입니다

   감사합니다. headless 가 그런 뜻이군요
"
"https://news.hada.io/topic?id=19894","몬스터 케이블스는 위협할 사람을 잘못 골랐다 (2008)","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    몬스터 케이블스는 위협할 사람을 잘못 골랐다 (2008)

     * Monster Cables는 고가의 스테레오 케이블을 제조하는 회사이며, Blue Jeans Cable에 다양한 침해 혐의를 주장하며 중단 및 철회 서한을 보냄
     * 그러나 Blue Jeans Cable의 사장인 Kurt Denke는 과거 소송 변호사 출신으로, 강경하게 대응함
     * Denke는 Monster Cables의 주장에 대해 다음과 같은 입장을 밝힘:
          + Monster Cables가 제기한 주장에 대한 구체적인 정보를 요구하며, 이를 바탕으로 침해 여부를 판단하겠다고 선언
          + 합리적인 수준에서 침해 가능성이 확인된다면 필요한 조치를 취하겠지만, 정보가 제공되지 않으면 해당 주장을 포기한 것으로 간주하겠다고 경고
          + Monster Cables가 주장하는 침해 혐의에 대한 입증 책임은 Monster Cables에 있으며, Blue Jeans Cable은 이에 대해 협조할 의무가 없음을 강조
     * Denke는 소송 변호사로서의 경력을 바탕으로 강경한 입장을 취함:
          + 펜실베이니아 대학교 로스쿨 졸업 후 19년간 소송 변호사로 활동하며 복잡한 연방 소송 및 대규모 손해 배상 사건을 담당
          + 보험사들이 근거 없는 주장에 대해 협상하고 합의하는 것에 대해 좌절감을 느껴왔으며, 원칙에 따라 소송에서 끝까지 싸우는 방식을 선호함
          + 근거 없는 합의에 응하는 일은 없을 것이며, 50,000달러의 소송 비용을 쓰더라도 근거 없는 청구에 1달러도 지불하지 않을 것이라고 선언
     * Denke는 Monster Cables의 소송 전략에 대해 다음과 같이 비판함:
          + Monster Cables는 협박 후 신속히 합의를 유도하고, 이를 기반으로 다른 회사들도 합의를 강요함
          + Denke는 Monster Cables의 이 전략에 응하지 않을 것이며, Monster Cables가 승소 판결을 받지 않는 한 어떠한 합의나 라이선스 계약에도 서명하지 않을 것임을 강조
          + 소송이 진행되면 끝까지 싸울 것이며, 소송의 핵심은 Monster Cables의 주장이 근거 없다는 점을 증명하는 데 집중할 것이라고 경고
     * Denke는 소송을 두려워하지 않으며, 오히려 소송이 그립다고 언급함
     * Denke의 강경한 대응이 Blue Jeans Cable의 판매에 어떤 영향을 미칠지 주목됨

        Hacker News 의견

     * Monster가 기타 케이블 외에 다른 제품을 판매하는지 몰랐음
          + 약 15년 전, Monster 제품만 구매하던 사람을 알았음
          + 기타에서 페달 보드, 보드에서 앰프로 두 개의 케이블을 사용했음
          + 음질 향상 때문이 아니라 평생 보증 때문이었음
          + 두 개의 Monster 1/4인치 케이블을 5번이나 무료로 교체받았음
          + 2018년경 평생 보증을 없애고 이름 사용권으로 전환한 것으로 보임
     * Arkell vs Pressdram 사건이 실제로 밈이 된 사례를 언급함
          + 비즈니스 위협에 대한 응답으로 이 사건을 언급한 것을 본 적이 있음
     * Monster Cables는 오랫동안 생각하지 않았던 이름임
          + 디지털 이미지가 더 비싸고 좋은 케이블로 더 나아 보일 것이라고 설득하려 했던 회사로 기억함
     * 몇십 년 전 eBay에서 Monster 스테레오 스피커 케이블을 구매했음
          + 오디오 애호가로서 zip wire로 교체할 수 있었지만, 깔끔한 나일론 재킷이 없었음
          + 스피커를 움직일 때 방해되지 않음
          + 설정에 추가하는 것이 어리석지만 재미있었고, 지금은 만족함
          + Blue Jeans Cable의 인터커넥트 케이블도 가지고 있으며, 그 회사는 훌륭함
          + Monster가 그 회사를 고소한다면 법정에서 패배하길 바람
     * ""나는 변호사다""라는 말이 ""소송에 겁먹지 않을 뿐만 아니라 때때로 그리워한다""는 문장으로 차원이 달라짐
     * Monster가 잘못된 사람을 위협한 것이 아니라, 이번 경우는 Monster에게 잘 풀리지 않을 것임
          + 100명 중 1명이 반격하고 그 사람을 그냥 두면 여전히 큰 승리임
     * 이 이야기를 통해 처음으로 BJC를 알게 되었음
          + 몇 년 후 견고하게 제작된 맞춤형 스피커 인터커넥트를 몇 백 달러에 구매했고 후회 없음
          + 법적 전술에 대해 그의 입장에 매우 공감하며, 더 많은 사람들이 합의 대신 끝까지 싸우길 바람
     * Monster Cables가 Monster Energy로 전환했다고 상상함
          + 주주들에게 '우리는 여전히 사람들을 흥분시키는 사업을 하고 있다'고 정당화함
     * 오디오 장비를 구매할 때 Monster 케이블의 2-5배 더 비싼 업셀에 집중되었음
          + 디지털에서는 비트만 도달하면 케이블이 중요하지 않다고 설명했음
          + 젊은 판매원이 이해하는 것을 보고 저렴한 케이블을 구매함
          + 스피커 와이어도 마찬가지로 더 두꺼운 게이지의 구리 케이블을 저렴하게 구할 수 있음
"
"https://news.hada.io/topic?id=19876","Universal Motion Graphics across All Platforms: Unleashing Creativity with ThorVG","                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Universal Motion Graphics across All Platforms: Unleashing Creativity with ThorVG

   FOSSASIA2025에서 소개한 ThorVG 프로젝트의 최신 업데이트 소개:
     * 산업 표준인 Lottie 스펙을 완벽하게 지원하는 범용 크로스플랫폼 엔진
     * Lottie Expressions의 고급 스크립팅 기능 지원
     * 인터랙티브 Lottie 기능 지원 등
     * https://github.com/thorvg/thorvg
"
"https://news.hada.io/topic?id=19893","Show GN: oopy 노션 블로그: floating table of contents 커스텀 플러그인","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Show GN: oopy 노션 블로그: floating table of contents 커스텀 플러그인

   oopy 노션 블로그에 적용할 수 있는 floating table of contents 입니다.

   [특징]
    1. notion에서 우측에 뜨는 floating table of contents의 UI와 똑같이 구현했습니다. (hover할 때 뜨는 팝오버 제외)
    2. indicator를 클릭하면 스크롤 이동 / indicator로 현재 위치를 알려줍니다.

   [설치 방법]
    1. oopy 관리자 페이지 > html 편집 > body에 아래 script 태그 추가 후 저장
    2. <script src=""https://roseline124.github.io/custom-js/…;
    3. 캐시 삭제 후 강력 새로고침

   [oopy의 floating-toc와 다른점]

   oopy에서 만든 실험적 기능의 floating-toc도 존재합니다.
   https://www.oopy.io/ko/guides/tips-and-tricks/floating-toc

   이 커스텀 플러그인은 우피의 floating-toc와 달리
    1. table of contents 블럭이 없어도 heading을 감지해서 indicator로 표시해줍니다.
    2. page 별로 설정해주지 않아도 heading이 있는 모든 페이지에서 동작합니다.
    3. floating-toc는 heading tag의 텍스트를 모두 보여주지만, 이 플러그인은 콘텐츠 영역을 침범하지 않기 위해 indicator에 hover 시 4~6글자만 노출해서 보여줍니다. (단점)

     * 지금은 노션 popover도 똑같이 재현했습니다!
"
"https://news.hada.io/topic?id=19945","Qwen2.5-VL-32B - 더 똑똑하고 가벼운 모델","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Qwen2.5-VL-32B - 더 똑똑하고 가벼운 모델

     * 1월에 출시한 Qwen2.5-VL 시리즈를 기반으로 강화 학습을 통해 모델을 최적화하고, 32B 파라미터 규모의 새로운 VL 모델 Qwen2.5-VL-32B-Instruct를 Apache 2.0 라이선스 하에 오픈 소스화
     * 이전 모델과 비교하여, 이 32B VL 모델의 특징:
          + 인간 선호도에 더 잘 맞춘 응답: 출력 스타일을 조정하여 더 상세하고 잘 정리된 답변을 제공함.
          + 수학적 추론: 복잡한 수학 문제 해결의 정확성이 크게 향상됨.
          + 세밀한 이미지 이해 및 추론: 이미지 파싱, 콘텐츠 인식, 시각적 논리 추론 등의 작업에서 정확성과 세부 분석이 강화됨.

  성능

     * 동급의 최신 모델들과 광범위한 벤치마킹을 통해, Qwen2.5-VL-32B-Instruct는 Mistral-Small-3.1-24B 및 Gemma-3-27B-IT와 같은 기준 모델을 능가하며, 더 큰 Qwen2-VL-72B-Instruct도 뛰어넘는 성과를 보임.
     * 특히 MMMU, MMMU-Pro, MathVista와 같은 복잡하고 다단계의 추론을 요구하는 멀티모달 작업에서 상당한 이점을 가짐.
     * MM-MT-Bench에서는 주관적인 사용자 경험 평가를 강조하며, Qwen2-VL-72B-Instruct보다 상당한 차이로 우수한 성과를 보임.
     * 시각적 능력뿐만 아니라, 동일한 규모에서 순수 텍스트 능력에서도 최고 수준의 성과를 달성함.

        Hacker News 의견

     * 오픈 소스 중국 모델 출시의 큰 날임. DeepSeek-v3-0324가 오늘 MIT 라이선스로 업데이트되어 출시됨 (이전에는 커스텀 DeepSeek 라이선스였음)
     * 몇 달 전 Llama vision 3.2를 사용했었는데, 속도와 결과 품질 면에서 매우 실망스러웠음. Hugging Face에서 대안을 찾다가 Qwen을 발견했음. 정확도와 속도의 차이가 엄청났음. 이미지를 분석해 반응을 요청하면 4090으로 반초 만에 대부분 정확한 응답을 받음. 더 놀라운 것은 이미지에서 엔티티 이름을 추출할 때, 이름이 잘려 있어도 완전한 이름을 제공함 (예: ""Coca-C""가 배경에 희미하게 보이면 ""Coca-Cola""로 반환함). 잘 알려지지 않은 엔티티나 특정 지역에서만 알려진 엔티티도 잘 처리함. Qwen을 사용한 이후로 Llama나 다른 비전 모델로 돌아가지 않았음
     * 32B 모델은 현재 내가 가장 좋아하는 모델 크기 중 하나임. 매우 강력하면서도 단일 GPU나 적당한 사양의 Mac 노트북(32GB 이상)에서 실행할 수 있을 만큼 작음
     * 이 모델은 이제 MLX에서 다양한 크기로 사용 가능함
          + uv를 사용하여 라이브러리를 설치할 필요 없이 실행함
          + 약 18GB의 모델을 다운로드하여 매우 인상적인 결과를 얻었음
     * 어리석은 질문일 수 있지만, OpenAI, Claude 등은 모든 오픈 소스 모델을 고려할 때 어떻게 그렇게 큰 평가를 받을 수 있는지 궁금함. 그들이 사라지거나 작아질 것이라고 말하는 것은 아니지만, 왜 그렇게 가치가 큰지 궁금함
     * 오픈 웨이트 모델들이 너무 빨리 나오고 있어 추적하기 어려움. 각 모델에서 ""현재""인 것을 유지하는 목록을 관리하는 사람이 있는지 궁금함
     * 모델을 멀티모달로 만드는 것이 텍스트 기능에 어떤 영향을 미치는지 아는 사람이 있는지 궁금함. 기사는 순수 텍스트에서도 좋은 성능을 발휘한다고 주장하지만, 실제로 얼마나 영향을 미치는지 분석이 있는지 궁금함. 몇몇 사람들은 모델이 텍스트에서 더 나아질 것이라고 주장하지만, 데이터 없이 믿기 어렵다고 생각함
     * 어떤 크기의 비디오 카드를 필요로 하는지 더 잘 알고 싶음. HuggingFace 링크에 따르면 bfloat16이므로 최소 64GB가 필요할 것 같음. -7B는 내 16GB AMD 카드에서 실행될 수 있을까?
     * Qwen은 Alibaba Cloud에서 제작한 것임 (블로그 포스트 어디에도 언급되지 않음)
     * 오늘은 Qwen, 내일은 Google의 새로운 SOTA 모델, 다음 주에는 R2가 나올 예정임. 아직 한계에 도달하지 않았음
"
"https://news.hada.io/topic?id=19928",""모든 데모의 어머니" 키셋을 위한 USB 인터페이스","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ""모든 데모의 어머니"" 키셋을 위한 USB 인터페이스

     * USB 인터페이스와 ""모든 데모의 어머니"" 키셋
          + 1960년대 초, 더글라스 엥겔바트는 컴퓨터가 인간의 지능을 어떻게 증강할 수 있는지 연구하기 시작했음. 그는 마우스, 하이퍼텍스트, 공유 문서, 윈도우, 그래픽 사용자 인터페이스 등 현대 컴퓨팅의 많은 기능을 개발했음. 1968년 공동 컴퓨터 회의에서 엥겔바트는 이러한 혁신을 ""모든 데모의 어머니""로 알려진 획기적인 발표에서 시연했음.
          + 엥겔바트의 데모에는 키셋이라는 입력 장치도 포함되어 있었지만, 다른 혁신과 달리 키셋은 널리 사용되지 않았음. 5개의 손가락으로 구성된 키셋은 손을 움직이지 않고 여러 키를 동시에 눌러 문자를 입력할 수 있게 해줌.
          + 엥겔바트의 딸인 크리스티나 엥겔바트가 키셋을 대여해 주었고, 이를 현대 컴퓨터와 연결할 수 있도록 USB 인터페이스를 제작했음.
     * 엥겔바트와 ""모든 데모의 어머니""
          + 엥겔바트의 작업은 Vannevar Bush의 1945년 비전 에세이 ""As We May Think""에서 영감을 받았음. 부시는 하이퍼텍스트 스타일의 링크를 가진 ""memex""라는 지식의 도서관을 상상했음.
          + 1960년대 초, 엥겔바트는 인간 지능을 증강할 수 있는 방법을 개발하기 위해 노력했으며, Stanford Research Institute의 Augmentation Research Center를 설립했음.
          + 1968년, 엥겔바트는 NLS 시스템을 시연했으며, 이는 2,000명의 청중 앞에서 이루어졌음. 그는 계층적 문서를 생성하고 하이퍼링크를 통해 이동하는 방법을 보여주었음.
     * USB 인터페이스로 키셋 연결하기
          + 키셋은 5개의 마이크로 스위치로 구성되어 있으며, 표준 DB-25 커넥터에 연결됨. Teensy 3.6 마이크로컨트롤러 보드를 사용하여 USB 장치 및 호스트로 작동할 수 있도록 함.
          + Teensy의 입력 라인은 마이크로컨트롤러 내부의 풀업 저항기로 구성할 수 있음. 키셋의 왼쪽 버튼과 접지 사이에 1.5 kΩ 저항이 있어 Teensy가 해당 핀을 읽을 수 있도록 1 kΩ 풀업 저항을 연결했음.
     * 인터페이스 코드
          + 키셋을 읽고 USB를 통해 문자를 보내는 것은 비교적 간단하지만 몇 가지 복잡한 점이 있음. 버튼이 안정된 값을 가질 때까지 100ms 대기한 후 USB로 키를 전송함.
          + 5개의 키로 32개의 문자만 지원되므로, 마우스 버튼과 함께 사용하여 대문자, 숫자, 특수 문자 및 제어 문자를 얻어야 함. 인터페이스는 USB 호스트로 작동하여 USB 마우스를 연결할 수 있어야 함.
     * 결론
          + 엥겔바트는 키셋 학습이 어렵지 않다고 주장했지만, 실제로 사용해 본 결과 물리적으로 사용하기 어려웠음. Xerox PARC의 David Liddle는 ""키셋이 사람들을 느리게 만드는 경향이 있었다""고 말했음.
"
"https://news.hada.io/topic?id=19939","소프트웨어 엔지니어링 팀의 AI 활용 방법","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        소프트웨어 엔지니어링 팀의 AI 활용 방법

     * AI 기반 코딩 도구가 급증하며 일부 개인 개발자들은 AI를 이용해 놀라운 성과를 내고 있지만, 하지만 실제 엔지니어링 팀에서는 성과가 미미한 경우가 많음
     * 성과가 차이가 나는 이유는 2가지: ""그린필드 vs 큰 코드베이스"", ""싱글 vs 멀티 플레이어""
     * 그래서 AI를 위한 새로운 코딩 워크플로와 앞으로의 흐름을 다음과 같이 예측해봄:
          + 많은 기업이 엔지니어를 추가 고용 중 — 특히 좋은 회사들이 그러함
          + 가장 큰 도전 과제는 대규모 코드베이스 — 실제로 가치를 창출하는 영역
          + 로봇 vs 아이언맨 — AI 도구의 철학적 차이
          + 개발자 행복 최적화 — AI가 처리할 수 있는 고역은 무엇인가?
          + AI 코드 추적은 안티패턴 — 추적의 유혹에 빠지지 말 것

성과 차이의 원인

     * Green-field vs 큰 코드베이스
          + 대부분의 AI 도구는 새 프로젝트(Green-field)에 최적화됨
          + 오래된 코드베이스에서는 활용도가 떨어짐
     * 싱글 플레이어 vs 멀티 플레이어
          + 현재 AI 워크플로우는 싱글 플레이어 중심
          + 팀에서 협업 시 문제 발생 (머지 충돌, 복잡한 컨텍스트 처리 등)

     ""AI 워크플로우는 혼자 작업할 때는 괜찮지만, 팀에서 사용하면 충돌이 잦고 비효율적임.""

우수한 기업들은 더 많은 엔지니어를 고용중

     * AI의 발전으로 엔지니어 수요가 감소할 것이라는 예측은 틀림
     * AI로 생산성이 증가하면, 결과적으로 엔지니어 고용이 늘어나는 Jevon의 역설 발생
     * AI 도입에 따른 조직별 반응
          + 상위 팀: AI 도입으로 생산성이 증가 → 엔지니어 추가 고용
          + 평균 팀: 관료주의와 조정 비용으로 인해 고용 변화 없음
          + 하위 팀: 기술이 단순 도구에 불과 → 비용 절감을 위해 팀 축소

가장 큰 문제는 대규모 코드베이스

     * AI는 알고리즘 문제 해결에는 뛰어나지만, 실제 프리랜서 작업 성과는 저조함
     * 컨텍스트 부족이 주요 원인
     * 코드베이스에서 컨텍스트 전달 방식:
          + Fine-tuning → 예측 불가능하고 비용이 큼
          + Context Window 확장 → 정확도 보장 어려움
          + RAG (Retrieval-Augmented Generation) → 현재 가장 유망함

     좋은 RAG가 AI 코딩 도구 확장의 핵심

로봇 vs 아이언맨: AI 도구의 철학적 차이

     * 자율형 도구 → 독립적인 에이전트처럼 작동
          + Slack에서 명령받아 자동으로 PR 제출
          + 예: Devin, Lindy
     * 증강형 도구 → 인간이 작업을 주도하며 보조 역할 수행
          + IDE에서 보조 도구로 활용, 최종 PR은 사람이 제출
          + 예: Augment, Cursor
     * 어떤 전략이 더 유리한가?
          + 피드백 루프 → 증강형 도구가 더 빠르게 오류 수정 가능
          + 확장성 → 자율형 도구는 조직적 복잡성 증가 위험
          + 인간 중심 접근 → 증강형 도구가 인간을 강화하는 방향으로 발전

     ""AI는 클론 전쟁이 아니라 어벤저스를 만들어야 함""

개발자 행복을 위한 최적화

     * 성공적인 팀은 생산성이 아니라 개발자 행복에 초점
     * AI를 사용해 단순 작업(고역)을 줄이는 데 집중
     * AI가 해결할 수 있는 Toil
          + 1) 테스트 자동화
               o AI가 테스트 코드 작성 → 보일러플레이트 코드 부담 감소
               o 사전 명세 작성에 대한 보상이 증가 → TDD 적용 용이
          + 2) 문서화 자동화
               o AI가 코드 주석 및 기술 명세 작성 → 문서 관리 부담 감소
               o AI가 코드 구조와 동작 설명 가능 → 단, 코드 작성 의도는 여전히 인간이 설명해야 함
          + 3) 코드 품질 개선
               o 코드 스타일 및 보안 취약점 점검 가능
               o 인공지능 도구 예: Augment, Packmind, Codacy

AI 코드 추적은 안티패턴

     * AI가 자율적으로 작업하면 성과 추적 필요
     * 그러나 AI가 인간을 증강하는 경우, AI 코드와 인간 코드 구분은 무의미함
     * 생산성과 개발자 만족도에 집중하는 것이 더 효과적임

주요 시사점

    1. AI 도입으로 엔지니어 고용 증가 → Jevon의 역설로 인해 생산성 증가 시 고용 확대
    2. AI의 멀티플레이어 도입 필요 → 팀에서의 협업 강화 필요
    3. 대규모 코드베이스 문제 해결 필요 → 맥락 제공이 핵심
    4. 증강형 도구가 자율형 도구보다 유리 → 인간이 주도하고 AI가 보조
    5. 개발자 행복 최적화 → 생산성보다 행복 중시
    6. TDD의 부활 → AI가 테스트 작성 부담 완화
    7. 문서화 부담 감소 → AI가 코드 주석 및 기술 명세 자동 작성
    8. 코드 품질 개선 → AI가 코드 스타일, 보안 문제 점검
    9. AI 코드 추적은 무의미 → 성과는 전체 생산성과 만족도로 평가해야 함

   1번 동의 어렵네요
     * 좋은 회사들은 훌륭한 엔지니어만 채용하려 합니다. 그런 엔지니어 자원은 한정되어 있습니다. 그래서 채용이 늘지 않습니다.

   저는 이렇게 많이 느낍니다. 왜냐면 작은 회사에서 좋은 엔지니어 채용하려고 노력하고 있지만 정말 쉽지가 않더라구요.
"
"https://news.hada.io/topic?id=19916","NixOS와 재현 가능한 빌드로 탐지된 xz 백도어","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      NixOS와 재현 가능한 빌드로 탐지된 xz 백도어

     * 2024년 3월, Linux 배포판에서 소스 타르볼을 압축 해제하는 데 사용되는 xz 소프트웨어에 백도어가 발견됨.
     * 이 백도어는 악의적인 유지보수자 _Jia Tan_에 의해 3년 동안 은밀하게 삽입됨.
     * 이 사건은 원격 코드 실행을 가능하게 하여 큰 영향을 미쳤으며, 발견하기 매우 어려웠음.
     * Microsoft의 Postgres 개발자인 Andres Freund가 성능 저하를 조사하던 중 우연히 발견하여 큰 재앙을 피할 수 있었음.

공격 작동 방식

     * 백도어는 ssh 프로그램을 하이재킹하여 원격 코드 실행을 가능하게 함.
     * RSA_public_decrypt 함수를 수정하여 특정 RSA 키로 로그인할 때 공격자가 임의의 명령을 실행할 수 있도록 함.
     * 두 가지 주요 구성 요소로 구성됨:
         1. 악성 객체 파일을 xz 빌드 프로세스의 일부로 설치하는 스크립트.
         2. RSA_public_decrypt 함수를 후킹하는 절차.

  1. 악성 객체 파일 설치 스크립트

     * 악성 객체 파일은 xz git 저장소의 테스트 파일에 숨겨져 있음.
     * 백도어는 유지보수자가 제공한 릴리스 타르볼에서만 활성화됨.

  2. RSA_public_decrypt 함수 후킹 절차

     * 동적 로딩 시간에 실행되는 코드를 강제 실행하기 위해 glibc의 ifunc 기능을 사용함.
     * ssh가 실행될 때 libsystemd와 liblzma가 로드되며, 이 과정에서 백도어가 임의의 코드를 실행함.

xz 재앙을 피하기 위한 방법

     * 오픈 소스 소프트웨어의 신뢰성을 높이기 위해 소셜 문제와 기술적 문제를 모두 다루어야 함.
     * 소프트웨어 공급망 보안 프로세스를 개선해야 함.

  신뢰할 수 있는 소스에서 소프트웨어 빌드

     * 많은 배포판이 유지보수자가 제공한 타르볼을 사용하여 xz를 빌드했기 때문에 공격이 효과적이었음.
     * 가능한 경우, 가장 신뢰할 수 있는 소스에서 소프트웨어를 빌드해야 함.

    상황이 허락할 때...

     * NixOS는 기능적 패키지 관리 모델을 기반으로 하는 배포판이며, 각 패키지는 Nix라는 함수형 프로그래밍 언어로 표현됨.
     * NixOS는 GitHub에서 자동 생성된 소스 아카이브를 사용하는 문화가 있음.

  신뢰할 수 없는 릴리스 타르볼에 신뢰 구축

     * NixOS는 부트스트랩 단계에서 유지보수자가 제공한 타르볼을 사용해야 했음.
     * 소프트웨어 공급망 보안을 강화하기 위해 특정 보호 조치를 마련해야 함.

    1. 소스 비교

     * 배포판에서 사용하는 소스 타르볼이 GitHub의 것과 동일한지 확인하는 것이 중요함.
     * 그러나 릴리스 타르볼이 소스와 다른 경우가 종종 있으며, 이는 문제가 아님.

    2. 비트 단위 재현성 활용

     * 재현 가능한 빌드는 동일한 조건에서 두 번 빌드할 때 동일한 아티팩트를 생성하는 소프트웨어 프로젝트의 속성임.
     * 비트 단위 재현성을 통해 신뢰할 수 없는 유지보수자 제공 타르볼에 대한 신뢰를 구축할 수 있음.

  결론

     * xz 백도어 사건은 오픈 소스 소프트웨어 공급망 보안의 중요성을 일깨워줌.
     * NixOS와 같은 시스템은 재현 가능한 빌드를 통해 보안을 강화할 수 있음.

        Hacker News 의견

     * NixOS와 재현 가능한 빌드가 xz 백도어를 탐지하지 못했음. NixOS는 악성 xz 빌드를 배포했지만, NixOS를 목표로 한 것이 아니었기 때문에 문제는 없었음
          + NixOS 개발자는 백도어가 드러났을 때 악성 xz 버전이 사용자에게 배포된 것을 보고 놀랐음
          + 이론과 현실은 다르며, xz가 가능했던 이유는 기술적 취약점이 아닌 '현실 세계'의 문제였음. 소프트웨어로 현실 세계를 패치할 수 없음을 인식하는 데 어려움이 있음
     * 저자는 이번 사건에만 집중하고 있는 것 같음. Jiatan 사건은 단일 사례이며, 다른 시나리오에서도 방어가 실패할 수 있음
          + NixOS 사용자로서 NixOS가 이를 잡아내지 못했을 가능성이 높다고 생각함. 증거가 없으면 NixOS에 신뢰를 두는 것은 어리석음
     * NixOS는 xz 백도어가 RedHat과 Debian을 목표로 했기 때문에 관련이 없음. 아이러니하게도 백도어는 Microsoft 직원에 의해 발견됨
     * 기사에서는 배포판이 전통적인 설치용 tarball 대신 VCS(예: Github)에서 직접 소스 코드를 가져와야 한다고 언급함
          + 그러나 악의적인 유지보수자가 소스 코드 저장소에 직접 바이너리 블롭을 추가할 수 있음
          + 저자는 Github가 코드를 검증하는 것처럼 신뢰할 수 있다고 제안하지만, 실제로 Github는 코드를 검증하지 않음
     * NixOS가 예방할 수 있었던 사건에 집중하려면 CrowdStrike 사건에 집중해야 함. 어제의 설정으로 부팅할 수 있었다면 대부분의 문제를 완화할 수 있었음
     * NixOS는 소스에서 모든 것을 컴파일하고, 사용된 소스가 변조되지 않았음을 암호학적으로 검증하며, 패키지 간 버전 종속성을 가짐. Debian도 재현 가능한 빌드를 가짐
          + 문제는 빌드 시스템이 소스에서 빌드하기 전에 사전 컴파일된 객체 파일을 제거하지 않았다는 것임. 소스 코드를 아무도 확인하지 않으면 백도어를 추가할 수 있으며, NixOS나 다른 배포판도 이를 막을 수 없음
     * ""할 수 있었다""는 것은 증명되지 않았음을 의미하며, 실제로 그들은 이를 배포했음
     * 훌륭한 설명적 분석. 잘못된, 오해를 불러일으키는 제목, 아마도 ""기술적으로 정확""하지만, ""백도어가 있는"" 의미로 최선임
          + 빌드 매니저 도구의 필요성과 사용을 강조하며, 빌드 과정에서 파일이 파일에 영향을 미치는 인과 추적 그래프를 명시적으로 만들고, 그 그래프를 강제하거나 이전 추적 그래프와의 편차를 보고하는 방법을 구축해야 함
     * Jia Tan의 PR이 승인되었다면, 악성 아티팩트가 tarball과 마찬가지로 Github 릴리스로 쉽게 갈 수 있었음. Github 릴리스가 보안 완화라는 점을 이해하기 어려움
     * 릴리스 tarball이 소스와 다르다는 점
          + 유지보수자가 제공한 tarball이 원본 소스 코드에서 정직하게 생성되었다면, 어떻게 다른 버전 등이 문제가 되는지 이해하기 어려움
          + 생성된 tarball이 소스 코드 자체에서 생성될 수 있도록 하고, 아무것도 제외하지 말고, git add & commit을 해야 함. 이 경우에도 커밋 기록을 확인해야 하며, 육안으로는 무해했기 때문에 어떻게 검증할 수 있는지 의문임
          + 유지보수된 tarball이 소유자의 소스 코드에서 생성되고 Github에 없으면 문제가 됨
     * 독이 든 테스트 파일을 푸시하는 것 이상의 문제가 있었지만, Nix가 이를 어떻게 예방할 수 있었는지 이해하기 어려움
          + 유명 프로젝트가 리더를 변경했다면, 커밋을 주의 깊게 보고 누가 리더인지 확인해야 할 것임
     * 기사를 잘못 이해했는지, 놓친 것이 있는지 궁금함
"
"https://news.hada.io/topic?id=19880","Model Context Protocol(MCP)을 통해 IntelliJ와 Claude를 연동하기","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Model Context Protocol(MCP)을 통해 IntelliJ와 Claude를 연동하기

   때는 2025년 3월 18일 새벽... MCP (Model Context Protocol) 를 처음 경험하고 느낀 놀라움이 너무 기억에 남아요. 그래서 이 강의를 통해 MCP를 전파하기 위해 이 강의를 만들게 되었어요. 2020년 IntelliJ를 처음 접했을 때의 신세계, 2022년 ChatGPT에 이어, MCP는 LLM을 이용한 개발의 패러다임을 또 한 번 바꿀 것이라 확신합니다.

   본 강의에서는 Model Context Protocol(MCP)을 통해 IntelliJ와 Claude를 연동하여 개발 경험을 혁신적으로 향상시키는 방법을 배웁니다.

   https://blog.sionic.ai/mcp-intellij

   https://youtu.be/1iUBHt2LQ3g?si=VNZ9f-ELtssBkvPh

   Cursor 에서 Claude 3.7 MAX 사용시 요청당 추가 과금이 붙는데 Claude 구독 상태에서 MCP로 IDE에 연결하면 3.7 Thinking 모드를 엄청 넉넉하게 사용할 수 있다는 장점이 있습니다.

   물론 그래도 Cursor 에서 제공하는 IDE 통합 기능 같은 것들이 여전히 강력해서 계속 저울질 하면서 비교를 하게 되지만요..

   그냥 cursor를 사용하는게....

   그러게요 IDE에 사용할거면 Cursor 사용하는게 더 싸고 빠를거같은데
"
"https://news.hada.io/topic?id=19983","변호사 없이 수감: 텍사스 마을의 빈곤한 피고인 방치 문제","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    변호사 없이 수감: 텍사스 마을의 빈곤한 피고인 방치 문제

    변호사 없이 감옥에 방치된 사람들: 텍사스 마을이 가난한 피고인들을 실패시키는 방법

     * 배경: 이글 패스, 텍사스는 멕시코의 피에드라스 네그라스와 국경을 맞대고 있으며, 많은 주민들이 매일 국경을 넘어 일하거나 쇼핑을 하거나 친척을 방문함.
     * 문제점: 매버릭 카운티에서는 경범죄로 기소되기까지 몇 달 동안 감옥에 갇혀 있는 경우가 많음. 일부는 시스템에서 잊혀진 상태로 남아 있음.
     * 주요 사례: 페르난도 파드론은 신용카드를 훔쳐 기저귀와 자전거 등을 구매한 혐의로 체포되었으나, 9개월 동안 법정에 서거나 변호사를 만나지 못했음. 이후 경범죄로 기소되었고, 여러 번 체포되며 부당한 합의에 압박을 받았음.
     * 시스템의 문제점: 매버릭 카운티는 피고인에게 변호사를 제공하지 않으며, 기소되지 않은 상태로 감옥에 오래 머무르는 경우가 많음. 이는 미국 헌법이 보장하는 변호사와 공정한 재판 절차의 권리를 위반함.
     * 지역 정치: 카운티의 사법 시스템은 비효율적이며, 정치적 분열로 인해 개선이 어려움. 민주당이 주도하는 지역이지만 내부 분열이 존재함.
     * 개선 노력: 카운티 판사와 검사들은 시스템 개선을 위해 노력하고 있지만, 여전히 많은 피고인들이 변호사 없이 방치되고 있음.
     * 결론: 매버릭 카운티의 사법 시스템은 피고인들에게 불공정하며, 이는 미국의 사법 정의 원칙에 어긋남. 개선이 필요함.

        Hacker News 의견

     * 미국 사법 시스템은 일반인에게는 부패한 시스템으로 보임. 90%는 법원과 경찰의 자금 조달을 위한 것임
          + 변호사를 고용할 수 없다면, 형식적인 변호사를 제공받음
          + 변호사를 고용할 수 있다면, 주가 당신에게서 갈취하려는 금액보다 더 많은 돈을 쓸 의향이 있는지의 문제임
          + 법정에서 싸우고 싶다면, 패소할 경우 법원이 당신을 기소하는 데 들었다고 믿는 모든 비용을 부담해야 함
          + 법정 비용과 추가 수수료, 법에 명시되지 않은 벌금, 그리고 경찰이 당신을 범죄자로 몰아가는 구실이 됨
     * 미국의 사법 시스템은 돈 있는 사람들을 위한 것임
     * ""두 남성이 형기를 마친 지 반년 후에야 The Times의 문의로 석방됨""
          + 끔찍한 인권 침해로, 개발도상국이 아닌 선진국에서 일어날 일이라고 생각하기 어려움
     * 단순히 ""실패""라고 표현하는 것은 사과하는 듯한 과소평가로 보임
          + 시스템은 적극적인 억압에 가까움
     * 기사에 따르면 당국이 여러 차례 법을 위반한 것으로 보임
          + ""사람들이 기소되지 않은 채 몇 달 동안 감옥에 갇혀 있는 경우가 많음, 이는 주 법이 허용하는 것보다 훨씬 긴 기간임""
     * 미국처럼 소송이 많은 사회에서, 왜 죄수들이 변호사를 고용해 당국을 고소하지 않는지 의문임
          + 성공 수수료로 일할 변호사들이 많으며, 법이 위반되었고 큰 금액을 받을 수 있는 경우가 많음
     * 재미있는 사실: 텍사스에서는 모든 교통 위반(속도 위반과 개방 용기 제외)이 체포 가능한 범죄로 간주됨
          + 경찰관의 재량에 따라 티켓을 발부하거나 체포할 수 있음
     * 우리는 왜 당신이 감옥에 있는지 모르지만, 감옥에 있는 이유는 나쁜 일을 했기 때문이라고 생각함
          + 나쁜 사람들을 자유롭게 놔둘 수 없음
     * 농담처럼 들리지만, 인생에서 의존해 온 것: 대부분의 문제는 돈을 충분히 쓰면 해결됨
          + 지난 9년 동안 문제를 돈으로 해결할 수 없는 상황에 처하지 않기 위해 공격적으로 돈을 저축해 옴
          + 냉소적이지만, 미국에서는 현실임
     * 미국은 200년이 조금 넘었으며, 법률가들이 법원 시스템을 더 빠르고 저렴하게 만들기 위해 열심히 일하고 있음
          + 조금 더 시간이 필요함
     * 작은 사회적 보수적인 공동체에서 눈에 띄는 것은 매우 끔찍한 결과를 초래할 수 있음
"
"https://news.hada.io/topic?id=19865","GitHub Actions로 인한 고통","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GitHub Actions로 인한 고통

     * GitHub Actions의 문제점
          + 최근 GitHub Actions로 CI 스크립트를 다시 작성하는 데 많은 시간을 소비했음. 이전에는 Earthly를 사용했으나 중단되어 다시 GitHub Actions로 돌아옴.
          + CI는 복잡하며, 병합 대기열, 여러 실행기, Rust 빌드, Docker 이미지, 통합 테스트 등을 포함함. 모든 PR 병합 시 많은 CI 시간이 소모됨.
          + 좋은 소프트웨어 관행으로 모든 테스트를 통과해야 하고, 사소한 실수는 자동으로 수정되어야 하며, 테스트한 아티팩트는 릴리스와 동일해야 함. GitHub Actions는 이를 가능하게 하지만 설정이 복잡하고 비일관적임.
     * 상태 검사와 병합 대기열
          + GitHub의 병합 대기열은 PR을 메인 브랜치에 리베이스한 후 CI를 실행함. 그러나 CI를 대기열에 넣기 전과 후에 모두 실행해야 하며, 이를 설정하는 것이 어려움.
          + 해결책은 두 단계에서 작업 이름을 동일하게 설정하는 것임. 이를 통해 두 단계 모두 통과해야 함.
     * 보안 문제
          + 최근 인기 있는 GitHub Action이 손상됨. 대응책으로 해시로 종속성을 고정하라는 권고가 있었으나, 대부분의 사용자가 이를 하지 않음.
          + GitHub의 보안 모델은 복잡하며 이해하기 어려움. GITHUB_TOKEN의 기본 권한을 설정할 수 있지만, 권한을 제거하는 것이 명확하지 않음.
          + 워크플로우 권한은 액션 자체에 의존하지 않으며, 권한을 코드 내에서 높이는 것은 이상함.
     * Docker와 GitHub Actions의 조합
          + GitHub Actions에서 컨테이너 내에서 작업을 실행할 수 있지만, 파일 권한 문제와 $HOME 디렉토리 위치 변경 등으로 인해 문제가 발생함.
          + 컨테이너 필드에는 제한이 많아 엔트리포인트를 재정의하거나 일부 단계만 컨테이너 내에서 실행하는 것이 불가능함.
     * YAML로 워크플로우 개발
          + YAML로 로직을 작성하는 것은 복잡해질 수 있으며, 실수를 하기 쉬움. RustRover IDE를 사용해 일부 검사를 수행했으나, 더 나은 정적 검사가 필요함.
          + 로컬에서 테스트하기 어려워 동일한 레포지토리를 만들어 CI가 작동할 때까지 반복적으로 커밋하고 푸시해야 함.
          + 워크플로우를 작게 유지하고 아티팩트를 푸시하여 다른 워크플로우에서 재사용할 수 있도록 함. 그러나 아티팩트를 다운로드할 때 토큰이 필요함.
     * 결론
          + 새로운 CI 스크립트로 병합 시간이 크게 줄어들었으나, 설정 과정이 복잡하고 디버깅이 어려움. 혁신이 필요함.

        Hacker News 의견

     * GitLab이 더 낫다는 의견이 있지만, GitLab도 다른 방식으로 문제가 있음
          + 여러 CI 도구를 사용해본 결과, 가능한 많은 CI 로직을 자체 코드에 작성하는 것이 중요함
          + 개발자 머신에서 파이프라인을 로컬로 실행할 수 있도록 투자해야 함
          + YAML 사용을 가능한 한 피해야 함
          + VC 자금 지원을 받은 새로운 도구에 의존하지 말아야 함
          + 가능한 한 자체 러너를 사용하고, 온프레미스에서 운영해야 함
     * GitHub Actions와 DevOps가 널리 비판받는다는 사실이 흥미로움
          + 설정과 테스트가 번거로울 수 있지만, 작동하면 거의 손대지 않음
          + Node 버전 업데이트 외에는 4년 동안 워크플로를 거의 수정하지 않음
          + 개인적으로는 만족스러움
     * GitLab을 사용하다가 GitHub로 전환했지만 실망스러웠음
          + GitHub Actions가 GitLab에 비해 매우 부족하다고 느낌
          + 회사 운영 시 GitLab을 선택할 것임
     * 피드백 루프가 30-60초인 것이 최악임
          + GHA 환경을 로컬에서 복제하려고 했지만 불가능했음
          + 작은 실수로 인해 많은 시간이 소요됨
     * CI가 자동으로 코드를 수정하는 것을 원치 않음
          + 사소한 체크는 pre-commit hook으로 실행되어야 함
     * GitHub Actions의 발전이 멈춘 것 같아 실망스러움
          + Earthly와 Dagger의 개발 중단이 아쉬움
          + Depot.dev를 평가한 결과, 매우 똑똑한 팀이 문제를 잘 해결했음
     * GitHub Actions가 컨테이너를 설치 스크립트로 오용하게 만듦
          + 워크플로에서 많은 시간이 설치 프로그램 실행에 소요됨
     * 적절한 도구를 선택하는 것이 중요함
          + GitHub Actions는 간단한 작업에 적합하지만 복잡한 작업에는 적합하지 않음
     * GitHub Action의 보안 문제로 인해 해시를 사용해 의존성을 고정해야 함
          + 해시를 사용하면 훨씬 안전함
     * GitHub Actions의 문제점이 많음
          + 10GB 캐시 제한, 러너 유형에 따른 동시성 제한, 높은 비용 등
          + Depot.dev는 GitHub Actions를 더 빠르게 만들고 문제를 해결하려고 함
          + Docker 이미지 빌드를 빠르게 하고, 러너를 최적화하여 작업을 매우 빠르게 만듦
          + GitHub Actions는 인기가 많지만 개선의 여지가 많음
"
"https://news.hada.io/topic?id=19972","Hacker News 유명도 기준 최고의 개인 블로그들","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Hacker News 유명도 기준 최고의 개인 블로그들

     * Hacker News에서 인기 있는 개인 블로그를 순위별로 나열한 목록으로, 각 블로그의 저자, 주제 및 총 점수를 표시
     * 다양한 기술 및 비즈니스 주제를 다루며, 독립 저널리스트부터 기술 분석가에 이르기까지 다양한 배경의 저자들이 포함

Hacker News 인기 개인 블로그 순위

     * paulgraham.com
          + 총 점수: 96,443
          + 저자: Paul Graham
          + 소개: Y Combinator 공동 창립자, 기업가, 에세이 작가
          + 주제: 스타트업, 기술, 에세이
     * krebsonsecurity.com
          + 총 점수: 83,047
          + 저자: Brian Krebs
          + 소개: 독립 저널리스트
          + 주제: 보안, 악성코드, 사기
     * jvns.ca
          + 총 점수: 50,092
          + 저자: Julia Evans
          + 소개: 개발자 및 잡지 작가
          + 주제: 리눅스, 디버깅, DNS
     * danluu.com
          + 총 점수: 48,169
          + 저자: Dan Luu
          + 소개: 엔지니어 및 작가
          + 주제: 하드웨어, 소프트웨어, 성능
     * daringfireball.net
          + 총 점수: 47,248
          + 저자: John Gruber
          + 소개: 기술 블로거
          + 주제: Apple, 기술, 디자인
     * simonwillison.net
          + 총 점수: 46,596
          + 저자: Simon Willison
          + 소개: 개발자 및 Django 공동 창작자
          + 주제: 소프트웨어 개발, 데이터 저널리즘, AI
     * stratechery.com
          + 총 점수: 44,237
          + 저자: Ben Thompson
          + 소개: 기술 분석가
          + 주제: 비즈니스, 기술, 미디어
     * righto.com
          + 총 점수: 41,876
          + 저자: Ken Shirriff
          + 소개: 빈티지 컴퓨터 애호가
          + 주제: 컴퓨터 역사, 빈티지 컴퓨터, 역공학
     * troyhunt.com
          + 총 점수: 41,875
          + 저자: Troy Hunt
          + 소개: 보안 전문가 및 강사
          + 주제: 보안, 데이터 유출, 웹 보안
     * kalzumeus.com
          + 총 점수: 41,254
          + 저자: Patrick McKenzie
          + 소개: 개발자 및 컨설턴트
          + 주제: 제품 가격 책정, A/B 테스트, 전환 최적화

        Hacker News 의견

     * 몇 년 동안 같은 이름을 가진 훌륭한 개발자이자 작가와 블로그 SEO 순위 싸움을 벌이고 있었음. 축구 선수는 우리 둘을 능가하지만, ""개발자""나 ""프로그래밍""을 추가하면 그가 나보다 훨씬 앞섬. 그는 기술에 대해 더 일관되게 글을 쓰고, 그의 글이 내 산발적이고 다양한 글보다 더 유용할 가능성이 높음
          + 이 글을 보고 내 블로그를 검색했을 때 #292에 있는 것을 보고 기뻤음
          + #289에 있는 사람은 누구일까? 바로 나임
          + 이 글을 Show HN으로 제출하려고 했지만 성공하지 못했음. 관심을 가져줘서 기쁨
          + 잠자기 전에 이 글을 봤지만, 제안이나 질문을 환영하며 아침에 답변할 것임
          + 메타데이터를 개선하고 싶다면 PR을 환영함: https://github.com/mtlynch/hn-popularity-contest-data
     * Ken Shirriff의 블로그가 상위 5000에 들지 않은 것이 놀라움. 블로그로 간주되지 않는 것일까?
          + 명시적으로 제외된 것 같음
          + [1] https://news.ycombinator.com/from?site=righto.com
          + [2] https://github.com/mtlynch/hn-popularity-contest-data/…
     * 흥미로운 웹사이트임. 능동태와 수동태에 대한 무료 챕터를 읽었는데, 잘 이해하지 못했던 부분을 명확히 설명해줌. 매니저는 우리의 공을 인정할 때 능동태를 사용하고, 잘못했을 때 수동태를 사용함. 깔끔한 트릭임
     * dynomight.net이 ""실존적 불안""이라는 독특한 카테고리로 상위 블로그 중에서 두드러지는 것이 마음에 듦. 익명/가명 작가가 작성한 글임. 그들의 글을 매우 좋아함
          + 내 사이트가 지난 5년 동안 상위 5000에 포함된 것도 놀라움. Hacker News는 동시에 매우 크지만, 일상적으로 이름을 인식할 수 있는 아늑한 커뮤니티 같음
     * 와우, 나는 511번째 상위 블로그임. 작가, 소개, 태그는 없음. 슬픔
          + 솔직히 HackerNews는 성장하기에 좋은 장소였음. 대학 시절 21살 때부터 여기서 글을 쓰기 시작했음. 이제 37살이 되었음
          + Hacker News 덕분에 슬로베니아에서 샌프란시스코로 올 수 있었음. 지금까지 멋진 여정이었음. 그 중 일부는 첫 페이지에 올랐음
     * HN 블로그의 섞인 목록을 유지하고 있음
          + [1] https://blogs.hn
          + 사이트를 추가하거나 수정해 주세요 :)
          + [2] https://github.com/surprisetalk/blogs.hn
     * https://lcamtuf.substack.com/ 또는 https://lcamtuf.coredump.cx/가 포함되지 않은 것이 당황스러움
     * 와우, #265 :) FortressOfDoors.com
          + 하지만 내 이름은 Lars Doucet이고, Keith Burgun이 아님 (KeithBurgen.net)
          + 포함되어 기쁨
     * 항상 이런 목록에서 내 블로그를 검색하지 않을 수 없음. 예상대로 상위 5000에는 없음
"
"https://news.hada.io/topic?id=19970","Node.js에서 Corepack 배포 중단하기로 결정","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Node.js에서 Corepack 배포 중단하기로 결정

     * Node.js 기술운영위원회(TSC)가 Corepack을 더 이상 Node.js에 포함해 배포하지 않기로 공식 투표로 결정함
     * Node.js 25버전부터 적용되며, Node.js 24 이하에서는 실험적 기능으로 계속 제공됨

Corepack의 역할과 한계

     * Corepack은 Node.js 16.9.0에서 도입된 실험적 도구로, Yarn, pnpm 같은 패키지 매니저를 별도 설치 없이 사용할 수 있게 해줌
     * 프로젝트에서 특정 패키지 매니저 버전을 강제할 수 있도록 도와주는 역할을 수행함
     * 하지만 사용자 인식 부족과 목적에 대한 오해로 인해 널리 사용되지 않음
     * 런타임과 독립적으로 동작해야 할 패키지 매니저를 Node.js에 포함시키는 것에 대한 회의론 존재

Corepack 제거까지의 과정

     * Corepack의 향후에 대한 논의는 수년간 지속되어 왔으며, 2023년 11월에는 기본 활성화 제안이 논란을 일으킴
     * 2024년 2월에는 Corepack이 npm과 Node.js의 결합을 해체하는 수단으로 쓰일 수 있다는 우려 제기
     * 2024년 3월에는 npm은 계속 Node.js에 포함된다는 점을 명확히 하면서도, Corepack의 제거 가능성이 대두됨
     * TSC는 패키지 유지보수 워킹 그룹(PMWG)에 관련 결정을 위임함
     * PMWG는 다음과 같은 제거 로드맵을 제시함:
          + Node.js 다운로드 페이지에서 nvm, fnm 같은 버전 관리 도구를 강조
          + Corepack 문서를 Node.js API 문서에서 분리하여 별도 저장소로 이동
          + 다음 주요 릴리스부터 Corepack을 Node.js 배포본에서 제거
     * 이 로드맵은 PMWG 내에서 강한 지지를 받아 최종 투표로 이어짐

Corepack 제거 결정의 이유

     * 낮은 채택률: 많은 개발자들이 Corepack 대신 각자 선호하는 패키지 매니저를 직접 설치해서 사용함
     * 배포 관련 우려: Corepack이 Node.js 바이너리에 포함되는 것 자체가 불필요하다는 의견 존재
     * 장기 유지보수 문제: Corepack이 Node.js와 분리되면, 패키지 매니저가 더 독립적으로 발전할 수 있음
     * 투표 결과는 '향후 단계적 제거' 제안이 채택됨
     * 다른 제안(예: 기본 비활성 상태로 유지)은 충분한 지지를 받지 못함
     * 일부 개발자들은 npm 대신 Corepack을 사용해 pnpm을 활용했기 때문에 이 결정을 후퇴라고 평가
     * Node.js 측은 Corepack이 원래부터 영구적인 기능이 아니며, 분리 유지되는 것이 바람직하다고 강조함

앞으로의 변화

     * 향후 Node.js에서는 Corepack이 기본 포함되지 않음
     * 필요 시 수동으로 다음 명령어를 통해 설치해야 함:
          + npm install -g corepack
     * Corepack을 사용하는 프로젝트는 문서와 워크플로우를 업데이트할 필요 있음
     * 단, 이번 결정은 Corepack의 지원 종료를 의미하는 것이 아니라, 단지 Node.js에서 제거된다는 의미임
     * Node.js 24.x가 EOL이 되기 전까지는 Corepack 유지보수가 계속됨

Node.js와 패키지 매니저의 역사적 맥락

     * 과거에도 Node.js에 포함해야 할 요소에 대한 논란이 존재했으며, npm 포함 여부도 그 중 하나였음
     * Yarn, pnpm 등 대체 패키지 매니저의 등장으로 다양한 선택지가 생김
     * Corepack 제거는 Node.js 배포본을 더 간결하게 만들기 위한 움직임의 일환임
     * 이는 런타임과 패키지 매니저를 분리하는 다른 언어 생태계의 흐름과도 일치함
     * 개발자들은 향후 Node.js에 Corepack이 포함되지 않는 점을 고려하여 개발 환경을 준비해야 함
"
"https://news.hada.io/topic?id=19871","Claude, 인터넷 검색 기능(Web Search) 정식 지원 시작","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Claude, 인터넷 검색 기능(Web Search) 정식 지원 시작

     * Claude, 인터넷 검색 기능(Web Search) 정식 지원 시작 (Claude 3.7 Sonnet부터)
     * 최신 정보를 실시간 검색하여 보다 정확하고 신뢰할 수 있는 응답 제공
     * 웹 검색 결과를 직접 인용하여 출처를 명시, 사용자가 손쉽게 팩트체크 가능
     * 주요 활용 사례:
          + 영업팀: 최신 업계 트렌드 분석으로 잠재 고객과의 효과적 소통 지원
          + 금융 분석가: 시장 데이터, 실적 보고서 분석을 통한 투자 결정 지원
          + 연구자: 웹상의 최신 자료 검색을 통해 연구 제안서 및 문헌 리뷰 강화
          + 소비자: 제품 기능, 가격, 리뷰를 실시간 비교하여 합리적 구매 결정 지원
     * 현재 미국 내 유료 사용자 대상으로 프리뷰 제공 중이며, 무료 플랜 사용자 및 타 국가도 곧 지원 예정

   이래서 어제 오늘 API가 불안정하군요
"
"https://news.hada.io/topic?id=19959","argp - Go용 GNU 스타일 커맨드라인 인자 파서","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     argp - Go용 GNU 스타일 커맨드라인 인자 파서

     * ./test -vo out.png --size 256 input.txt 같은 GNU 표준을 따르는 명령줄 인자 파서
     * -h 및 --help로 내장된 도움말 메시지 제공
     * 태그 설정으로 구조체 필드에 인자 매핑
     * 배열, 슬라이스, 구조체 같은 복합 타입 필드 지원
     * 중첩된 서브 명령 지원

GNU 명령줄 인자 규칙

     * 하이픈(-)으로 시작하는 항목은 옵션임
     * 여러 옵션은 결합 가능 (-abc는 -a -b -c와 동일함)
     * 긴 옵션은 두 개의 하이픈(--)으로 시작 (--abc)
     * 옵션 이름은 영숫자만 가능
     * 옵션 값은 공백, 등호(=), 또는 연속된 값으로 설정 가능 (-a1, -a=1, -a 1 모두 동일)
     * 옵션과 비옵션 값은 섞여도 문제 없음
     * 옵션은 어떤 순서로든 나타날 수 있음.
     * --는 옵션 종료 의미로 이후 인자는 모두 비옵션으로 처리
     * 단일 -는 일반적으로 표준 입력 또는 출력을 의미
     * 동일 옵션이 여러 번 지정되면 마지막 값이 적용됨
     * 옵션은 여러 개의 값을 가질 수 있음 (-a 1 2 3은 [1,2,3]으로 처리됨)

추가 기능

     * 옵션 카운팅: -vvv는 v = 3으로 설정됨
     * 옵션 추가: -v 1 -v 2는 v = []int{1, 2}로 설정됨
     * 불리언 옵션: --var는 활성화하고 --no-var는 비활성화함
     * 옵션은 구조체, 슬라이스, 맵과 같은 복합 타입이 될 수 있음
     * 옵션은 소스(예: SQL)에서 목록/딕셔너리 값을 가져올 수 있음

   cobra를 사용했었는데, 그에 비해 argp는 flag에 대해 여러가지 옵션을 주네요 ㅎㅎ
"
"https://news.hada.io/topic?id=19924","2025년 React 트렌드","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            2025년 React 트렌드

     * React는 클라이언트-서버 경계를 허무는 풀스택 프레임워크로 진화 중
     * Next.js의 독점적 지위가 약화되며 TanStack Start 및 React Router가 경쟁자로 부상
     * React의 폼, 상태 관리, 서버 컴포넌트, AI 도입 등 기능이 강화됨
     * React 개발자는 앞으로 풀스택 환경에 익숙해질 필요가 있음

React Server Components (RSC)

     * React Server Components (RSC) 는 클라이언트 측 JavaScript 번들 크기를 줄이고 성능을 최적화하는 기능
          + 최초 발표: 2020년 12월 21일
          + 첫 구현: Next.js 13 (2022년)에서 App Router 도입
          + Next.js 15 (2024년)에서 보다 안정적인 상태에 도달
          + React Router 및 TanStack Start에서도 곧 RSC를 도입할 것으로 예상됨
     * RSC의 동작 방식
          + 서버에서 한 번 실행되고 렌더링된 결과만 클라이언트에 전송
          + 클라이언트 측 JavaScript 양 감소
          + 서버에서 데이터베이스 및 API 접근 가능 (보안 강화)

React Server Functions (RSF)

     * React Server Actions (RSA) → RSC에서 발전한 형태로, 서버에서 데이터를 수정 및 업데이트 가능
          + API 라우트를 정의하지 않고 원격 프로시저 호출(RPC) 방식으로 서버 함수 실행
          + use server 디렉티브 사용
     * React Server Functions (RSF)
          + 2024년 9월 React 팀이 RSA를 포함한 포괄적 개념으로 RSF 발표
          + RSC 및 클라이언트 컴포넌트에서 모두 작동 가능
          + 데이터 읽기 및 수정 작업 모두 포함
     * Next.js, TanStack Start, React Router에서 구현 예정

React Forms 개선 사항

     * React 19에서 폼 관련 기능 대폭 개선
          + <form>의 action 속성을 통해 서버 액션 직접 호출 가능
          + 새로운 훅 추가
               o useFormStatus, useOptimistic, useActionState
          + 복잡한 폼 상태 관리 개선
     * 기존 라이브러리와 호환 가능
          + React Hook Form 같은 기존 라이브러리도 계속 사용 가능
          + React의 자체 폼 처리 기능이 더 강력하고 유연해짐

Library vs Framework (라이브러리 vs 프레임워크)

     * React는 이제 단순한 라이브러리를 넘어 프레임워크의 성격을 띔
          + 클라이언트 렌더링(CSR), 서버 사이드 렌더링(SSR), 정적 생성(SSG), 증분 정적 재생성(ISR) 지원
          + 특정 프레임워크(예: Next.js)를 사용해야 RSC 및 RSF 기능 사용 가능
     * 프로젝트 요구사항에 따른 선택 필요
          + 단순 클라이언트 앱 → React 자체 사용 가능
          + 서버 측 기능 필요 → Next.js, TanStack Start, React Router 같은 프레임워크 필요

React Frameworks 경쟁 심화

     * Next.js가 여전히 가장 인기 있는 프레임워크
     * TanStack Start와 React Router가 2025년에 경쟁자로 부상할 가능성 높음
          + TanStack Start → TanStack Router 기반의 새로운 프레임워크
          + React Router → Remix에서 발전한 형태로 프레임워크 성격 강화
     * 두 프레임워크 모두 RSC 및 RSF 지원 예정

Full-Stack React

     * React의 서버 중심 기능 도입 → 풀스택 애플리케이션으로 발전 중
          + RSC 및 RSF를 통한 데이터베이스 접근 가능
          + 인증, 권한, 캐싱 등 백엔드 인프라 필요
          + 클라이언트-서버 간 통신도 간소화됨
     * React 기반의 AI 애플리케이션 구축 가능성 증가

React의 ""Shadcnification""

     * Shadcn UI → Tailwind CSS처럼 React의 기본 UI 라이브러리로 자리잡음
          + 사전 스타일링된 컴포넌트 제공
          + 사용자 정의 가능
     * 새로운 UI 접근 방식 등장 가능성
          + 현재 프로젝트들이 비슷해 보이는 현상 발생

React와 AI

     * AI 기반 React 코드 생성 증가
          + AI 도구(v0 등)에서 React 코드 자동 생성
     * AI 지원 애플리케이션 구축 증가
          + Vercel의 AI SDK, LangChain 등 지원

Biome (구 Rome)

     * ESLint 및 Prettier 통합 문제 해결
     * Rust 기반의 빠르고 일관된 도구
          + Prettier의 $20,000 상금 획득 (2023년)
     * Biome → 차세대 React 툴체인으로 자리잡을 가능성 높음

React Compiler

     * React Compiler → 성능 최적화 자동화 도구
          + useCallback, useMemo, memo를 자동으로 처리
          + 수동 메모이제이션 필요 없음
          + React 19에서 베타 버전 제공 중

   React는 풀스택 프레임워크(가 되어가는 중)임
   React 기술 스택 2025
   2024년 React 트렌드
"
"https://news.hada.io/topic?id=19885","관리자, 디렉터, VP의 진짜 의미 (2015)","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       관리자, 디렉터, VP의 진짜 의미 (2015)

   관리자, 디렉터, VP의 핵심 역할과 차이점
     * 1. 관리자 (Manager)
          + 결과를 내는 역할 (지원이 필요함)
          + 해당 분야에서 경험이 있음
          + 책임을 지고 일을 수행하지만 여전히 학습 중
          + 프로젝트의 전술적 계획을 실행 가능하지만 직접 수립하기는 어려움
     * 2. 디렉터 (Director)
          + 결과를 독립적으로 내는 역할 (""Set and Forget"")
               o 감독 없이 결과를 도출 가능
               o 프로젝트의 전술적 계획을 쉽게 수립하고 실행 가능
               o 조직 간 협업을 통해 프로젝트 완료 가능
          + 강한 디렉터는 ""일을 해내는 사람""
     * 3. 부사장 (VP)
          + 계획을 수립하고 실행하는 역할
               o 회사의 비즈니스 상황을 파악하고, 이를 해결하기 위한 계획 수립
               o 계획에 대한 내부 합의 및 승인 획득 후 실행
          + 계획이 실패할 경우 책임을 피할 수 없음
               o 승인된 계획을 실행했더라도 실패하면 책임은 VP에게 있음
               o ""계획은 승인받았다""는 변명이 통하지 않음

디렉터에서 VP로의 전환에서 가장 흔한 문제점

     * 디렉터 사고방식을 버리지 못하는 VP
          + 계획이 실패했을 때 ""계획은 승인된 것이었다""고 변명하는 경우
          + VP의 역할은 단순히 계획을 실행하는 것이 아니라 올바른 계획을 세우는 것
          + CEO는 실패한 계획에 대해 변명하지 않음 → VP도 마찬가지로 결과에 책임져야 함

""지금 해고하든 나중에 해고하든"" 원칙

     * VP는 자신이 신뢰하지 않는 계획에 서명하지 말아야 함
          + 계획이 잘못되었다고 판단되면 처음부터 반대해야 함
          + ""동의하지 않은 계획""을 어정쩡하게 수행하다 결국 실패하고 해고되는 것보다,
            처음부터 반대하고 해고되는 것이 더 나음
          + 자신의 계획이 실패하면 책임질 수 있는 계획을 세워야 함

결국 중요한 것은 책임감과 리더십

     * VP는 결과에 대한 책임을 피할 수 없음
     * 자신의 계획을 믿고 추진하는 것이 VP의 핵심 역량
     * 실패할 가능성이 있다면, 자신의 계획으로 실패해야 함
     * 훌륭한 VP는 결과에 책임지고 계획을 수정할 수 있는 능력을 보유

경력 개발의 핵심은 사고방식의 전환

     * 디렉터는 실행자가 아닌 계획 수립자로 성장해야 함
     * VP는 계획 수립에 대한 완전한 책임을 져야 함
     * 성장 단계에서 요구되는 핵심 역량 변화 인식이 중요

        Hacker News 의견

     * IC에서 매니저로 전환하면서 배운 점은 매니저 레벨에서 많은 활동이 보이지 않는다는 것임
          + 좋은 인재를 유지하려는 노력이 그 예임
          + 좋은 인재는 다양한 이유로 회사를 떠나고 싶어함
          + 이 경우 매니저와 HR 간의 회의가 열리고, 성공적인 유지로 이어질 수 있음
          + 그러나 이러한 일들은 직원과 매니저만 알고 있으며, 다른 직원들은 알지 못함
          + 매니저는 많은 ""보이지 않는"" 일을 함
          + IC에서 매니저로 전환할 때 이러한 점을 연구할 가치가 있음
     * 경력 동안 다양한 직함을 가졌지만, 회사마다 책임과 운영 방식이 크게 다름
          + 리더십 직책을 찾는 것은 각 회사가 매니저나 디렉터, VP에게 무엇을 원하는지 해독하는 것임
          + 어떤 역할은 ""핸즈온""임
          + 다른 역할은 사람 관리와 감성 지능에 중점을 둠
          + 기술적 통찰력과 방향성이 중요한 경우도 있음
          + 리더십 직책에서 유일하게 믿을 수 있는 것은 직함이 참석해야 할 회의를 설명한다는 것임
     * 많은 VP가 여전히 디렉터처럼 생각하는 것이 가장 큰 문제임
          + VP의 역할은 올바른 답을 찾는 것임
          + CEO는 결과에 대해 책임을 지며, 노력이나 활동이 아닌 결과로 평가받음
          + VP 레벨에서 진정으로 운영하려면 이 사실을 내면화해야 함
          + 6년 전에 이 글을 읽었더라면 좋았을 것임
          + 당시 회사에서 잘못된 전략을 고수한 것이 문제였음
     * CEO는 노력이나 활동이 아닌 결과로 평가받는다는 주장이 있음
          + 이는 미국 비즈니스 세계의 큰 문제 중 하나임
          + 장기적으로 회사를 망치더라도 ""결과""를 얻으면 계획이 성공적임
          + 단기적으로 회사를 해치더라도 장기적인 이익을 위해서는 실패로 간주됨
          + 장기적인 사고가 부족하고, 숫자만 오르내리는 것을 보는 것임
     * 경력 개발과 급여 협상을 혼동하는 것은 나쁜 것이 아님
          + 소프트웨어 엔지니어에게는 급여 인상이 투명하게 할당되는 방법이 필요함
          + 그렇지 않으면 회사에 가치 있는 사람보다 똑똑하고 영리한 사람들이 보상을 받을 수 있음
     * 많은 사람들이 ""개발""이나 ""레벨링"" 대화를 요청함
          + 그러나 그들은 급여에 대해 이야기하고 싶어함
          + 지식과 성과를 높이는 주된 동기는 더 많은 급여를 받기 위함임
          + 회사에 어떤 가치를 제공해야 더 많은 돈을 벌 수 있는지 알고 싶어함
     * 대부분의 레벨링 시스템은 너무 세분화되어 있음
          + 이는 형식적인 작업이며, 가짜 과학임
          + 비판적 사고 없이 ""사다리 오르기"" 접근 방식을 장려함
     * 회사 간 경력 개발을 일반화하려는 시도가 무의미해 보임
          + 한 회사에서는 ""매니저""가 10명 이상의 직속 보고서를 관리하고 거의 기술 작업을 하지 않음
          + 다른 회사에서는 ""매니저""가 4-5명의 직속 보고서를 관리하고 상당한 기술 작업을 함
          + 회사의 승진 사다리는 회사 규범과 밀접하게 통합되어 있음
     * 매니저는 계획을 실행하고, 작업을 관리하며, 팀을 조정하고 정책과 프로세스를 시행함
     * 디렉터는 문제를 해결하기 위한 계획을 수립하고, 작업을 수용하며, 팀을 조정하고 좋은 프로세스를 만듦
     * VP는 팀이 해결해야 할 문제를 정의하고, 작업의 용량과 예산을 관리하며, 회사 전반의 전략을 조정하고 좋은 정책을 만듦
"
"https://news.hada.io/topic?id=19953","Show GN: 바이브 코딩만으로 교육 챗봇 웹사이트 제작.","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Show GN: 바이브 코딩만으로 교육 챗봇 웹사이트 제작.

Sungblab AI - 교육을 위한 인공지능 플랫폼

   ""AI와 함께 더 나은 교육을 만들어가세요""

  서비스 개요

   Sungblab AI는 교육 분야에 특화된 인공지능 기반 맞춤형 교육 솔루션 플랫폼입니다. 교육자와 학습자를 위한 다양한 AI 도구와 기능을 제공하여 교육 경험을 혁신적으로 개선합니다.

  주요 기능

    1. 최첨단 AI 모델 통합

     * 다양한 AI 모델 지원
          + Anthropic Claude (claude-3-7-sonnet, claude-3-5-haiku)
          + Google Gemini (gemini-2.0-flash)
          + DeepSeek (deepseek-reasoner)
          + Sonar (sonar-pro, sonar, sonar-reasoning)
     * 멀티모달 기능
          + 이미지, PDF 등 다양한 형식의 파일 처리
          + 최대 32MB, PDF 100페이지 지원
          + 최대 3개 파일 동시 업로드

    2. 교육 특화 프로젝트

     * 수행평가 도우미
          + 과제 요구사항 분석 및 아이디어 제공
          + 창의적 답변을 위한 최적화 (temperature 0.7)
          + 평가 기준 고려 및 피드백 제공
     * 생기부 작성 지원
          + 교육부 지침에 맞는 서술형 작성
          + 음슴체 사용 및 바이트 수 제한 준수
          + 구체적 사례 중심의 안정적 답변 (temperature 0.3)

    3. 고급 교육 도구

     * 수학 수식 렌더링 (KaTeX)
     * 코드 실행 환경 (Pyodide)
     * 데이터 시각화 (Chart.js)
     * 마크다운 문서 지원

  기술적 특징

    프론트엔드

     * React 18 + TypeScript
     * Tailwind CSS,
     * PWA(Progressive Web App) 지원
          + 독립 실행형 애플리케이션으로 설치 가능
          + 다양한 디바이스 호환성

    백엔드

     * FastAPI 프레임워크
     * JWT 및 Google OAuth2 인증
     * SQLAlchemy ORM
     * 비동기 처리 및 스트리밍 응답

    보안 및 성능

     * 토큰 사용량 최적화 및 캐싱 시스템
     * 환경 변수 기반 보안 설정
     * CORS 보안 및 API 키 관리
     * 상세한 로깅 및 오류 처리

  사용자 경험

     * 깔끔한 흰색 배경의 인터페이스
     * 브랜드 테마 컬러: #4F46E5 (인디고 계열)
     * 반응형 디자인으로 모든 디바이스 지원
     * 직관적인 교육 도구 제공

  특별한 장점

    1. 교육 현장 맞춤형 설계
          + 수행평가와 생기부 작성에 특화된 AI 프롬프트
          + 교육 과정에 최적화된 도구 제공
          + HTML 로 보고서 만들기 기능 제공
          + 딥 리서치 추후 지원 예정
    2. 효율적인 토큰 관리
          + 입출력 토큰 최적화
          + 캐시 시스템을 통한 비용 절감 (캐시 히트 시 90% 할인)
    3. 확장성과 유연성
          + 다양한 AI 모델 통합
          + 모듈화된 API 구조
          + 지속적인 기능 업데이트
     __________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

   고등학생 3학년이 만든 Sungblab AI는 인공지능 기술을 교육 현장에 효과적으로 접목하여, 교육자와 학습자 모두에게 혁신적인 교육 경험을 제공합니다. 수행평가 준비와 생기부 작성부터 다양한 교육 자료 생성까지, AI의 힘으로 교육의 질을 한 단계 높여보세요.

   https://github.com/Sungblab/Sungblab_AI_backend.git 깃허브 주소

     이 개념은 OpenAI의 공동 창립자이자 전 테슬라 AI 책임자인 안드레이 카르파티(Andrej Karpathy)가 2025년 2월에 처음 제안했습니다. 그는 AI의 제안을 적극 활용하여 코드를 작성하는 방식을 '바이브 코딩'이라고 명명했습니다.

   얼마전부터 긱뉴스에 바이브코딩이 넘처나서 뭔가? 싶었음.
"
"https://news.hada.io/topic?id=19872","웹 폰트의 메모리 안전성 강화","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            웹 폰트의 메모리 안전성 강화

     * Skrifa는 Rust로 작성된 새로운 글꼴 처리 라이브러리로, 기존의 FreeType을 대체해 Chrome에서 글꼴 처리를 보다 안전하게 수행하기 위해 개발됨
     * Rust의 메모리 안전성 덕분에 보안 문제가 줄어들고, 글꼴 기술 개선 속도 향상
     * FreeType에서 Skrifa로 전환하면서 코드 품질이 향상되고 보안 수정 시간 단축

FreeType을 대체하는 이유

     * 웹 환경에서는 신뢰할 수 없는 리소스를 다양한 출처에서 가져와 안전하게 사용할 수 있어야 함
     * Chrome에서는 웹 글꼴을 안전하게 사용하기 위해 여러 보안 조치를 적용하고 있었음
          + 샌드박싱(Sandboxing): 코드가 안전하지 않고 글꼴이 신뢰할 수 없기 때문에 별도의 보호 환경에서 실행
          + OpenType Sanitizer: 글꼴 처리 전에 글꼴을 정리하고 검사
          + 퍼징(Fuzzing): 글꼴 처리 관련 라이브러리를 광범위하게 테스트
     * FreeType은 Android, ChromeOS, Linux에서 기본 글꼴 처리 라이브러리로 사용됨
          + 보안 취약점이 발생하면 많은 사용자에게 영향을 미칠 위험 존재

FreeType에서 발생한 주요 보안 문제

     * 1. 안전하지 않은 언어 사용
          + FreeType은 C로 작성되었기 때문에 메모리 오류 및 버퍼 오버플로 등의 보안 취약점 발생 가능
     * 2. 프로젝트별 문제
          + 매크로 사용으로 인한 명시적 크기 타입 부족
               o 매크로(FT_READ_*, FT_PEEK_*)가 명시적 크기 타입(int16_t 등)을 숨김
          + 새로운 코드에서 반복적으로 버그 발생
               o COLRv1 및 OT-SVG 지원 추가 시 문제 발생
          + 테스트 부족
               o 복잡한 테스트 글꼴 생성이 어려워 테스트 부족 문제 발생
     * 3. 의존성 문제
          + FreeType이 사용하는 bzip2, libpng, zlib 등의 라이브러리에서 반복적인 문제 발생
     * 4. 퍼징의 한계
          + 글꼴 파일은 복잡한 데이터 구조로 인해 퍼징에서 발견되지 않는 문제 발생
               o 글꼴은 복합적인 규칙과 상태 기계(state machine)를 포함
               o 유효한 구조 생성이 어려워 효과적인 퍼징 진행이 어려움

Skrifa의 도입 및 Chrome 적용 과정

     * Chrome에서 사용하는 그래픽 라이브러리 Skia는 글꼴 메타데이터 및 렌더링에 FreeType을 사용
     * Chrome은 FreeType을 Skrifa로 교체하기 위해 Skia의 글꼴 백엔드를 새로 구축

Skrifa 도입 단계

     * Chrome 128 (2024년 8월):
          + 컬러 글꼴 및 CFF2와 같은 덜 사용되는 글꼴 형식에 대해 Skrifa 시범 적용
     * Chrome 133 (2025년 2월):
          + Linux, Android, ChromeOS에서 웹 글꼴 처리에 Skrifa 전면 도입
          + Windows 및 Mac에서는 시스템이 글꼴 형식을 지원하지 않을 때 대체 처리기로 사용

보안 및 성능 강화

     * 1. 메모리 안전성 강화
          + Rust는 기본적으로 메모리 안전성을 보장함
          + 다만, 성능을 위해 bytemuck 라이브러리 사용
               o 강력한 타입 구조로 바이트 재해석 필요 시 사용
               o Rust의 향후 업데이트에서 안전한 변환이 가능해지면 해당 기능으로 전환 예정
     * 2. 정확성 개선
          + Skrifa는 데이터 구조의 불변성(immutable) 보장을 통해 코드 가독성, 유지보수성 및 멀티스레딩 성능 강화
          + 약 700개의 유닛 테스트로 코드 품질 검증
          + fauntlet 도구를 사용해 FreeType과 Skrifa의 출력 비교 → 화질 품질 일치 여부 확인
     * 3. 광범위한 테스트 및 보안 강화
          + Skrifa 및 통합 코드에 대해 2024년 6월부터 퍼징 테스트 진행
               o 현재까지 39개의 버그 발견 → 보안 취약점은 아님 (시각적 오류 혹은 제어된 충돌)
               o 보안 문제로 이어지지 않는 코드 품질 개선 확인

결론 및 향후 계획

     * Rust 기반 Skrifa 도입으로 보안 강화 및 코드 품질 개선 효과
     * 개발 생산성 향상 및 사용자에게 더 안전한 글꼴 환경 제공
     * 향후 Linux 및 ChromeOS의 시스템 글꼴 처리에 Skrifa 적용 계획

   저번에는 zlib, 이번에는 freetype…
   고인물들이 하나둘씩 밀려나는건… 사람 사는 세상이랑 비슷하네요

        Hacker News 의견

     * Google에서 fuzzing으로 발견된 문제를 해결하는 데 최소 0.25명의 소프트웨어 엔지니어가 필요함
          + 이러한 추가 작업을 측정하는 방식이 마음에 듦
          + FreeType을 사용하지 않더라도 TTF 힌팅 명령을 완전히 사용할 수 있는 방법이 있기를 바람
          + Windows와 macOS는 더 이상 적절한 힌팅을 활성화할 방법이 없는 것 같음
          + FreeType도 2.7 버전 이후로 부적절한 힌팅을 기본값으로 설정함
          + 적절히 힌팅된 텍스트가 어떻게 보이는지 궁금하다면 스크린샷을 참조할 수 있음
          + Windows는 XP 이후로 폰트 힌팅을 포기한 것으로 의심됨
          + UI 스케일링과 다양한 해상도의 화면에서 래스터 이미지를 보는 것이 흐릿함을 유발함
     * Rust의 진정한 힘은 안전성을 향한 점진적인 전환과 기존 프로젝트에 통합될 수 있는 능력임
          + 대규모 재작성 없이 구성 요소를 하나씩 마이그레이션할 수 있음
     * 폰트가 모니터 패널의 서브픽셀 레이아웃에 따라 렌더링되는 방식에 대해 배우고 있음
          + Windows는 모든 패널이 RGB 레이아웃을 사용한다고 가정하고 ClearType 소프트웨어가 그 가정에 따라 폰트를 렌더링함
          + 새로운 디스플레이 유형에서는 텍스트 프린징이 발생함
          + MacType이나 Better ClearType Tuner 같은 타사 도구가 존재하지만 Chrome이나 Electron에서는 작동하지 않음
          + 새로운 패널 기술이 보편화되면서 서브픽셀 레이아웃을 그래픽 레이어에 전달하는 표준을 정의하는 노력이 필요함
          + Blur Busters에서 일부 노력이 보이지만 공급업체의 인식은 아직 부족함
     * Skia는 고급 텍스트 레이아웃을 수행하고 글리프를 캐시하는 고급 라이브러리임
          + Skia는 C++로 작성되었으며 Google에서 만듦
          + FreeType은 글리프를 측정하고 렌더링하며 다양한 안티앨리어싱 모드와 힌팅을 지원함
          + FreeType은 C로 작성되었으며 Google에서 만든 것이 아님
          + 왜 FreeType이 먼저 Rust로 재작성되었는지 궁금함
     * 글꼴은 OpenType Sanitizer를 통해 처리되기 전에 통과됨
          + 글꼴 형식이 그렇게 나쁜지 파일을 소독해야 하는지 궁금함
          + 정수 오버플로가 취약성의 원인 중 하나로 식별됨
          + 많은 언어가 오버플로를 감지하지 않으며, RISC-V 같은 현대 아키텍처도 오버플로 트랩을 포함하지 않음
          + Rust 같은 새로운 언어가 오버플로 트랩을 포함하지 않는 이유를 이해할 수 없음
"
"https://news.hada.io/topic?id=19931","JEP 467: Markdown 문서 주석","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        JEP 467: Markdown 문서 주석

  목표

   Java의 문서 주석에서 Markdown 문법을 지원하여 가독성 향상 및 간결한 문서 작성 유도.

  동기

     * 기존 JavaDoc은 HTML 태그에 의존 → 너무 장황하고 읽기 어려움.
     * 개발자들은 이미 README, GitHub 등에서 Markdown에 익숙.
     * Markdown 지원으로 일관성 있고 간결한 문서 작성 가능.

  설명

     * CommonMark 기반 Markdown 문법을 JavaDoc 주석 내에서 지원.
     * 기존 HTML 주석도 여전히 사용 가능.
     * 기존 /* ... */ 방식의 주석 대신 /// 를 사용하여 마크다운 문서 주석임을 표기
     * 3rd-party JavaDoc 툴이 Markdown을 파싱하고 렌더링 처리.

  Markdown 사양

     * CommonMark 기반.
     * 지원하는 문법:
          + 제목(#, ##, ### 등)
          + 목록 (순서/비순서)
          + 코드 블록 (```)
          + 링크
          + 표 (Github Flavored Markdown 방식)
          + 인용문
          + 강조 (*기울임*, **굵게**)

  Java 전용 태그

   Markdown과 함께 기존 JavaDoc @-태그 사용 가능:
     * @param
     * @return
     * @throws
     * @see
     * @since
     * @deprecated

   훌륭합니다...

   표준에 반영되었나 보군요

   JDK23에 들어갔습니다.
   테스트 해보니 프로젝트의 JDK 버전이 23미만이어도 IDE나 자바독 EXPORT 툴이 지원하면 정상적으로 동작합니다.
"
"https://news.hada.io/topic?id=19886","프랑스, 백도어 요구 법안 거부 – 암호화의 승리","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      프랑스, 백도어 요구 법안 거부 – 암호화의 승리

     * 프랑스 하원이 암호화된 메시징 플랫폼에 백도어를 강제하는 법안을 거부함
     * 이 법안은 마약 밀매와의 싸움을 명분으로 제안되었으나 개인 통신의 사생활 보호를 심각하게 침해할 위험이 있었음
     * 법안 통과 시, Signal 및 WhatsApp 같은 플랫폼이 사용자 간 비밀 대화를 당국이 은밀히 감시할 수 있도록 강제됨
     * 이 투표는 디지털 권리, 개인 정보 보호, 보안 및 상식의 승리

법안의 문제점

     * 이 법안은 사실상 감시를 위한 요구사항을 숨긴 반암호화 법안
     * 핵심 문제: ""고스트 참여자 모델(Ghost participant model)"" 부활 시도
          + 보안 기관이 사용자 모르게 암호화된 대화에 침투 가능하도록 함
          + 보안 전문가들은 이 모델이 시스템 취약점을 초래하고 사용자 신뢰를 훼손할 것이라고 경고
          + 이 모델은 해커와 악의적 행위자에게 악용될 위험이 높음

프랑스 하원의 현명한 판단

     * 프랑스 하원은 기술 전문가 및 디지털 권리 옹호 단체의 의견을 수렴
     * 프랑스 디지털 권리 단체(La Quadrature du Net)와 사이버 보안 전문가들이 법안의 위험성을 경고함
     * 암호화는 활동가, 기자, 의료 전문가, 학대 피해자, 일반 시민 등 모두의 프라이버시 보호에 필수적임을 인식

글로벌 메시지: 암호화는 권리 보호 도구

     * 프랑스의 이번 결정은 전 세계 입법자들에게 중요한 메시지를 전달함
          + 암호화는 기본 인권을 보호하는 도구
          + 사생활 보호와 공공 안전은 공존할 수 있음
          + 암호화를 약화시키는 것은 보안을 강화하는 것이 아니라 오히려 위험을 증가시킴
     * 미국, 영국, 호주 등 여러 국가에서 반암호화 법안이 계속 논의 중
          + 프랑스의 이번 결정은 다른 국가에 경고이자 모델이 될 수 있음

이번 승리의 의미와 앞으로의 과제

     * 이번 거부는 지속적인 대중의 압박, 전문가의 의견 제시 및 시민 사회의 적극적인 활동 덕분에 가능했음
     * 하지만 정부와 보안 기관의 백도어 요구는 계속될 가능성 높음
          + 비슷한 법안이 새로운 형태로 다시 등장할 수 있음
          + 이를 막기 위해 지속적인 경계와 대응 필요

오늘의 승리를 기념하고, 내일을 대비하자

     * 오늘은 암호화와 디지털 권리의 승리를 축하할 날
     * 그러나 프라이버시 옹호자들은 앞으로도 경계를 늦추지 말아야 함
     * 암호화는 개인의 자유와 안전을 지키는 핵심 도구임을 잊지 말아야 함
"
"https://news.hada.io/topic?id=19933","Project Aardvark: AI 기반 날씨 예측의 혁신","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Project Aardvark: AI 기반 날씨 예측의 혁신

     * 정확한 날씨 예측은 농업, 교통, 에너지 등 여러 분야에서 중요한 역할을 함
     * 홍수나 폭염과 같은 극단적 기후 상황에서 경고 시스템의 역할 수행
     * Huawei의 Pangu-Weather와 Google DeepMind의 GenCast 같은 AI 기반 예측 시스템이 등장하면서 AI 날씨 예측에 대한 기대감이 높아짐
     * Turing Institute에서는 AI를 이용한 날씨 예측 기술 개발에 집중하고 있으며, 이를 통해 새로운 세대의 AI 기반 예측 시스템 Aardvark를 개발 중임

  현재의 날씨 예측 방식

     * 현재 날씨 예측은 수치 기상 예측(Numerical Weather Prediction, NWP) 방식에 기반함
     * NWP는 다음과 같은 3단계로 이루어짐:
          + 1단계: 위성, 기상 관측소, 기상 풍선, 선박, 비행기 등에서 정보를 수집해 대기 상태를 추정
          + 2단계: 복잡한 컴퓨터 모델을 사용해 현재 상태에서 미래 상태로 발전시킴
          + 3단계: 예측 결과를 가공하고, 위치별 정확도를 보정하며, 인간 기상 예보자의 입력 반영
     * 이 과정은 고성능 슈퍼컴퓨터와 대규모 인력 및 복잡한 소프트웨어가 필요함
     * 선진국에서는 이러한 시스템 운용이 가능하지만, 개발도상국에서는 인프라 부족으로 운용이 어려움

  Aardvark의 혁신적인 접근 방식

     * Aardvark는 전체 예측 과정을 하나의 AI 모델로 대체
     * 데스크톱 컴퓨터에서 훈련 및 실행 가능하며, 예측 속도가 기존 방식보다 수천 배 빠름
     * 위성, 기상 관측소, 기상 풍선 등 다양한 출처에서 데이터를 수집해 10일 간의 전 세계 기상 예측 수행
     * 복잡한 데이터 처리 및 결측값 보완을 위한 새로운 딥러닝 아키텍처 도입
     * Aardvark의 장점:
          + 개발도상국에서도 운용 가능 → 슈퍼컴퓨터 필요 없음
          + 예측의 정확성과 효율성이 높아짐
          + 날씨 예측에 소요되는 에너지 절감으로 탄소 배출 감소 가능

  Aardvark의 성능 및 가능성

     * 현재 Aardvark는 미국의 Global Forecast System(GFS) 와 비슷한 수준의 정확도를 보임
     * 현재 사용 가능한 데이터의 약 10%만 사용 중 → 더 많은 데이터를 사용할 경우 정확도 향상 가능성 높음
     * 기존의 수치 예측 모델을 대체할 가능성
     * 빠른 예측 속도로 신속한 기후 대응 가능
     * 개발도상국 및 데이터 부족 국가에서 고급 예측 도구 제공 가능

  도전 과제

     * AI 기반 예측 도구는 아직 실험 단계이며, 장기적인 검증이 필요함
     * 허리케인, 홍수 등 극단적 기후 현상 예측이 특히 어려움
     * 과거 데이터를 기반으로 훈련된 모델이기 때문에 기후 변화로 인한 오차 발생 가능성 존재
     * 희소한 기후 현상 데이터 부족 문제 해결 필요

  Aardvark의 미래 계획

     * Turing Institute는 Aardvark를 통해 기상, 해양, 해빙 예측 분야의 정밀도 향상을 목표로 함
     * 특히 개발도상국 및 북극 지역에서의 적용을 중점 추진
     * 데이터 확장 및 아키텍처 최적화를 통해 극단적 기후 현상 예측 강화 계획
     * 장기 예측 및 계절별 예측 기능 추가 → 정부 및 기업의 장기 기후 계획 지원
     * AI 기반 날씨 예측 기술의 발전으로 사회적 혜택 및 경제적 보호 강화 기대

  결론

     * Aardvark는 날씨 예측의 패러다임을 바꿀 혁신적인 시스템임
     * 개발도상국의 기후 대응 역량 강화 및 예측 정확도 향상 가능성 높음
     * Turing Institute는 Aardvark를 통해 영국이 기후 예측의 최전선에 서도록 주도할 계획임
     * Aardvark의 자세한 내용은 Nature 논문에서 확인 가능

        Hacker News 의견

     * ""The Turing Institute? 아직도 존재하나?""라는 생각이 들었음
          + 글래스고에 있었던 이전의 Turing Institute는 AI 연구를 했으며, 1994년에 끝을 맺었음
          + 그곳에서 흥미로운 연구들이 나왔지만, 지금의 기관과는 다름
     * 수십 년간의 역사적 데이터를 저장하고 있는지 궁금함
          + AI 알고리즘이 과거 데이터를 통해 기존 방법과 성능을 비교할 수 있는지
          + 금융 기술 알고리즘이 과거 주식 시장 데이터를 통해 평가되는 방식과 유사함
     * 모델에 도전 과제를 제시함
          + 캔자스시티 메트로 지역의 2일 이상 날씨 예측을 정확히 하는 것
          + 2024년 기준으로는 드물게 정확했음
     * 미래의 가상의 AGI 에이전트가 인간이 공의 궤적을 본능적으로 아는 것처럼 날씨를 예측할 수 있을지 궁금함
          + AI가 내일의 날씨를 정확히 알지만, 그 지식이 어떻게 도출되었는지는 이해하지 못할 수 있음
     * 논문은 여기에서 확인 가능함
     * 모든 단계를 대체한다는 것이 과장인지, 아니면 내가 뉘앙스를 놓친 것인지 알 수 없음
          + 모델이 데이터 수집 단계를 어떻게 대체할지 궁금함
     * 날씨 풍선과 같은 데이터 수집 장비에 대한 자금 지원이 중단된 것이 아쉬움
     * 허리케인이나 드문 극한 날씨와 같은 엣지 케이스를 어떻게 처리할지 궁금함
     * 아버지가 해풍과 강수량 모델링에 대한 광범위한 연구를 했으며, 이러한 AI와 기계 학습의 발전을 보셨으면 좋았을 것임
     * 급격한 기후 변화의 세계에서 과거가 더 이상 미래를 예측하지 못할 때, 기계 학습 모델이 얼마나 견고할지 궁금함
"
"https://news.hada.io/topic?id=19887","IronRDP - Microsoft RDP(원격 데스크탑)의 Rust 구현체 ","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               IronRDP - Microsoft RDP(원격 데스크탑)의 Rust 구현체

     * Rust로 작성되어 안정적이고 성능이 강화된 Microsoft Remote Desktop Protocol(RDP) 구현
          + 보안에 중점을 둔 고성능 오픈소스 라이브러리(Cargo 모음)
     * 비동기 I/O 기반 완전한 RDP 클라이언트 제공 → 다양한 사용 사례에 유연하게 적용 가능
     * 다양한 비디오 코덱 및 그래픽 형식 지원
          + 비압축 원시 비트맵
          + Interleaved RLE 비트맵 코덱
          + RDP 6.0 비트맵 압축
          + Microsoft RemoteFX (RFX)
     * 간단한 코드베이스로 쉽게 클라이언트 개발 가능

   이러다가 라면도 러스트로 끓이겠네....
   저는 물론 좋습니다 ㅎㅎ

        Hacker News 의견

     * MS RDP가 최고의 원격 데스크톱 클라이언트 및 프로토콜이라고 생각함. 성능이 매우 뛰어나고, 95%의 컴퓨터에서 쉽게 이용 가능함. 멀티 모니터 지원도 훌륭함. 유일한 단점은 Microsoft 제품이라는 점임
     * Rust에서 Iron으로의 전환을 이해하지만, Iron이라는 접두사를 보면 dotnet이 떠오름. 이는 ironlanguages와 ironsoftware 때문임
     * RDP와 기능이 완전히 동일한지 궁금함. 지난 15년 동안 RDP와 로컬에서 거의 동일한 시간을 보냈음. 사무실에서도 블레이드에 RDP를 사용하고, 집에서는 강력한 워크스테이션에 노트북을 연결함. 최근 원격 근무로 인해 더 많이 사용하고 있음. Linux 데스크톱을 시도했지만 열등한 RDP 대안 때문에 포기했음. RDP의 작은 디테일들이 훌륭함을 깨달음
     * README의 데모는 독립적인 구현으로 인상적임. 하지만 저장소에 서버 코드가 포함되어 있는 것을 발견함. Proxmox 같은 도구가 VNC나 SPICE보다 더 효율적인 대안으로 사용할 수 있을지 궁금함
     * RDP를 사랑함. 정말 인상적인 기술임. 사무실에서 일할 때, 회의실 클라이언트에서 내 책상 노트북으로 RDP를 사용하면 네이티브 성능을 제공함. 오디오도 포함됨. Linux에서 최고의 원격 데스크톱 서버는 무엇인지 궁금함
     * 우연히도 오늘 Cloudflare가 클라이언트 없는 브라우저 기반 RDP 지원을 발표함. IronRDP를 사용하고 있는 것 같음
     * RDP의 Rust 구현을 보는 것이 흥미로움. 프로토콜에는 많은 특이점과 엣지 케이스가 있어 올바르게 구현하기 어려움. 특히 인증과 세션 관리 부분에서 어려움. 보안에 중점을 두는 것은 좋음. RemoteFX와 같은 독점 확장을 어떻게 처리하는지 궁금함. Microsoft 스택에 의존하지 않는 크로스 플랫폼 RDP 구현의 견고한 기반이 되기를 바람
     * Wayland 지원이 있는 Linux 클라이언트를 알고 있는지 궁금함. 시도한 모든 클라이언트에서 아티팩트가 발생함
     * 서버를 구현하는지, 클라이언트만 구현하는지 궁금함. Linux인지 궁금함
     * 훌륭함. 지원이 종료된 Mac OS 에디션을 위해 macports를 통해 클라이언트를 실행해봐야겠음. 공식 클라이언트의 마지막 버전이 가끔 RAM을 많이 사용하며 충돌함. 스마트 카드 지원을 클라이언트에 통합하고 싶음. 하드웨어를 호스트로 전달하는 대신, 일반 원격 UI를 통해 PIN을 입력하는 것이 불안함
"
"https://news.hada.io/topic?id=19969","코딩은 프로그래밍이 아니에요 ","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            코딩은 프로그래밍이 아니에요

     * Leslie Lamport는 LaTeX의 초기 개발자이며 분산 시스템 분야의 선구자. 2013년 튜링상 수상
     * 그가 SCaLE 22x 키노트에서 추상화의 중요성을 강조하며, 대부분의 프로그래머가 코딩과 언어에 몰두하지만, 코딩 전 추상적 사고와 설계가 핵심임을 지적함

발표 요약

     * 여러분은 내가 동시성(Concurrency)에 대해 얘기하는 걸 기대할 수 있으나, 이에 대해 새롭게 말할 것이 없음
     * 그러나 ""Concurrent한 프로그램 작성""에 대한 통찰이 일반적인 모든 프로그래밍에도 적용됨
     * 이 발표는 프로그래밍 전반에 관한 이야기임

알고리듬 vs. 프로그램

     * 알고리듬: 언어와 무관한 추상적 아이디어. 프로그램보다 더 추상적이고 상위 수준의 개념
     * 프로그램: 알고리듬을 특정 언어로 구현한 구체적인 형태. 프로그래밍 언어는 알고리듬을 표현하기에 너무 복잡함
     * 알고리듬은 실행되지 않으며, 일반적으로 짧고 간단함
     * 특히 동시성 관련 코드에서는 먼저 정확한 알고리듬을 정의하고 구현해야 함

배열 최대값 예제로 보는 추상화

     * 단순한 문제라도 ""무엇을 할 것인가(What)""를 명확히 정의해야 함
     * 예: ""정수 배열의 최대값 반환"" → ""모든 원소 이상인 최소 수 반환""
     * 비어 있는 배열 처리도 사전에 정의 필요 (예: -∞ 사용)
     * 이렇게 명확한 정의를 통해 더 간단하고 견고한 알고리듬(How) 을 도출 가능

프로그램 실행은 상태의 흐름

     * 프로그램 실행은 단순한 명령 순서가 아닌, 상태(state)의 연속
     * 각 상태 전이는 코드의 한 부분 실행을 의미함
     * 이러한 시각은 알고리듬의 올바름을 증명할 때 중요함 (불변식 사용 등)

복잡한 시스템을 위한 도구: TLA+

     * 추상화를 정밀하게 표현하기 위해 정확한 언어가 필요
     * TLA+는 그런 용도로 설계된 도구
     * Amazon Web Services는 TLA+로 심각한 설계 결함을 사전에 발견
     * Rosetta 우주선의 OS인 Virtuoso도 TLA+ 기반으로 설계, 코드가 간결하고 안정적이었음

불완전한 사양에서도 추상화의 역할

     * 예: 프리티 프린터는 정렬 기준이 주관적일 수 있음
     * 그럼에도 불구하고 추상화된 규칙 세트를 정해두는 것이 디버깅과 유지보수에 중요

글쓰기와 사고의 관계

     * 생각을 글로 적는 것이 사고를 명확하게 해줌
     * 추상화는 단순히 머리로만 하는 게 아니라 글로 표현해야 효과적
     * Lamport는 자신의 수학적 훈련이 추상화 능력을 길러줬다고 언급
     * 수학자들이 프로그래머에게 추상화를 가르칠 수 있음

라이브러리와 버그에 대한 시각

     * 발표 2부 ""왜 프로그램은 버그를 가져야 하는가""에서 복잡성 문제를 다룸
     * 현대 소프트웨어는 많은 라이브러리에 의존하지만, 이들은 정확한 언어 독립적 설명이 부족
     * 이로 인해 통합 과정에서 예상치 못한 버그가 발생
     * 예: 본인의 TLA+ 강좌 사이트에서 JavaScript 디버깅 경험
     * 상태 기반 시각이 이러한 복잡성을 이해하는 데 유용

질의응답에서 다룬 주제들

     * AI가 추상화에 미칠 영향
     * 오픈소스와 학계의 단절
     * 개발자들이 형식 정의(formal definition)를 소홀히 하는 현실
     * 여전히 가장 중요한 것은 ""코딩 전에 생각하기""

결론: 프로그래밍의 본질은 사고

     * Lamport는 단순한 코딩보다 추상적 사고와 형식적 사양을 우선시해야 한다고 주장
     * upfront 노력이 크지만, 결과적으로 더 견고하고 유지보수하기 쉬운 소프트웨어로 이어짐
     * 코딩은 프로그래밍의 일부일 뿐, 진짜 프로그래밍은 정확한 알고리듬과 추상화에서 시작
     * 시스템 복잡성과 동시성이 증가하는 현대에서 추상화는 필수 역량 이며, 사고하고 추상화하는 훈련이 프로그래머에게 필요함

   저도 이 글에 공감합니다
   추상화 된 상태 값들로 문제 정의하는게 문제 발견에 유용하다 보고 있고 다이어그램 등으로 상태시각화나 언리얼 블루프린트나 워크 플로우 같이 시각적 명시적 으로 분명한 상태 관리 툴을 만들려하고 있는데

   언어를 먼저 봐야겠네요

   계산이론 전공 수업이 생각나는 글입니다! 프로그래밍 하는분들께 공부해보길 추천드려요.

   TLA 가 뭔지 궁금하네요
   찾아봐야겠어요

   저도 궁금해서 찾아봤습니다.
   TLA+ - 프로그램 및 동시/분산 시스템을 모델링하기 위한 고급 언어

        Hacker News 의견

     * 데모 씬의 '코더'들은 자신들을 그렇게 부르며 자부심을 느끼고, 이들은 종종 뛰어난 '프로그래머'와 '소프트웨어 엔지니어'이기도 함. 코더, 프로그래머, 소프트웨어 엔지니어 등 어떤 이름을 사용하든, 중요한 것은 컴퓨터가 원하는 대로 작동하게 만드는 것임
     * 다음 해의 키노트는 '바이빙은 코딩이 아니며, 프로그래밍도 아니며...; 가끔은 조금 작동하는 쓰레기의 피라미드'일 것 같음. Dijkstra가 이를 보지 않아 다행임. 그는 80년대에 부모님 거실에서 화가 났었음. '바이브 코딩'을 보면 어떤 반응일지 상상도 할 수 없음
     * Leslie Lamport의 SCaLE 22x 키노트: 생각하고, 추상화하고, 그 다음 코딩하기. Lamport는 코딩 전에 생각과 추상화를 강조하는 프로그래밍 접근 방식의 근본적인 변화를 주장했으며, 이는 모든 비사소한 코드에 적용됨
          + 추상화 우선: 코드를 작성하기 전에 프로그램의 추상적 관점을 정의함. 이 고수준 설계는 논리를 명확히 하고 오류를 조기에 발견함. 특정 언어가 아닌 아이디어에 집중함
          + 알고리즘 != 프로그램: 알고리즘은 추상적 개념이며, 프로그램은 구체적 구현임
          + 상태로서의 실행: 프로그램 실행을 상태의 연속으로 모델링하며, 각 상태의 미래는 현재에만 의존함. 이는 특히 동시성에서의 추론을 단순화함
          + 불변성의 중요성: 모든 실행 상태에 대해 참인 속성인 불변성을 식별함. 이를 이해하는 것이 정확성에 필수적임
          + 명확한 명세의 중요성: 많은 라이브러리 프로그램이 명확한 명세가 부족하여 올바른 사용을 방해함. 특히 동시성에서 기능의 명확하고 언어 독립적인 설명이 필요함
          + 글쓰기는 사고임: 글쓰기는 명확성을 강요하고 부주의한 사고를 드러냄. 사고는 글쓰기를 개선함. 이는 선순환임
          + 추상화 배우기: 추상화는 수학의 핵심 기술이며, 프로그래머는 이 능력을 개발해야 함
          + AI를 통한 추상화? AI 모델이 프로그래밍에서 추상적 사고 과정을 위해 활용될 수 있는지에 대한 질문이 제기됨
     * 프로그래밍은 신중한 설계(추상화) 후 구현(코딩)을 따르는 의도적인 과정이어야 하며, 명확한 명세와 상태 연속 및 불변성을 통한 프로그램 행동 이해에 중점을 둬야 함. 생각하는 것이 항상 더 나음
     * 수학 교수는 개념을 더 정확하고 기계가 읽을 수 있는 형태로 변환하는 모든 행위를 코딩이라고 부름. 프로그래밍 언어로 컴퓨터가 하기를 원하는 것을 쓰는 것뿐만 아니라 데이터를 인코딩하는 것도 포함됨. ""인코드""라는 단어가 이를 명확히 함. 이진 트리를 자연수로 변환하는 코딩 방식을 정의하는 과제를 줌. 코딩이라는 단어는 너무 모호하여 많이 사용하지 않음
     * Lamport는 ""무엇""과 ""어떻게""를 분리해야 한다고 주장함. 그러나 대부분의 문제에서 프로그램의 ""무엇""과 ""어떻게""가 어느 정도 합쳐지지 않나 궁금함. 예를 들어, 성능 고려사항은 ""무엇""의 일부인가, ""어떻게""의 일부인가?
     * 흥미로운 요약: 알고리즘은 프로그램이 아니며 프로그래밍 언어로 작성되어서는 안 되며 단순해야 함. 반면 프로그램은 잠재적으로 큰 데이터셋에서 빠르게 실행해야 하므로 복잡해야 함. 특히 여러 CPU에서 실행되는 동시 프로그램의 실행 순서가 다르기 때문에 논의됨
     * 코딩 전에 생각이 필요한 코드, 코드를 읽고 싶지 않은 사람이 사용할 코드로 프로그램을 정의함. 이 강연은 오래전부터 진행되어 왔음. 가장 작은 항목을 찾는 것을 단순화하는 예시가 John Ousterhout의 책에서 ""Define Errors Out of Existence""와 정확히 일치함
     * 댓글 섹션이 메시지를 이해하지 못하는 사람들로 주로 채워져 있는 아이러니를 즐기고 있음. Leslie Lamport의 핵심은 추상적 사고 능력을 개발하는 것이 더 나은 프로그램으로 이어진다는 것임. 수학적 및 논리적 의미에서의 추상화는 모든 관련 없는 세부 사항을 제거할 수 있게 해줌. AI가 안내하는 소프트웨어 개발도 마찬가지임
     * 엄격함이 관련된 모든 것에서 예상할 수 있듯이, 많은 사람들이 제목만 읽고 부정적인 반응을 보임. Hacker News의 해커는 문제를 해결할 수 있는 숙련된 프로그래머일 수 있음. 이제는 ""You're a Hack""이라는 의미로, 무능하고 저품질 결과를 만드는 사람일 수도 있음
     * 이 강연과 논의는 지나치게 세세함
     * 현재 ACM에 좋은 기사가 있으며, 추상화가 무엇인지에 대해 동의하지 않지만, 그럼에도 불구하고 매우 유용하다는 내용임. 중요한 점이 어디에 있는지 대체로 동의함. 정확히 무엇인지, 왜 중요한지에 대해서는 동의하지 않음. 영감을 많이 받을 수 있으며, 이는 자체적으로 가치가 있음
     * 해킹은 코딩이 아니며, 프로그래밍도 아니며, 소프트웨어 개발도 아니며, 소프트웨어 엔지니어링도 아님. 그러나 결국 많은 사람들이 이 용어들을 거의 교환 가능하게 사용하며, 개인적으로 사용하는 정의의 차이를 강조하는 것은 거의 생산적인 시간 사용이 아님
"
"https://news.hada.io/topic?id=19891","OS 개발에 관한 작은 책","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             OS 개발에 관한 작은 책

     * x86 운영 체제를 직접 개발하는 방법에 대한 실용적인 가이드
     * 기술적 세부 사항을 제공하면서도 코드 예제나 샘플을 통해 너무 많은 정보를 공개하지 않도록 작성
     * 운영 체제의 이론이나 특정 운영 체제의 작동 방식에 대해 설명하지 않음
     * 초반 챕터는 상세하고 구체적으로 설명해 코드 작성에 빠르게 익숙해질 수 있도록 함
     * 후반 챕터는 개념과 요구사항을 개략적으로 설명하고, 구현과 설계는 독자가 수행하도록 유도함
     * 운영 체제 이론에 대한 학습이 필요하다면 Andrew Tanenbaum의 Modern Operating Systems 추천

주요 챕터 내용

     * 초반 챕터
          + 2~3장: 개발 환경 설정 및 가상 머신에서 OS 커널 부팅 → C 언어로 코드 작성 시작
          + 4장: 화면 출력 및 시리얼 포트 출력
          + 5장: 세그멘테이션
          + 6장: 인터럽트 및 입력 처리
     * 기능적인 커널 개발 이후 과정
          + 7장: 사용자 모드 애플리케이션 지원 준비
          + 8~9장: 페이징을 통한 가상 메모리 설정
          + 10장: 메모리 할당
          + 11장: 사용자 애플리케이션 실행
     * 고급 주제
          + 12장: 파일 시스템
          + 13장: 시스템 콜
          + 14장: 멀티태스킹

책의 배경 및 개발 과정

     * 이 책과 OS 커널은 스웨덴 Royal Institute of Technology의 고급 개별 과정을 통해 개발됨
     * 저자들은 이전에 OS 이론 과목을 수강했지만, 실제 커널 개발 경험이 부족했음
     * 이론을 실제로 구현하고 더 깊이 이해하기 위해 새로운 과정을 개설하고 이 책을 집필함
     * x86 아키텍처는 오랜 기간 가장 널리 사용된 하드웨어 아키텍처이며, 방대한 참고 자료와 에뮬레이터가 존재함
     * 하드웨어 세부사항에 대한 문서화는 복잡하고 이해하기 어려운 경우가 많았음

개발 방식

     * 약 6주 동안 풀타임으로 작업
     * 작은 단계로 구현하고 매 단계마다 수동 테스트 수행 → 버그 원인 파악 용이
     * 페어 프로그래밍(pair programming) 을 통해 대부분의 코드 작성 → 버그 감소 효과 기대

대상 독자

     * 다음과 같은 배경 지식이 있는 독자에게 적합함:
          + UNIX/Linux 및 시스템 프로그래밍에 익숙함
          + C 언어에 익숙함
          + 컴퓨터 시스템 및 16진수 표기법 등에 대한 이해가 있음
     * 초보자도 학습 도구로 사용할 수 있지만 난이도가 높음

        Hacker News 의견

     * osdev를 사랑함. 최종 목표는 모르지만 원하는 것을 만들 수 있다는 점이 정말 멋짐
          + 기본적인 x86 인터럽트와 시스템 호출을 작동시켰을 때 모든 것이 이해됨
          + 시스템 호출을 시작하면 세상이 나의 것임
          + 취미로 OS를 만져보는 것을 강력히 추천함
          + Rust를 배우는 기회로 사용했고 기대 이상의 것을 얻음
          + 이제 Rust에 어느 정도 익숙해졌고 대부분의 사람들보다 더 많은 이중 및 삼중 오류를 던질 수 있음
     * 많은 사람들이 자신이 좋아하는 대안을 추천하는데, 나는 여전히 Project Oberon의 큰 팬임
          + 2025년 컴퓨팅에는 적합하지 않을 수 있지만, 메모리 안전 시스템 언어로 작성된 작은 그래픽 기반 OS임
          + OS 개발에 대해 배울 수 있는 충분한 콘텐츠가 있음
          + Project Oberon 웹사이트
     * 이 책은 osdev 튜토리얼의 고전적인 결함을 가지고 있음
          + x86 세부사항에 대한 많은 설명이 있지만 osdev에 대한 내용은 거의 없음
          + x86 세부사항은 osdev가 아님
          + 기본 OS가 처리해야 할 것의 극히 작은 부분임
     * 내가 가장 좋아하는 OS 책은 Operating Systems: Three Easy Pieces임
          + 개발보다는 작동 방식에 대한 내용이 많음
          + HTML과 PDF 형식으로 무료로 제공되며 인쇄된 책도 판매함
          + OSTEP 웹사이트
     * 감사합니다! 이 주제에 대한 훌륭한 자료처럼 보임
          + 십대 때 만든 ""OS""의 소스 코드를 아직 가지고 있었으면 좋겠음
          + MBR 부트 로더 작성, 보호 모드 전환, 화면에 문자 표시, 키보드 입력까지 작성함
          + 재미있는 도전을 찾고 있다면 강력히 추천함
     * 이 댓글은 2000년대로의 향수를 불러일으킴
          + planet-source-code.com이라는 웹사이트가 개발자 커뮤니티에서 인기가 있었음
          + 회원들이 작성한 수백 개의 미니 운영 체제가 있었음
          + 대부분 C/C++와 어셈블리로 부트로더가 작성되었고, Mingw32로 컴파일되었으며, 일반 플로피 디스크에서 부팅됨
     * 책은 좋음. GitHub의 이슈를 살펴보면 좋겠음
          + 수정이 필요한 부분이 있음
          + 마지막 커밋은 10년 전임
     * 일본의 운영 체제 개발 책 두 권이 영어 번역이 되었으면 좋겠음
          + 그래픽 환경에서 창을 작동시키는 것까지 안내함
          + 그 중 한 권은 30일 도전 과제임
          + MikanOS GitHub
          + 30-days Homemade OS GitHub
          + ""30-days Homemade OS""를 영어로 번역하려는 시도가 있었지만 멀리 가지 못함
          + os-in-30-days GitHub
          + 영어로 이만큼 멀리 가는 책이나 기사를 알지 못함
          + Fusion은 그래픽 환경 챕터가 아직 완료되지 않음
          + Fusion OS 웹사이트
     * 작은 빨간 OS 책의 설명서는 어디에 있는지 궁금함
          + Kylin 운영 체제 위키피디아
     * OS 개발에 대해 말하자면, 게임은 학습을 재미있게 만듦
          + 컴퓨터 역사를 여행하면서 운영 체제를 가르치는 게임을 만들고 싶었음
          + 플레이어는 프로세스 스케줄러와 인터럽트 핸들러 역할을 하게 됨
          + 매우 제한된 RAM을 가진 단일 CPU 시스템에서 시작하여 SMP 시스템으로 성장하고 오늘날의 다중 시스템 분산 컴퓨팅 플랫폼에 도달할 수 있음
"
"https://news.hada.io/topic?id=19908","PDF만 던져주면 끝날줄 알았다 - GPTs RAG 적용 실패기","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  PDF만 던져주면 끝날줄 알았다 - GPTs RAG 적용 실패기

  불교 GPT 개발 배경

     * 불교 공부에 GPT를 활용하고자 했으나, 기본 성능은 기대 이하.
     * PDF 자료 학습을 통해 답변 품질이 향상됨.
     * 자타카 경전 학습을 제안받아 프로젝트 착수.

  PDF 학습의 한계

     * 자타카 PDF 학습 후 환각 심각.
     * 다단, 표, 그림 등 비선형 구조가 GPT에게 방해됨.

  시도한 방법들 (모두 실패)

     * epub 포맷 사용
     * instruction 조정
     * 마크다운 변환 + 크롤링
     * csv 인덱스 추가

  해결의 실마리

     * 문제는 자타카의 번호 기반 구조와 GPT의 생성형 특성의 충돌.
     * GPT가 csv를 제대로 활용하지 못함.
     * JSON 인덱스를 제안받아 적용하자 정확도 급상승.

  실제 적용 방식

     * epub → 마크다운 변환 (pandoc)
     * heading 수정, 불필요한 텍스트 제거
     * 경우에 따라 수작업으로 마크다운 구성

  서비스 종료 이유

     * 아비담마 질문에서 환각 발생
     * 번역자 Sujato Bhante의 AI 학습 반대 입장
     * SuttaCentral 라이선스 위반 소지

  결론

     * RAG는 단순하지 않다.
     * AI 학습용 자료는 반드시 라이선스를 확인해야 한다.

   경전과 비슷한 표기법을 사용하는 다른 종류 학습에 도움이 될 수 있겠네요. 플라톤 서적이라든가...

   Mistral OCR로 Doc As Prompt가 잘 될줄 알았는데, 저도 비슷한 문제가 있었습니다. 실마리 얻고갑니다.

   ""친구들에게 하기 힘든 연애상담을 LLM에 편하게 하세요""이 생각나는 군요.

   이거이거.... 우리 두고 지 혼자 열반에 들어버린거 아니죠?
"
"https://news.hada.io/topic?id=19973","Show GN: velopers: 국내 IT 기업들의 기술 블로그를 한곳에서 모아볼 수 있는 웹사이트","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Show GN: velopers: 국내 IT 기업들의 기술 블로그를 한곳에서 모아볼 수 있는 웹사이트

    소개

   velopers는 다양한 국내 IT 기업들의 기술 블로그를 한곳에서 모아볼 수 있는 웹사이트에요. 기업 테크 블로그 포스팅을 RSS 기반으로 크롤링하고 AI로 분류해서 필요한 정보를 더 쉽고 빠르게 찾을 수 있어요.

    주요 기능들

     * 여러 기업의 기술 블로그 게시물을 한 눈에 확인
     * AI를 활용한 카테고리 분류와 태그 자동 추출
     * 게시물 AI 요약 제공으로 빠른 내용 파악
     * 기술 태그별, 기업별 필터링
     * 태그, 블로그, 키워드 조합 검색으로 원하는 정보 쉽게 찾기
     * 카테고리별 인기 게시글 확인

  만든 이유...

   제가 필요해서 만들었습니다! 출퇴근 시간에 여러 기술 블로그를 둘러보는데, 매번 새 글이 올라왔는지 확인하려고 이곳저곳 들어가는 게 너무 귀찮았거든요.

   처음엔 RSS로 구독했는데, 관심 없는 주제까지 알림이 너무 많이 와서 오히려 불편했어요. 나중에 다시 찾아보려고 해도 검색이 어렵더라고요.

   이런 불편함을 해결하려고 velopers를 개발했습니다. LLM기반으로 분류되어 원하는 카테고리만 집중해서 볼 수 있고, 예전 글들도 원하는 조건으로 쉽게 검색할 수 있어요.

    나중에는

   앞으로는 이메일(또는 슬랙) 구독 서비스, 벡터 검색 기능, 해외 블로그 번역 요약, 커뮤니티 기능 같은 것들도 추가할 계획이에요.

   커리어리 + 벨트렌즈 느낌나네요 b

   벨로그가 생각나네요. 서핏도 있고

   https://freederia.com/category/research/
   https://freederia.com/category/aerospace/
   https://freederia.com/category/ai_learning/
   https://freederia.com/category/robotics/
   https://freederia.com/category/semiconductor/
   https://freederia.com/category/biotechnology/
   https://freederia.com/category/quantum_computer/
   https://freederia.com/category/fundamental_science/
   아파치 2.0라이선스(특허제외,변형 특허가능)으로 1만개이상 연구자료 오픈소스입니다.
   연구자료에 불과하지만 현재와 1년와 2년이내 사용화와 최적화를 중심으로 다룬내용입니다.
   도움이 되셨으면합니다.

   새 탭으로 열기가 안되네요 글에 들어갔다가 뒤로가기 하면 검색 내용도 초기화 됨

   https://techblogposts.com/ko 이 사이트도 괜찮아요. 기능은 적은 대신 소개해주신 velopers 보다 개수가 조금 더 많습니다. (저랑은 관계 없습니다)

   깔끔하니 좋습니다.

   좋네요
"
"https://news.hada.io/topic?id=19946","goblin.tools - 신경발달장애가 있는 사람들의 과제를 돕기 위한 간단한 단일 과제 도구","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         goblin.tools - 신경발달장애가 있는 사람들의 과제를 돕기 위한 간단한 단일 과제 도구

     * 신경다양성(Neurodivergent)인 사람들이 어렵거나 부담스럽게 느끼는 작업을 돕기 위한 간단하고 단일 작업 중심의 도구 모음임
     * 대부분의 도구는 AI 기술을 사용하며, 다양한 오픈 소스 및 비공개 소스 모델을 기반으로 작동함
     * 가능한 경우 윤리적인 모델을 사용하는 데 중점을 둠

AI 모델 사용 및 결과 주의사항

     * 사용되는 AI 모델은 일반 목적 모델이므로 출력 정확성이 다를 수 있음
     * 도구에서 제공되는 결과는 정확한 진술이 아닌 추측이므로, 자신의 지식과 경험을 바탕으로 판단해야 함

무료 제공 및 유지 방침

     * goblin.tools는 완전 무료로 제공되며, 광고나 유료화 없이 유지될 예정임
     * Android 및 iOS 모바일 앱은 저렴한 가격에 제공되며, 이를 통해 웹사이트의 운영 및 유지 비용을 충당할 계획임
     * 도구를 편리한 형태로 무료로 제공하는 것이 핵심 원칙임

     신경다양성(神經多樣性, 영어: neurodiversity)은 뇌신경의 차이로 인해 발생하는 다름(예: 자폐특성, 지적스펙트럼, ADHD, 학습 장애, 사회소통장애 등)을 생물적 다양성으로 인식하는 관점

        Hacker News 의견

     * ADHD를 자신의 정체성의 중요한 부분으로 여기는 사람들이 많음
          + 책을 읽다가 멍해지거나, 문을 지나가면서 할 일을 잊어버리거나, 화가 나거나, 생각을 놓치는 경우가 ADHD 때문이라고 여기는 경향이 있음
          + ADHD 관련 유튜브 채널에서는 ""ADHD와 함께 요리하기"", ""ADHD가 거짓말을 하게 만드는 방법"", ""ADHD를 가진 사람들을 위한 음악"" 같은 콘텐츠가 많음
          + ""집중을 위한 음악"" 같은 콘텐츠는 사라진 것 같음
          + Hacker News에서도 이런 현상이 자주 보임
     * ADHD와 자폐 스펙트럼을 가진 사람으로서, 어떤 앱도 주의를 산만하게 하는 요소를 완전히 없애지 못할 것 같음
          + goblin.tools가 신경전형적인 시장을 목표로 삼아야 한다고 생각함
     * goblin.tools는 Bram De Buyser가 작성하고 유지하는 AI, 소프트웨어 및 데이터 엔지니어링 프로젝트임
          + AI를 이름 붙이고 인격화하는 것처럼 보일 수 있음
     * 신경다양성을 가진 사람으로서, 이 웹사이트는 혼란스럽게 느껴짐
          + 할 일 목록을 확장하는 것보다 다음 단계로 안내하는 것이 더 효과적임
          + 최근 LLM 모델이 도움이 됨
     * 파이를 먹는 과정을 세분화한 예시
          + 파이 선택, 필요한 도구 모으기, 파이를 접시에 놓기, 조각 자르기, 포크로 조각 집기, 입으로 가져가기, 한 입 먹기, 맛을 음미하기, 반복, 남은 것 처리, 도구와 접시 정리
          + 기본적인 작업을 더 어렵게 만드는 것 같음
     * LLMs는 빈 페이지 효과를 극복하는 데 유용함
          + 잘못된 목록을 수정하는 것이 직접 시작하는 것보다 쉬움
     * Estimator를 사용해 본 예시
          + 우주 왕복선 건설: ""5~10년""
          + 타임머신 건설: ""5~50년""
          + 미국의 거버넌스 시스템을 독재로 대체: ""몇 달에서 몇 년""
     * ""욕실 청소""를 세분화한 결과
          + 3시간 25분이 걸린다고 추정했으나 실제로는 40분 정도 걸림
          + 간단한 작업에 대한 시간 추정이 과대평가됨
          + 전체 작업과 각 하위 작업에 대한 추정을 조정하는 방법이 필요함
     * 다양성은 팀을 강하게 하지만 명확한 의사소통을 어렵게 함
          + 인구의 20%는 신경전형적이지 않음
          + 문화적 차이도 존재함
     * The Judge라는 도구를 발견했을 때 매우 흥미로웠음
          + 이메일 스레드나 채팅방에서 문제가 발생할 때 유용한 도구임
     * TickTick과 통합된 도구를 만들었음
          + goblin tools처럼 태그를 설정하여 작업을 확장할 수 있음
"
"https://news.hada.io/topic?id=19866","번아웃 머신","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 번아웃 머신

     * 기술 업계는 ""꿈의 직장""이라는 신화를 팔아넘김
          + 사무실의 빈백, 무료 음료수, ""애자일"" 프로세스 등으로 유혹
          + 실제로는 개발자, 시스템 관리자, 보안 전문가를 소모품처럼 다룸
     * ""열정""이라는 명목으로 80시간 근무 강요
          + 보상은 번아웃, 불안, 그리고 상시 해고 위협
          + 업계는 근로자를 친구가 아닌 소모품으로 취급함

애자일 프로세스의 왜곡된 현실

     * 애자일의 본래 목적: 유연한 작업, 자율적인 팀 운영
     * 실제 현실: 경영진이 직원들을 더 빠르고 강하게 밀어붙이는 도구로 변질
          + ""변화에 대응"" → 사실상 끝없는 노동 강요
          + 스프린트는 마라톤이 되고, 비용은 직원들이 부담함
     * 기술 업계에서 번아웃은 흔한 일이 아닌, 기본 상태
          + 철야 작업 → ""헌신 부족""으로 취급
          + 야간 슬랙 메시지 응답 거부 → ""팀워크 부족""으로 낙인
     * 끊임없는 프로젝트, 혁신 압박, 불안정한 미래가 스트레스 유발
     * 업계의 해결책?
          + 마음챙김 앱과 일-생활 균형 강연 → 실질적인 해결책은 아님

일자리 보안의 부재

     * 기술 업계의 ""능력주의"" 신화 → 사실상 노동 시장 착취 구조
          + 최신 기술을 따라가지 못하면 바로 해고 위험
     * 외주, 계약직, 긱 이코노미 → 고용 불안정성 조장
     * 상시 해고 위험으로 인해 근로자는 끊임없이 경쟁 강요
     * 비정규직 선호 → 복지 및 고용 보장 회피 전략
     * 경쟁 금지 조항 → 이직 및 경력 발전 제한

윤리적 문제

     * 기술 업계는 ""미래를 구축""한다고 주장
     * 현실: 감시 기술, 데이터 마이닝, 편향 알고리즘 등의 문제 발생
          + 반윤리적 프로젝트에 강제 투입되는 경우 빈번
          + 근로자는 자신의 코드가 어떻게 사용되는지에 대한 통제권 없음

변화는 스스로 만들어야 함

     * 업계 스스로 변화할 가능성 없음
          + 상위 1%의 억만장자들이 자발적으로 변화를 수용할 가능성 낮음
          + 근로자가 스스로 조직화하고 저항해야 함
     * 노조 결성은 필수적임
          + 더 나은 임금과 복지 → 기본적인 요구
          + 근로 환경 개선, 업무 선택 권한 확보, 윤리적 책임 강화 필요

성공 사례: Alphabet Workers Union

     * 구글의 Alphabet Workers Union → 대기업에 저항하고 성공 사례 창출
     * 더 많은 기업에서 유사한 움직임 필요

해커 정신으로 노조 결성

     * 해커의 핵심 가치는 자유
          + 정보의 자유, 통제에서의 자유
     * 노조 결성 → 해커 정신을 직장에서 구현하는 과정
     * 행동 방안:
          + 대화 시작: 동료와 이야기 나누기 → 고립감에서 벗어나기
          + 기존 노조 지원: 이미 노조 활동이 있는 경우 참여
          + 기술 활용: 보안 커뮤니케이션, 비밀 조직화 기술 활용
          + 윤리적 플랫폼 구축: 임금과 복지뿐만 아니라 업무 윤리 문제 포함

기술 업계의 미래는 우리가 결정함

     * 현재의 산업 구조는 지속 불가능
     * 노조 결성은 선택이 아닌 필수
     * 해커의 도구와 기술을 사용해 업계를 재편해야 함
     * 노조 결성 → 업계의 미래를 우리가 주도

   취침실 샤워실이 있다? 저녁밥을 준다?

   애자일은 팀원이 하고 싶을 때 해야하는 거지, 보스나 팀장이 애자일을 하자고 시키면 안된다는 것을 저는 뼈저리게 깨달은 경험이 있습니다. 팀원 설득없는 팀장의 애자일 강요는 번아웃 생성 알고리즘일지도 모르겠네요.

   동의합니다. 애자일이 정확히 무엇인지도 모르면서 ""애자일하게 해야지?"" 라는 말을 입버릇처럼 하시던 분들도 있더라구요.

        Hacker News 의견

     * 소프트웨어 엔지니어링은 삶을 ""쉬운 모드""로 플레이하는 방법 중 하나임. 이 블로그 글은 이를 다르게 그리려 하지만, 다른 직업과 비교했을 때 관점이 부족함
          + 일부 소프트웨어 직업에서는 극한의 업무를 기대하지만, 다른 곳에서는 평균적인 40시간 근무로도 좋은 급여를 받을 수 있음
          + 자유로운 직업 선택이 많지 않음. 예를 들어, 의학 분야에서는 대학을 졸업하지 않으면 경력을 쌓을 수 없음
          + 기술 분야에서는 회사를 그만두면 LinkedIn에서 많은 메시지를 받음
          + 노동 착취에 대한 비판은 필요하지만, 특권 있는 직업군의 구성원으로서 자신을 피해자로 그리지 말아야 함
     * 노조는 마케팅을 개선해야 함. 문제를 공감하지만, 해결책은 정치인의 공약처럼 들림
          + 좋은 워크라이프 밸런스와 혜택을 제공하는 노조화된 엔지니어링 팀의 예시를 보고 싶음
          + 항공사, 택배, 교사 노조에서 일하는 가족과 친구들이 있음. 어떤 사람들은 좋아하고, 어떤 사람들은 싫어함
          + 노조의 약속은 CEO/CFO의 IPO 약속과 같은 톤을 가짐
     * HN에서 이런 글을 보는 것은 멋짐. 낮은 급여, 긴 근무 시간, 해고 위협 속에서 우리는 무력하지 않음을 기억해야 함
          + 상사와의 관계는 대립적임. 그들은 최소한의 급여로 최대한의 생산성을 원함
          + 조직화는 상황이 악화될 때 우리를 보호함
          + 기술 노동자들은 다른 산업에 비해 연대가 부족함. 해고를 겪으며 연대의 필요성을 느낌
     * 이 글은 특정 회사 집단을 설명하는 것 같음. 샌프란시스코의 유니콘 회사에서 일하고 싶다면 착취를 각오해야 함
          + 경로를 벗어나면 괜찮은 직업이 많음. 소프트웨어는 두뇌와 손만 있으면 생산 수단을 소유한 것임
          + 노조를 지지하지만, 착취적인 회사에 남아 있는 것보다 회사를 바꾸고 경력을 쌓는 것이 더 나음
     * 저자는 모두가 이렇게 일한다고 생각하는 것 같음. 실제로 많은 사람들은 40-45시간 근무하며 회의가 적음
          + 지루한 분야(군사, 은행, 보험 등)에서 일하지만 괜찮은 생활을 함
     * 고등학교 교사였을 때 노조에 가입하거나 같은 회비를 내야 했음. 회비의 90%가 나와 학생들에게 불리하게 사용됨
          + 아버지는 노조를 지지했지만, 노조가 그를 부당하게 대우함
          + 노조가 나를 따라잡으면 더 나은 곳을 찾을 것임
     * 기술 분야의 근무 조건에 대한 글은 다른 세계와 동떨어져 있음. 다른 산업에서는 기술 분야를 특권으로 봄
          + 기술 노동자들이 특권을 인정하지 않으면 다른 사람들이 지지하지 않을 것임
     * 기술 산업은 기본적인 사회 계약을 망쳤음. 다른 산업에서는 명성 있는 회사에서 일하려면 열심히 일해야 함
          + 저렴한 자금과 인재 수요가 많았던 시기가 끝나고 현실로 돌아가는 것이 불공평하게 느껴질 수 있음
     * 일반 소프트웨어 노조가 성공적으로 형성된 적이 있는지 궁금함. 많은 사람들이 좋은 직업 제안을 찾아 떠남
          + 소프트웨어는 다양한 산업으로 구성되어 있어 노조화가 어려움
          + 엔터테인먼트 산업처럼 성공적인 사례를 참고해야 할지도 모름
     * 개발자들이 작은 사업을 시작하고 서로를 고객으로 지원하는 것이 이상적임
          + 대기업에 팔지 않고 사업을 운영하는 것이 중요함
          + 대기업은 자연스러운 부작용이며, 노조는 창의성을 억제할 수 있음
"
"https://news.hada.io/topic?id=19855","Boston Dynamics, 모션캡쳐 기반으로 강화학습한 Atlas 로봇 데모 공개","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Boston Dynamics, 모션캡쳐 기반으로 강화학습한 Atlas 로봇 데모 공개

     * ""Walk, Run, Crawl, RL Fun""
     * 인간 모션 캡처와 애니메이션을 가져와 강화 학습을 사용하여 개발된 동작을 시연
     * Boston Dynamics 와 Robotics and AI Institute(RAI)의 협업으로 개발

   와우! https://youtu.be/I44_zbEwz_w?si=rrCJ73rtrd5pByZa&t=46
"
"https://news.hada.io/topic?id=19901","STPA - Google SRE의 새로운 장애 예방 방법 교육","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   STPA - Google SRE의 새로운 장애 예방 방법 교육

     * STPA(System Theoretic Process Analysis, 시스템 이론적 프로세스 분석) 는 시스템 및 제어 이론을 기반으로 복잡한 시스템의 제어-피드백 루프를 모델링하는 방법
          + 구글은 STPA을 사용하여 소프트웨어 시스템을 분석하고 잠재적인 위험을 발견
     * STPA는 시스템 안전성을 제어 문제로 다루며, 시스템이 위험 상태에 빠질 수 있는 모든 제어 동작을 분석함
     * 개별 동작의 결과보다는 위험 상태에 집중해 근본 원인을 찾는 방식
          + 위험 상태로 이어지는 제어 동작을 이해하면, 이를 예방하거나 자동 복구 가능
          + 자동 복구가 어려운 경우에는 인간 오퍼레이터에게 경고 가능

Google이 STPA 교육을 커스텀하는 이유

     * STPA를 통해 미확인된 문제를 사전에 발견하고 장애를 예방한 성공 사례가 늘어남
     * 기존 STPA 교육 자료는 물리 시스템 중심으로 구성돼 있어 소프트웨어 환경에 적용하기 어려움
     * Google의 순수 소프트웨어 시스템에 맞춘 맞춤형 교육이 필요해짐

초기 STPA 교육 시도

     * 2021년부터 초기 교육 시작 (40명의 Google 엔지니어 대상)
     * 물리 시스템 사례 (예: Mars Polar Lander 추락) 사용 → 소프트웨어 엔지니어의 공감 부족
     * Google 시스템에 적용한 실제 사례가 필요하다는 점 인식

제어 구조 개념 교육

     * 제어 구조(control structure) 는 기본 제어-피드백 루프로 구성됨
          + 컨트롤러가 상태 변경 제어 → 피드백으로 상태 확인 후 다음 동작 결정
     * 소프트웨어 환경에서 적용 예시
          + 예: 사용자 생성 콘텐츠 데이터베이스에서 잘못된 콘텐츠 삭제 또는 수정
          + 피드백 루프가 제대로 설계되지 않으면 잘못된 제어 동작 발생 가능
     * 교육 도전 과제
          + 제한된 시간 내에 유용한 제어 구조 설계 교육이 어려움
          + 소프트웨어 시스템마다 제어 구조가 달라 피드백 제공 어려움

STPA 교육 개선 전략

     * 모든 STPA 단계 교육 → 엔지니어가 독립적으로 STPA 수행 가능하도록 지원
     * Google의 실제 사례 활용 → 이론 설명 후 실제 사례 적용
     * 제어 구조의 피드백 경로 강화에 초점
          + 잘못된 피드백 → 잘못된 제어 동작 발생 → 장애 발생 사례 분석
          + 인간 오퍼레이터에 대한 피드백 부족 → 위험 상태 발생

피드백의 중요성

     * 한 Google 시스템에서 잘못된 피드백으로 인해 30일 후 잘못된 제어 동작 발생 → 장애 발생
     * 잘못된 피드백 및 인간 오퍼레이터에게 피드백 부족이 원인
     * 피드백 설계가 제대로 이루어지면 장애 예방 가능
     * Ariane 5 로켓 폭발도 피드백 오류 사례
          + 부동소수점 데이터를 정수로 변환하면서 오류 발생
          + 피드백 오류 → 잘못된 상태 인식 → 로켓 방향 오류 및 폭발

데이터 흐름 다이어그램 vs. 제어 구조

     * 데이터 흐름 다이어그램(Dataflow Diagram)
          + 데이터가 소프트웨어 컴포넌트 간에 어떻게 이동하는지 표시
          + 피드백 및 제어 구조 명확하지 않음
     * 제어 구조(Control Structure)
          + 제어 동작 및 피드백 표시 → 제어 계층 구조 명확
          + 피드백 문제 파악 용이 → 복잡한 시스템 상호작용에서 문제 원인 추적 가능

STPA 적용 효과

     * 복잡한 소프트웨어에서 수백만 줄의 코드 중 문제 발생 가능성이 높은 부분을 수백 줄로 좁힘
     * 위험한 제어 동작을 시나리오화 → 문제 코드 식별 가능
     * 실제 사례에서 제어 구조 구축 후 피드백 부족 식별 및 수정

교육 전략의 변화

     * 긴 교육 시간 → 짧은 교육 세션으로 전환
          + 30분~60분 튜토리얼 → 관심 있는 엔지니어가 워크숍 참여 유도
     * 자기 주도형 학습 모델 도입
          + 짧은 동영상 + 과제 → 실제 시스템에 STPA 적용 유도
          + 전문가의 개입 없이 초기 STPA 수행 가능하도록 교육 강화

Google에서 STPA 확산 전략

     * STPA 전문가 양성 → 팀 내부에서 STPA 전파 가능
     * 초기 성공 → 다른 팀으로 확산 → 조직 전반에 STPA 적용
     * STPA 훈련 후 설계 단계에서 위험 요소 미리 제거 가능

다른 기업에서도 적용 가능

     * STPA는 복잡한 소프트웨어 시스템에서 ""미확인된 위험 요소""를 찾는 강력한 도구
     * 소규모 팀에서 시작해 STPA 전문가 주도로 확산 가능
     * 기업에 맞는 맞춤형 STPA 교육 개발이 핵심
     * 초기 시행착오 후 방향 수정 가능 → 궁극적으로 시스템 안정성과 신뢰성 향상

        Hacker News 의견

     * Google에서 소프트웨어 컨트롤러가 잘못된 피드백을 받아 위험한 제어 동작을 실행한 사례가 있음
          + 이 동작은 30일 후에 실행되도록 예약되었음
          + 위험한 동작이 발생할 것이라는 지표가 있었지만, 이를 모니터링하는 엔지니어가 없었음
          + 결국 30일 후에 위험한 제어 동작이 발생하여 서비스 중단이 일어났음
          + 이 사건이 정부 데이터베이스 삭제 사건인지 궁금해하는 의견이 있음
          + 비난 없는 일반화 시도가 좋지만, 너무 과장된 스타일로 쓰여져 배울 것이 없었음
     * STPA 수업이 잘 구조화되어 있으며, 구글 예시가 도움이 되었음
          + 그러나 기사 자체에는 구체적인 예시가 없었음
     * STPA는 덜 명확한 실패 모드를 찾기 위한 디자인 리뷰 프레임워크임
          + FMEA는 더 인기 있지만, 이미 알고 있는 실패 모드만 목록화함
          + STPA는 생각하지 못한 실패 모드를 채워줌
     * 이해하기 어렵지만 알고 싶다는 의견이 있음
          + 구글에서 특정 서비스에 대해 어떻게 적용되는지 구체적인 설명이 필요함
          + ""B가 C로부터 피드백이 부족하다""는 것이 왜 나쁜지 설명이 부족함
     * STPA가 구글에서 신뢰성 문제를 해결한 실제 사례가 있었다면 더 설득력 있었을 것임
     * STAMP/STPA는 복잡한 시스템에 대한 모델과 방법론으로 잘 작동함
          + 사이버 리스크 정량화에 관심이 있었음
          + 다른 접근법에서는 위험한 제어 동작을 쉽게 이해할 수 있는 모델이 주어지지 않음
          + 더 많은 회사들이 이를 채택했으면 좋겠음
     * 시스템 전문가들과 협력하여 제어 구조를 구축한 후, 컨트롤러 C에서 B로의 피드백이 부족하다는 것을 즉시 알게 되었음
          + D를 통한 피드백 루프가 있음
          + B에서 D로의 직접적인 연결이 없는 문제는 왜 적용되지 않는지 궁금해함
          + 다시 읽어보니 수직 방향이 제어와 피드백을 나타내는 데 중요함을 알게 되었음
     * 기업의 과장된 이야기, 유행어, 오래된 아이디어를 혁신적으로 보이게 하려는 시도임
          + 어린 시절 라디오 수리 이야기를 STPA와 연결하려는 어색한 시도가 있음
          + 구글이 STPA를 소프트웨어에 적용한 것이 혁신이라고 주장하지만, 이는 오래된 방법임
          + 대부분의 내용은 피드백 루프와 제어 구조에 대한 기본적인 엔지니어링 개념임
          + 실제 메시지는 구글이 내부 교육 프로그램을 만들었다는 것임
          + 끝부분은 STPA를 사용하지 않으면 안 된다는 식의 전형적인 기업 전략임
     * 구글이 1년 동안 진공 청소기 소리를 내며 조용히 있었으면 좋겠다는 의견이 있음
"
"https://news.hada.io/topic?id=19858","`git who` – 이 코드 누가 작성했어?!","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `git who` – 이 코드 누가 작성했어?!

     * git-who는 코드베이스의 전체 구성 요소나 하위 시스템에 대한 책임자를 찾는 CLI 도구
     * git blame과 달리, git-who는 파일 트리 단위로 작동하여 코드 작성자를 식별함
     * 세 가지 서브 커맨드를 제공하며, 각각의 하위 명령어는 Git 저장소의 저작권에 대한 다른 관점을 제공
          + table
               o 기본값으로, 저장소에서 커밋한 모든 작성자의 기여를 요약한 표를 출력함
               o 경로를 지정하여 특정 경로의 파일에 대한 커밋만 필터링할 수 있음.
               o 브랜치 이름, 태그 이름, 또는 ""commit-ish""를 지정하여 특정 커밋에서 도달 가능한 커밋만 필터링할 수 있음
               o -m, -c, -l, -f 플래그를 사용하여 다양한 메트릭으로 테이블을 정렬할 수 있음
          + tree
               o 파일 트리를 출력하며, 각 노드는 해당 경로에서 가장 많이 기여한 작성자를 표시함
               o -a 플래그를 사용하여 모든 파일을 주석 처리할 수 있음
               o -l, -f, -m, -c 플래그를 지원함
          + hist
               o 커밋 활동의 히스토그램/타임라인을 출력하여 저장소에 대한 기여 역사를 보여줌
               o -l 및 -f 플래그를 지원함.
     * 커밋 필터링을 위한 추가 옵션
          + --author 및 --nauthor 옵션을 사용하여 포함하거나 제외할 작성자를 지정할 수 있음
          + --since 및 --until 옵션을 사용하여 특정 날짜 이전 또는 이후의 커밋을 필터링할 수 있음
     * 캐싱 : XDG_CACHE_HOME에 저장소별로 데이터를 캐시함. 캐싱을 비활성화하려면 GIT_WHO_DISABLE_CACHE=1을 설정
     * git-who 바이너리를 경로에 설치하면 추가 설정 없이 git who를 실행할 수 있음. 다른 이름으로 설치하거나 명시적으로 설정하려면 Git 설정에 Alias를 추가할 수 있음
     * .mailmap 파일이 Git 저장소에 존재하면 git who는 이를 존중하여 동일한 사람의 커밋을 함께 계산
     * 메트릭
          + 커밋 수: 경로를 수정한 커밋 수를 나타냄
          + 파일 수: 작성자가 수정한 고유 파일 수를 나타냄
          + 추가된 줄 수 및 제거된 줄 수: 경로에 추가되거나 제거된 줄 수를 나타냄
     * git blame과의 차이점
          + git blame은 작업 트리의 코드를 기준으로 각 줄을 도입한 커밋을 식별하는 반면,
          + git who는 커밋 로그의 일부를 탐색하여 기여를 집계함
          + 두 도구는 서로 다른 수준에서 작동하며, 서로 다른 정보를 제공함

        Hacker News 의견

     * ""vim을 누가 작성했는가"" 분석과 관련하여, 워크플로우에 따라 내부 기여자가 더 많이 기여한 것으로 보일 수 있음
          + 패치나 풀 리퀘스트가 내부 기여자에 의해 병합 전에 재포맷되면, 동일한 작업이 두 번 계산되거나 재포맷한 사람에게만 기여가 귀속될 수 있음
          + 결과가 틀린 것은 아니지만, 기여 과정에 대한 검토 없이 결과에서 의미를 도출할 때는 주의가 필요함
     * 이 도구는 정말 멋짐. 하루를 마무리하기 전에 잠시 사용해봤음
          + 개인적인 위시리스트는 다음과 같음
               o 블레임 기반 통계. Bob과 Alice의 기여를 보는 것도 좋지만, 모듈/파일의 실질적인 소유자를 보여주는 것이 더 유용할 것임
               o 패턴 기반 포함/제외 지원. 예를 들어, 테스트에 사용되는 json 파일이나 자동 생성된 파일의 통계는 보고 싶지 않음
               o 설정 파일 지원. git 저장소에 선호 설정을 저장할 수 있는 TOML 기반의 파일이 있으면 좋겠음
               o 더 나은 패키징. 예를 들어, v0.6의 리눅스 tarball에는 애플 관련 ""쓰레기""가 포함되어 있고, gnu tar가 아카이브 형식 불일치를 경고함
     * git 블레임은 많은 사람들이 오해하고 있음. 누가 했는지가 아니라, 어떤 커밋이 원인인지에 대한 것임
     * git-who를 git who로 호출할 수 있음. 글로벌 Git 설정에서 별칭을 설정하면 됨
          + 별칭 없이도 작동함. 기본적으로 git whatever는 경로에서 git-whatever를 찾아 실행함
     * 저사양 버전으로 ""nerdwars""라는 별칭을 사용하여 ""git shortlog -ns --no-merges""를 실행함. 이는 프로젝트의 주요 기여자를 파악하는 좋은 방법임
     * Gitlab/Github는 제출된 병합 요청이 수정된 코드 라인의 마지막 작성자에게 자동으로 이메일을 보내는 기능을 추가해야 함
     * 이 도구는 훌륭함. 앱의 각 릴리스에서 AI와 인간이 작성한 코드 양을 추적하기 위해 git-blame 회계를 사용함
          + ""블레임 스크립트""가 저장소 크기가 커지면서 느려지고 있음. 캐싱을 추가하려고 했음
          + 파일 패턴에 기반하여 통계를 제한하는 기능을 추가할 생각이 있는지 궁금함
     * tig는 멋진 TUI git 프론트엔드이며, 아름다운 tig blame 서브 커맨드를 가지고 있음
     * git에서 놓치고 있는 것은 개발자가 작성한 라인 수나 커밋 수가 아님. 오히려 다음과 같은 것임
          + 누가 이 라인을 삭제했는가
          + 누가 이 메서드의 소유자인가
     * 어떤 사람들은 두 개의 다른 이메일을 사용하여 커밋함. 예를 들어, 집 컴퓨터와 회사 컴퓨터에서 각각 다른 이메일을 사용함. 이를 동일한 것으로 정의할 수 있으면 좋겠음
"
"https://news.hada.io/topic?id=19863","Claude, 이제 웹 검색 가능 ","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Claude, 이제 웹 검색 가능

     * Claude가 이제 인터넷 검색을 통해 최신 정보와 더 정확한 답변을 제공할 수 있음
     * 웹 검색을 통해 최신 이벤트와 정보를 반영하여 정확도를 향상시킴
     * 검색한 정보를 응답에 포함할 때 출처를 명확히 표시해 사용자가 쉽게 사실 확인 가능
     * 사용자가 직접 검색 결과를 찾지 않아도 Claude가 대화 형식으로 관련 정보를 제공함
     * Claude의 기존 지식 기반이 실시간 정보로 확장되어 더 정확하고 시의적절한 답변 가능

Claude의 웹 검색 활용 사례

     * 영업팀 : 업계 동향을 분석해 주요 이니셔티브와 문제점을 파악함으로써 고객과의 대화를 강화하고 성공률을 높일 수 있음
     * 금융 분석가 : 최신 시장 데이터, 실적 보고서, 업계 동향을 평가해 더 나은 투자 결정 및 금융 모델 수립에 활용 가능
     * 연구자 : 주요 소스를 검색해 강력한 연구 제안서와 문헌 검토 작성 가능. 새로운 트렌드를 발견하고 현재 연구에서 부족한 부분을 식별 가능
     * 쇼핑객 : 여러 소스를 통해 제품 특징, 가격 및 리뷰를 비교해 더 나은 구매 결정 가능

시작하기

     * 웹 검색은 현재 미국의 모든 유료 Claude 사용자에게 기능 프리뷰로 제공됨
     * 무료 사용자 및 다른 국가에 대한 지원은 곧 추가될 예정임
     * 시작하려면 프로필 설정에서 웹 검색을 활성화하고 Claude 3.7 Sonnet과 대화 시작
     * 필요한 경우 Claude가 자동으로 웹 검색을 통해 응답 제공

   한국에서는 아직 사용 못하는거 같은데, 맞죠?

        Hacker News 의견

     * 웹 검색은 이론적으로 훌륭한 기능이지만, 실제로는 상위 X개의 결과를 보고 그것을 정답으로 해석하는 경우가 많음
          + 인기 있는 주제나 일반적인 오류에 대해 LLM과 대화할 때, 상위 결과는 종종 블로그 스팸이나 해결되지 않은 포럼 게시물일 뿐임
          + 이는 웹 검색이 점점 더 사용하기 어려워지고 있다는 것을 나타내며, 생성 시스템의 성능에도 영향을 미침이 흥미로움
     * Anthropic이 기능을 발표하고 즉시 모든 사용자에게 제공한 점에 큰 찬사를 보냄
          + OpenAI는 이 부분에서 매우 짜증스러움. 정기적으로 출시 일정을 제공하지만 지키지 않거나 잘못된 경우가 많음
          + ""모든 사용자""는 유료 사용자만을 의미함. 무료 계층에 대해 신경 쓰지 않음. Anthropic과 OpenAI의 유료 사용자로서 출시 차이를 지적했을 뿐임
          + 미국 중심적 시각을 보여 미안함
     * 테스트에서 심각한 환각을 보였음. ""Arrow 지원을 갖춘 Postgres에 접근하는 Rust crate""를 물었더니 가상의 arrow-postgres crate를 만들어 냄
          + 이 가상의 crate를 사용하는 Rust 코드 샘플까지 제공함
          + PostgreSQL 데이터베이스를 SQL로 쿼리하고, 결과를 Arrow 레코드 배치로 반환하며, 강력한 타입의 Arrow 스키마를 사용하고, PostgreSQL과 Arrow 데이터 타입 간의 변환을 효율적으로 수행할 수 있다고 설명함
     * 이번에는 robots.txt를 실제로 존중할지 궁금함
     * 이미지 검색 및 재표시 기능을 원함. ""이 주소에서 5마일 이내의 모든 호텔을 검색하고 객실과 화장실의 상세 사진을 보여줘"" 같은 요청을 하고 싶음
          + 호텔들은 외관, 로비, 회의실을 보여주기를 더 원하기 때문에 실제 생활 공간을 찾는 것이 놀랍도록 어려움
     * 미국 내 모든 유료 Claude 사용자에게 기능 미리보기를 제공함. 무료 플랜 사용자와 더 많은 국가에 대한 지원은 곧 제공 예정임
     * 제품 비전과 목표 시장에 대해 많은 것을 말해줌. 예시 쿼리가 타입스크립트 마이그레이션 질문임
          + 일반 검색 사용자에 대해 신경 쓰지 않는 것인가? 개발자만을 위한 것인가?
     * 요즘 구글링을 덜 하게 됨. 검색 결과의 품질이 낮고 AI의 품질에 감명받아 검색의 시대가 끝나가고 있다고 생각함
          + AOL은 America Online이 관련 포털로서의 역할을 멈춘 후에도 이메일 주소로 꽤 오랫동안 지속됨. Gmail도 그럴 수 있음
     * 웹 검색을 어떻게 수행하는지에 대한 설명이 없음. 자체 자료를 활용하는 것인지 다른 웹 검색 엔진을 호출하는 것인지 궁금함
     * 주제에서 벗어난 내용:
          + Mistral은 이미 무료 계층에서 웹 검색을 활성화했음
          + 주의점: 무료 계층의 Mistral 추론 모델은 매우 느림(2-5 토큰/초)
"
"https://news.hada.io/topic?id=19920","HN에 공개: Drum Patterns 공유 웹사이트 구축","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    HN에 공개: Drum Patterns 공유 웹사이트 구축

     * 드럼 패턴 공유 플랫폼 소개
          + 드럼 머신 패턴을 발견하고 공유할 수 있는 플랫폼임.
          + 다양한 장르의 드럼 패턴을 제공하며, 사용자가 직접 패턴을 만들고 공유할 수 있음.
     * 드럼 패턴 예시
          + Breakbeat: 다양한 타악기 소리와 리듬이 포함된 패턴.
          + Electro Funk: 전자 음악과 펑크 리듬이 결합된 패턴.
          + Hip Hop: 힙합 음악에 적합한 리듬 패턴.
          + Techno: 테크노 음악에 사용되는 반복적이고 강렬한 리듬.
          + Reggae: 레게 음악 특유의 리듬을 가진 패턴.
     * 사용자 참여
          + 사용자는 자신의 드럼 패턴을 등록하고 다른 사용자와 공유할 수 있음.
          + 다양한 BPM(비트 퍼 미닛)으로 패턴을 재생할 수 있어 음악 제작에 유용함.
     * 플랫폼의 장점
          + 다양한 음악 장르에 맞는 드럼 패턴을 쉽게 찾을 수 있음.
          + 사용자 간의 패턴 공유를 통해 창의적인 음악 제작을 지원함.
          + 드럼 패턴을 통해 음악 제작의 기초를 배우고 응용할 수 있는 기회를 제공함.

        Hacker News 의견

     * Funklet이 생각나는 멋진 프로젝트임. Jack Stratton과 Rob Stenson이 만든 이 프로젝트는 펑크와 미디 드럼을 좋아하는 사람들에게 진정한 보석임
     * 드럼 머신에서 닫힌 하이햇이 하이햇을 닫는 기능을 추가할 수 있는지 궁금함. 이 기능을 정말 좋아함
     * Glicol로 몇 가지 패턴을 포팅하고 싶음. HTTPS 지원이 필요하다는 제안이 있음
     * 훌륭한 작업임. iOS 사용자에게 무음 모드를 해제해야 소리를 들을 수 있다는 힌트를 주는 것이 좋을 것 같음. iOS의 특이한 점으로, Web Audio API를 지원하지 않는다고 오해했음
     * 매우 멋짐. 몇 년 전에 만든 비주얼라이저가 생각남
     * 정말 창의적임. 훈련하기에 재미있을 것 같음
     * 드럼을 치지는 않지만 타악기를 좋아해서 재미있게 놀았음. 각 악기의 약어를 클릭하여 소리를 들을 수 있는 기능이 있으면 좋겠음. 노트를 배치할 때 약어가 어떤 악기인지 확인하기 위해 스크롤을 많이 해야 함
     * 좋은 사이트임. 피드백 중 하나로, iPhone에서는 시각이 오디오보다 약간 앞서 있는 것 같음. 큰 문제는 아니지만 약간 어긋난 느낌이 있음. iPhone의 Safari에서 오디오의 특성일 수 있음
     * 멋짐. 목록 보기에서 필터를 추가하고 재생 BPM, 샘플 등을 변경할 수 있는 방법이 있으면 좋겠음. 계속 발전하길 바람
     * 환상적임. 단순하고 재미있으며 아이디어를 빠르게 탐색할 수 있는 적절한 분위기를 가짐. 집중도가 높아 잡다한 요소 없이 바로 그루브에 들어갈 수 있음. 이 프로젝트가 계속 열정 프로젝트로 남을지, 아니면 비즈니스 모델을 고려하고 있는지 궁금함
"
"https://news.hada.io/topic?id=19905","스크립트에서는 긴 옵션을 사용합시다","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          스크립트에서는 긴 옵션을 사용합시다

     * 많은 명령줄 유틸리티는 짧은 형식 옵션(-f)과 긴 형식 옵션(--force)을 지원함
     * 짧은 형식은 대화형 사용을 위한 것임, 스크립트에서는 긴 형식을 사용할 것을 권장함
     * 예를 들어, 터미널에서는 $ git switch -c my-new-branch라고 입력함.
     * 릴리스 스크립트에서는 다음과 같이 작성함:
          + try shell.exec(""git fetch origin --quiet"", .{});
          + try shell.exec(""git switch --create release-{today} origin/main"", .{ .today = stdx.DateUTC.now() }, );
     * 긴 형식 옵션은 독자에게 훨씬 더 설명적임

        Hacker News 의견

     * 긴 옵션을 선호하지만, POSIX 명령을 이식성 있게 호출해야 할 때는 짧은 옵션만이 유일한 선택임. POSIX는 긴 옵션을 명시하지 않음
          + 예를 들어, diff의 사양을 참조할 수 있음
          + 대부분의 경우, POSIX 유틸리티에 의존하기보다는 라이브러리 바인딩을 사용하는 것이 더 나은 대안임
          + grep을 호출하는 대신 libpcre 같은 것을 사용하는 것이 더 효율적일 수 있음
          + git, hg, rg, ag 등 비-POSIX 유틸리티에서는 긴 옵션을 사용하는 것이 합리적임
     * 문자열 보간과 명령 실행을 혼합하지 말아야 함
          + 특히 명령이 셸을 통해 처리될 때 주의해야 함
          + 어떤 언어든지 리스트 기반 또는 배열 기반 실행 API를 사용하여 인수를 execv(2), execvp(2) 등으로 직접 전달해야 함
     * 긴 옵션을 사용해야 한다는 것에 동의하지만, 이식성을 고려해야 함
          + 모든 BSD 배포판이 GNU 스타일의 긴 옵션을 지원하지 않음
          + 이식성을 원한다면 짧은 옵션을 사용해야 함
     * 모든 옵션 뒤, 동적 인수 앞에 “--”를 사용하는 것을 잊지 말아야 함
     * 명령을 호출하기 전에 명령의 길이가 ARG_MAX보다 긴지 확인해야 함
          + 예를 들어, 다음과 같은 명령이 있을 때:
               o grep --ignore-case --files-with-matches -- ""hello"" *.c
          + 이렇게 호출해야 함:
               o CMD=""grep --ignore-case --files-with-matches -- \""hello\"" *.c""
               o ARG_MAX=$(getconf ARG_MAX)
               o CMD_LEN=${#CMD}
               o if (( CMD_LEN > ARG_MAX )); then
               o echo ""Error: Command length ($CMD_LEN) exceeds ARG_MAX ($ARG_MAX)."" >&2
               o exit 1
               o fi
               o eval ""$CMD"" # 경고, 파일 이름을 평가함
     * 이 방법에 동의함. 또 다른 이점은 옵션이 무엇을 하는지 man 페이지에서 grep하기가 더 쉬워짐
     * 스크립트를 다른 POSIX 시스템에 이식 가능하게 만들고 싶다면 짧은 옵션을 사용해야 할 수도 있음
          + 긴 옵션은 표준화되지 않았음
          + 스스로 트레이드오프를 결정해야 함
     * 옵션을 별도의 줄에 두어 추적하고 git blame하기 쉽게 해야 함
     * 스크립트를 작성할 때의 기본 규칙 중 하나임. 긴 옵션이 가능하다면 사용해야 함
          + 그렇게 하는 것이 너무 합리적임
     * 긴 형식 옵션은 독자에게 훨씬 더 설명적임
          + 오타가 덜 발생함
"
"https://news.hada.io/topic?id=19882","Bolt3D - 초고속 3D Scene 생성 모델","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Bolt3D - 초고속 3D Scene 생성 모델

     * 초고속 3D 장면 생성을 위한 잠재 확산 모델(latent diffusion model)
     * 하나 이상의 입력 이미지를 통해 7초 이내에 고해상도의 3D 장면을 생성할 수 있음
     * 대규모 멀티뷰 일관성 데이터셋을 구축해 훈련하였으며, 기존 3D 생성 모델 대비 최대 300배 빠름
     * 기존 모델들은 최적화 과정이 필요하지만, Bolt3D는 피드포워드(feed-forward) 방식으로 즉각적인 장면 생성 가능

기존 모델의 한계 및 문제점

     * 기존 2D 생성 모델은 고품질 이미지 생성 가능하나, 3D 장면 생성은 어려움
     * 기존의 3D 모델은 다음과 같은 문제점이 있음:
          + 복잡한 3D 데이터 구조 처리의 어려움
          + 고품질의 실제 3D 장면 데이터 부족
          + 높은 계산 비용 및 느린 처리 속도

Bolt3D의 주요 기법 및 구조

  3D 표현 방식

     * 3D Gaussian 표현 방식 사용:
          + 3D Gaussian은 색상, 위치, 불투명도 및 공분산 행렬로 구성됨
          + Splatter Image라는 픽셀 정렬된 이미지를 통해 3D Gaussian 렌더링 수행
          + 보이지 않는 영역까지 보완 생성 가능

  Bolt3D 생성 과정

    1. **잠재 확산 모델(latent diffusion model)**을 통해 입력 이미지에서 3D 장면 추정
    2. Geometry VAE를 통해 기하학적 정보를 잠재 공간에 인코딩
    3. Gaussian Head가 3D Gaussian의 세부 속성(불투명도, 색상 등) 예측 및 보정
    4. 고해상도 3D 장면을 즉각적인 렌더링 수행

  모델 구조

     * 잠재 확산 모델은 2D 이미지 생성 모델에서 발전된 구조 채택
     * Geometry VAE는 3D 포인트맵과 카메라 포즈를 인코딩
     * Gaussian Head는 생성된 3D 장면의 세부 속성 보완

데이터셋 및 훈련

     * 대규모 멀티뷰 데이터셋 구축:
          + CO3D, MVImg, RealEstate10K, DL3DV-7K 포함
          + 총 약 30만 개의 멀티뷰 장면으로 구성
          + MASt3R 기법 사용하여 정확한 기하학적 데이터 확보
     * 훈련 과정:
         1. Geometry VAE: 256×256 → 512×512 해상도로 훈련
         2. Gaussian Head: Splatter Image 생성 보정
         3. Latent Diffusion Model: CAT3D 모델 기반에서 미세 조정

실험 결과 및 성능 비교

  기존 모델과의 비교

     * Bolt3D는 기존의 Flash3D 및 DepthSplat 모델보다 성능이 우수함
     * Flash3D와의 성능 비교에서 Bolt3D는 PSNR 지표에서 약 3.6 포인트 높은 성능을 기록했으며, SSIM 및 LPIPS 지표에서도 개선됨
     * DepthSplat 모델과의 비교에서도 Bolt3D는 모든 성능 지표에서 우위를 보였음
     * 특히 입력 이미지가 하나뿐인 상황에서 성능 향상 폭이 가장 컸음

  최적화 기반 모델과의 성능 비교

     * Bolt3D는 기존의 CAT3D 등 최적화 기반 모델과 비교해 성능이 유사하거나 뛰어나면서도 300배 빠른 속도를 기록
     * CAT3D의 경우 장면을 생성하는 데 약 5분이 소요되지만, Bolt3D는 동일한 작업을 6.25초 만에 수행 가능
     * 성능 지표 측면에서 CAT3D가 Bolt3D보다 다소 높은 PSNR 점수를 기록하였으나, 처리 속도 측면에서 Bolt3D가 압도적인 성능을 보임

모델 구조 및 아키텍처 개선 사항

  Geometry VAE 개선

     * 기하학적 정보 전용 VAE 사용 → 일반적인 이미지 VAE보다 정확도 증가
     * 비선형 스케일링 및 깊이 매핑 적용 → 모델 성능 향상

  Gaussian Head 개선

     * 다중 뷰 정보 통합 및 보정
     * Cross-Attention 적용 → 보이지 않는 영역까지 보완 생성 가능

결론 및 시사점

     * Bolt3D는 기하학적 정보 학습 및 피드포워드 방식을 통해 고속 3D 장면 생성 가능
     * 기존 모델 대비 성능 및 속도 모두 개선됨
     * 다양한 응용 분야에서 즉각적인 고품질 3D 장면 생성 가능:
          + 게임 개발
          + 가상현실(VR) 및 증강현실(AR)
          + 건축 및 디자인 시각화
     * 초당 300배 향상된 처리 속도로 상용화 및 확장 가능성 높음

주요 성과 요약

     * 7초 이내에 3D 장면 생성 가능
     * 기존 모델 대비 300배 빠른 성능
     * 고해상도 세부 묘사 및 일관성 확보
     * 단일 및 다중 뷰에서 높은 성능
     * 복잡하고 미완성된 장면에서도 자연스러운 보완 생성 가능
"
"https://news.hada.io/topic?id=19874","Stripe, 자신들의 AI를 사용하지 않을시 추가로 $15의 분쟁 수수료를 부과하기로","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Stripe, 자신들의 AI를 사용하지 않을시 추가로 $15의 분쟁 수수료를 부과하기로

     * 기존에 분쟁이 발생할 때마다 부과되던 $15 수수료에 더해, 이제 분쟁에 대응할 경우 추가로 $15 수수료 발생
          + 분쟁에서 승소할 경우에만 추가 수수료 환급 가능
     * 은행은 어떤 증거를 제시하더라도 정당한 거래를 취소하는 경우가 많음
          + 결과적으로 Stripe는 분쟁당 총 $30을 가져가게 됨 (기존 $15에서 두 배로 증가)

     ""이건 강도짓이야.(This is highway robbery.)""

     * Stripe의 Smart Disputes AI를 사용할 경우 예외 적용 가능 (현재 미출시 상태)

   발생만 하고 대응하지 않아도 수수료를 부과한다는것인..? 이건 분쟁비용을 올리고 AI 를 사용하면 할인해주는것과 같은게 아닌지..

        Hacker News 의견

     * Stripe의 정책이 소규모 사업자에게 불리함
          + 고객이 $10 제품을 구입 후 환불을 요청하면 $25를 Stripe가 회수함 → 제품 가격의 250% 손해 발생
          + 새로운 정책에서는 $15 추가 비용을 감수하고 이의를 제기해야 하며, 승소 시에만 돌려받을 수 있음
          + 소규모 사업자는 규제와 고객 보호의 필요성을 인정하지만, 현재 정책은 대기업에만 유리함
     * SaaS 사업을 운영중. 구독 취소를 잊은 고객이 직접 환불을 요청하지 않고 분쟁 절차를 시작하는 경우가 많음
          + 이메일로 환불을 요청하면 쉽게 처리될 수 있으나, 바로 분쟁을 거는 경우가 많음
          + 분쟁이 발생하면 두 가지 선택지가 있음:
               o 고객에게 친절한 이메일을 보내 철회를 요청하고 환불 약속
               o 증거 제출로 반박 → 고객이 취소하지 않았음을 증명하기 어려움
          + 두 과정 모두 시간과 노력이 많이 들고, 결과와 관계없이 초기 분쟁 수수료는 반환되지 않음
          + 현재 시스템은 상인에게 불공평하게 느껴짐
               o 상인이 정직하게 운영해도 분쟁이 발생함
               o 고객 보호를 위한 장치가 필요하지만, 상인이 일방적으로 불리한 구조는 문제
          + 해결책 제안:
               o 고객에게 이메일로 환불 약속 후 분쟁 철회 요청
               o 증거 제출로 반박 → 그러나 고객이 취소하지 않았음을 증명하기 어려움
               o 간소화된 페널티 없는 분쟁 해결 프로세스 도입 제안
                    # 2주 내 환불 기회 제공 → 환불 시 분쟁 종료 및 추가 비용 없음
                    # 고객이 근거 없는 분쟁 제기 시 불이익 발생하도록 변경
     * Stripe의 정책 변화가 비즈니스에 부정적 영향을 줄 수 있음
          + 다른 결제 옵션(예: PayPal) 도입을 고려 중
     * LLM(대규모 언어 모델)이 환불 여부 결정에 사용될 가능성에 대한 우려
          + LLM은 가장 가능성 높은 텍스트를 생성하는 모델이므로 정확성이 보장되지 않을 수 있음
          + 경영진이 LLM의 작동 원리를 제대로 이해하지 못한 상태에서 이를 오용할 위험 존재
               o 예: 보험 청구 거부 사유를 고객에게 설명하는 데 LLM을 사용하는 경우
     * 신용카드 결제 시스템은 고객에게 유리한 구조
          + 거래 처리의 신속성과 편리함이 장점이지만, 상인은 고객 친화적인 정책을 수용해야 함
          + 신용카드 결제를 거부하고 ACH나 암호화폐 등 다른 결제 수단 사용 가능하나 고객 확보가 어려움
     * 고객이 구독 취소를 잊고 ""사기 청구""라고 주장할 경우 방어가 어려움
     * 사용자 활동 로그, 이메일 알림 등으로 반박 가능하나 부담이 큼
     * 고객이 취소를 잊었을 경우 환불 정책을 명문화할 필요 있음
     * 구독 자동 갱신을 선택적으로 허용하는 모델이 필요함
     * Stripe의 새로운 정책은 시장 독점적 지위를 이용해 상인에게 불리한 구조임
          + 경쟁이 부족해 이러한 정책이 강화됨
     * Stripe의 정책 변화는 자본주의의 본질적 문제를 반영함
     * 일부 상인은 Amex를 수수료 및 환불 문제로 인해 수용하지 않음
          + 중요한 서비스에 접근 제한이 있을 경우 환불 시 고객이 더 신중해짐
     * Stripe가 소규모 사업자를 지원한다고 주장하지만, 실제로는 그렇지 않음
     * Stripe Radar를 활성화하면 사전 경고를 받을 수 있으며, 이 경우 사전 환불을 통해 분쟁 회피 가능
          + Chargeblast, ByeDispute 등 분쟁 회피 서비스도 존재
     * Chargeback 조기 경고 시스템이 이번 달에 종료될 예정
     * Mastercard와 Visa의 중재 수수료는 $500임
          + Adyen은 관련 문서를 상세하게 제공하고 있음
"
"https://news.hada.io/topic?id=19848","Telescope - Clickhouse를 위한 웹 기반 로그 뷰어 UI 오픈소스","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Telescope - Clickhouse를 위한 웹 기반 로그 뷰어 UI 오픈소스

     * 직관적인 로그 탐색 인터페이스를 제공하는 웹 애플리케이션
     * ClickHouse에 저장된 모든 유형의 로그와 호환되며, 사용자는 ClickHouse와 쉽게 연결하여 로그를 검색하고 분석할 수 있음
     * 향후 추가적인 데이터 소스를 지원할 예정

주요 기능

     * 소스 관리
          + 여러 ClickHouse 클러스터에 대한 연결 생성 및 관리
          + 특정 테이블에서 사용할 필드 선택 및 자동 완성, 숨김 여부 설정
          + 사용자 및 그룹별 접근 권한 및 사용 권한 관리
     * 데이터 탐색
          + 동적 시각화 및 인터랙티브 그래프를 통한 로그 분석
          + 컬럼 선택, 데이터 표현 방식 조정, 필터링 등 맞춤형 뷰 제공
          + 상대적 시간 범위를 지원하는 날짜 및 시간 선택 기능
          + 미니멀한 디자인으로 로그 데이터 분석에 집중할 수 있는 환경 제공
     * 역할 기반 접근 제어 (RBAC) 및 인증 지원
          + GitHub 인증 지원 및 특정 조직 소속 사용자만 접근 허용 가능
          + 사용자 및 그룹별 권한 설정을 통해 특정 소스에 대한 접근 제어

   Elasticsearch 같은 서비스인가 봅니다.
"
"https://news.hada.io/topic?id=19859","AI Blindspots – AI 코딩 중에 발견한 LLM의 맹점들","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 AI Blindspots – AI 코딩 중에 발견한 LLM의 맹점들

   AI 코딩 중에 발견한 LLM의 맹점들. Claude Sonnet 기준
    1. Stop Digging → 문제 발생 시 방향 전환 어려움
    2. Use Static Types → 정적 타입 설정 필요
    3. Black Box Testing → 구현 세부 정보에 과도하게 의존
    4. Use MCP Servers → MCP 서버 설정 및 안전성 문제
    5. Preparatory Refactoring → 필요 없는 리팩토링 수행 가능
    6. Mise en Place → 환경 설정 실패 시 문제 발생
    7. Stateless Tools → 상태 의존 도구에서 문제 발생
    8. Respect the Spec → 명세 위반 가능성 높음
    9. Bulldozer Method → 반복 작업 과다 수행
   10. Memento → 맥락 이해 부족 문제 발생
   11. Requirements, not Solutions → 요구 사항 명확화 필요
   12. Scientific Debugging → 추측 기반 수정 시 문제 발생
   13. Use Automatic Code Formatting → 코드 스타일 불일치 발생
   14. The Tail Wagging the Dog → 중요 작업보다 사소한 문제에 집착
   15. Keep Files Small → 큰 파일 수정 시 문제 발생
   16. Know Your Limits → 모델이 자신의 한계 인식 부족
   17. Read the Docs → 학습된 지식 외의 정보에서 오류 발생
   18. Culture Eats Strategy → 코드 스타일 일관성 부족
   19. Walking Skeleton → 최소한의 시스템 작동 우선 필요
   20. Rule of Three → 코드 중복 시 리팩토링 필요
     __________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

문제에 빠져들지 않음 (Stop Digging)

     * 현재 LLM은 작업 중 문제가 발생해도 스스로 이를 중단하고 방향을 바꾸는 능력이 부족함
          + 예: 기능 X 구현 중 기능 Y를 먼저 구현해야 하는 상황이 발생해도 LLM은 원래 작업(X) 완료 시도
          + LLM이 명령을 충실히 수행한다는 점에서는 장점이지만, 문제를 자각하고 방향 전환이 어려움
     * 문제를 피하기 위한 전략
          + 계획 수립 단계에서 추론 모델을 사용해 작업의 우선순위 및 선행 작업 결정
          + Sonnet 같은 에이전트 LLM은 파일을 읽고 작업 계획을 수립함 → 사용자가 명시적으로 지시하지 않아도 필요한 작업을 파악 가능
     * 이상적으로는 LLM이 문제를 인지하고 사용자에게 확인 요청 가능해야 함
          + 그러나 이는 컨텍스트를 소모하기 때문에 별도의 감시 LLM이 이를 처리하는 것이 더 나을 수 있음
     * Example
          + Monte Carlo 시뮬레이션의 난수 샘플링 방식 수정 후 Claude Code에 테스트 수정 요청
               o 새로운 구현이 비결정적이라 테스트 결과가 통과/실패가 랜덤하게 발생
               o Claude Code는 이를 인지하지 못하고 테스트 조건을 완화해 문제 해결 시도
               o 대신 시뮬레이션이 결정론적이 되도록 리팩토링 제안했어야 함

정적 타입 사용 (Use Static Types)

     * 동적 타입 vs 정적 타입 시스템 논쟁은 프로토타이핑의 용이성과 장기적인 유지 보수 간의 균형 문제
          + LLM이 보일러플레이트 코드와 리팩토링을 처리할 수 있어 프로토타이핑에 적합한 언어 선택 부담 감소
          + 따라서 프로토타이핑보다 장기 유지 보수에 유리한 언어 선택 가능
     * 타입 오류 수정 전략
          + 에이전트 설정에서 LLM이 변경 후 발생한 타입 오류를 인지하도록 구성
          + 이를 통해 수정이 필요한 다른 파일도 쉽게 파악 가능
     * 주의점
          + Python 및 JavaScript의 경우 점진적 타입 시스템 사용 → 타입 체커 설정을 엄격하게 구성 필요
          + Rust는 원칙적으로 LLM에 적합하지만 현재 Python/JavaScript만큼 잘 생성되지 않음

블랙 박스 테스트 (Black Box Testing)

     * 블랙 박스 테스트는 컴포넌트의 내부 구조를 모른 채 기능을 테스트하는 방식
          + LLM은 구현 파일이 컨텍스트에 포함되기 때문에 블랙 박스 테스트 원칙 준수 어려움
          + Sonnet 3.7(Cursor 사용)의 경우 코드 일관성을 유지하려는 경향 → 테스트 파일의 중복 제거 시도
               o 그러나 블랙 박스 테스트에서는 중복 유지가 버그 탐지에 유리함
     * 이상적인 해결책
          + LLM이 로드한 파일에서 구현 세부 정보를 마스킹 또는 요약 가능해야 함
          + 아키텍트가 정보 은닉 경계를 명확히 정의해야 함
     * Example
          + Sonnet 3.7이 실패한 테스트 수정 시 하드코딩된 상수를 원본 알고리즘 기반으로 계산하도록 수정
               o 원래 상수를 그대로 유지해야 했음

MCP 서버 사용 (Use MCP Servers)

     * Model Context Protocol(MCP) 서버는 LLM이 환경과 상호작용할 수 있는 표준 인터페이스 제공
          + Cursor 에이전트 모드 및 Claude Code에서 MCP 서버를 광범위하게 사용
          + 별도의 RAG 시스템 없이 LLM이 MCP 호출로 필요한 파일 검색 및 수정 가능
          + 모델이 테스트 또는 빌드를 수행한 후 즉시 문제 수정 가능
     * 사용자 정의 MCP 서버 작성 고려 사항
          + Cursor에서 YOLO 모드 활성화 후 Cursor 규칙에 셸 명령 추가 가능
               o 위험함 → 임의의 셸 명령이 환경을 손상시킬 수 있음
          + 대안: 특정 명령만 노출하는 사용자 정의 MCP 서버 작성 → 안전성 강화
               o 단, 2025년 3월 기준 Cursor에서 프로젝트별 MCP 서버 설정은 미흡
     * Example
          + Sonnet 3.7이 TypeScript 프로젝트 타입 체크 및 오류 수정 시 MCP 사용
               o 터미널 출력을 수동으로 복사-붙여넣기할 필요 없이 자동 처리
               o 그러나 잘못된 명령(npm run typecheck)을 추론하는 경우 발생 가능

준비 리팩토링 (Preparatory Refactoring)

     * 준비 리팩토링은 변경 작업 전 먼저 리팩토링을 수행해 작업을 쉽게 만드는 전략
          + 리팩토링은 의미 보존 작업이므로 실제 변경보다 평가가 용이함
          + 먼저 리팩토링 후 변경 작업 수행 → 검토 및 오류 수정이 쉬워짐
     * 현재 LLM의 문제점
          + 사전 리팩토링 없이 모든 작업을 한 번에 처리하려는 경향
          + 필요 없는 정리 작업까지 수행 → 과도한 리팩토링 발생 가능
          + Cursor Sonnet 3.7은 명령 수행 정확도가 떨어짐 → 비관련 리팩토링 발생 가능
     * 개선 방안
          + LLM이 수정 전 리팩토링 단계에서만 코드 수정하도록 명시적 지시 필요
          + LLM이 편집할 코드 범위를 명확히 정의 → 불필요한 수정 방지
     * Example
          + LLM에 import 오류 수정 지시 → 수정 후 람다 함수에 타입 주석 추가
               o 주석 중 일부가 잘못 추가돼 에이전트 루프 발생

미장 플라스 (Mise en Place)

     * 요리에서 미장 플라스는 작업 전에 모든 재료와 도구를 정리해두는 것
     * LLM에서 미장 플라스는 작업 전에 필요한 규칙, MCP 및 개발 환경을 완전히 설정하는 것
          + Sonnet 3.7은 깨진 환경을 고치는 데 취약함
          + StackOverflow에서 명령어 복사-붙여넣기로 문제 해결 시도 → 환경 손상 위험
          + 작업 전에 환경을 올바르게 설정해 Sonnet이 디버깅 루프에 빠지지 않도록 해야 함
     * Example
          + npm link 문제로 VSCode에서 다른 로컬 프로젝트의 import 인식 실패
               o Cursor가 lint 및 테스트 수정 중 이 문제 해결에 집착했으나 npm unlink 실행 필요성 인식 실패

상태 없는 도구 사용 (Stateless Tools)

     * 도구는 상태를 저장하지 않고 매번 독립적으로 실행되어야 함
          + 셸은 현재 작업 디렉토리 상태에 의존 → 상태 저장으로 인한 혼란 발생 가능
          + Sonnet 3.7은 현재 작업 디렉토리 상태를 정확히 추적하지 못함
          + 모든 명령을 프로젝트 루트 디렉토리에서 실행 가능하도록 설정 필요
     * 개선 방안
          + 상태 변경이 필요한 도구 명령어 사용 최소화
          + 상태가 반드시 필요한 경우 현재 상태를 모델에 지속적으로 제공해 일관성 유지
     * Example
          + TypeScript 프로젝트가 common, backend, frontend의 세 모듈로 구성된 경우
               o Cursor가 루트에서 실행 시 적절한 디렉토리로 cd 필요 → 디렉토리 혼란 발생
               o 각 모듈을 개별 작업공간으로 열어 작업하니 문제 해결됨

스펙 준수 (Respect the Spec)

     * 시스템 변경 시 수정 가능한 부분과 수정 불가능한 부분을 명확히 구분해야 함
          + 공개 API 수정 시 하위 호환성 깨짐 방지 필요
          + 외부 시스템과 통합 시 실제 존재하는 API에 맞춰야 함 → 원하는 대로 수정 불가
          + 테스트 실패 시 테스트 삭제 금지 → 원인을 파악하고 수정해야 함
     * LLM의 문제점
          + 명세 위반 가능성 높음 → 테스트 삭제, API 변경 등 자유롭게 수행
          + 명세 준수는 상식적이지만 프롬프트에 명시해야 할 수도 있음
          + 일부 경계는 코드 리뷰를 통해만 발견 가능
     * Example
          + Sonnet이 테스트 수정 실패 후 테스트 내용을 assert True로 대체
          + public 함수가 pass 키를 포함한 dict 반환 → Sonnet이 pass_로 변경 시도 (예약어 문제)

불도저 방식 (Bulldozer Method)

     * 불도저 방식은 단순 반복 작업을 통해 문제를 해결하고 학습 효과로 속도를 높이는 전략
          + AI 코딩은 본질적으로 반복 작업에 강함 → 충분한 토큰 사용 시 대규모 리팩토링 가능
          + 사람이 ""너무 작업량이 많다""며 포기한 문제도 LLM이 해결 가능
          + 단, LLM은 같은 작업을 반복할 수 있으므로 실제로 무엇을 하고 있는지 검토 필요
     * Example
          + Haskell이나 Rust에서 핵심 함수 수정 시 광범위한 리팩토링 필요
               o LLM이 컴파일 오류 읽기 → 수정 → 다시 컴파일 과정을 자동화 가능
          + 하드코딩된 테스트 값 수정 시 LLM이 테스트 재실행 후 자동 수정 수행

메멘토 (Memento)

     * LLM은 상태를 기억하지 못함 → 매 작업마다 코드베이스를 처음부터 다시 이해해야 함
          + 프롬프트, 명시적/암시적 컨텍스트, 에이전트 모드에서 모델이 불러온 파일만으로 작업 수행
          + 매 작업마다 코드베이스를 재이해 → 초기 설정 실패 시 오작동 가능성 높음
     * 문제 방지 전략
          + LLM이 참조할 수 있는 문서를 명확히 제공
          + 모델이 필요한 정보를 쉽게 찾을 수 있도록 설정
          + 프로젝트 전체 맥락을 제공한 후 주요 변경 요청 수행
     * Example
          + Sonnet 3.7에 기존 프로젝트의 엔드 투 엔드 테스트 계획 수립 요청
               o 프로젝트의 전체 목적이 테스트라고 오해 → README를 테스트 중심으로 수정

요구 사항 명확화 (Requirements, not Solutions)

     * 소프트웨어 엔지니어링에서 흔한 실수는 요구 사항을 명확히 정의하지 않고 바로 해결책을 제안하는 것
          + 문제 공간이 충분히 제한되면 요구 사항만 명확히 정의해도 해결책이 자동으로 결정됨
          + 요구 사항이 명확하지 않으면 해결책에 대해 불필요한 논쟁 발생 가능
     * LLM의 문제점
          + LLM은 요구 사항을 알지 못함 → 훈련된 패턴에서 가장 확률이 높은 답변 생성
          + 명확한 요구 사항 없이 작업 요청 시 엉뚱한 결과 발생 가능
          + 프롬프트 수정으로 잘못된 해석 수정 가능 → 잘못된 해석이 컨텍스트에 남아 있으면 수정 어려움
     * 개선 방안
          + 특정 방식의 해결책이 필요하면 이를 명시적으로 지시
          + LLM은 명령을 정확히 따르므로 잘못된 방식으로 지시하면 부정확한 결과 발생 가능
     * Example
          + Sonnet에 시각화 생성 요청 시 기본적으로 SVG 생성
               o ""상호작용 가능"" 명시 시 React 기반 애플리케이션 생성 → 키워드 하나로 큰 차이 발생

과학적 디버깅 (Scientific Debugging)

     * 버그 수정 방식은 두 가지로 나뉨
          + 무작위로 수정 시도 후 운에 맡김
          + 시스템 작동 방식을 논리적으로 분석해 실제 상태와 예상 상태의 불일치 원인 파악
          + 과학적 디버깅(논리적 분석)이 장기적으로 더 나은 접근 방식
     * LLM의 문제점
          + LLM은 추론 능력이 부족해 과학적 접근이 어려움
          + ""정답 추측"" 후 바로 수정 시도 → 실패 시 무작위 수정 반복(에이전트 루프)
          + 디버깅은 Grok 3, DeepSeek-R1 같은 추론 모델이 더 적합
     * 개선 방안
          + 모델이 원인을 분석하도록 명령하거나 사용자가 원인 제공 → 수정 성공률 향상
          + 문제 원인을 정확히 알려주면 모델이 더 나은 해결책 제안 가능
     * Example
          + Sonnet 3.7이 pip가 없는 기본 uv 환경에서 패키지 설치 오류 발생
               o 원인 파악 실패 후 무작위 시도 반복 → 토큰 낭비 및 디버깅 실패

자동 코드 포맷팅 사용 (Use Automatic Code Formatting)

     * 자동 코드 포맷팅 도구(gofmt, rustfmt, black 등)는 일관된 코드 스타일 유지에 유용
          + LLM은 기계적인 규칙(예: 빈 줄에 공백 없음, 78자 줄 길이 제한 등) 준수에 취약
          + 포맷팅은 도구에 맡기고 LLM은 복잡한 작업에 집중하도록 해야 함
     * 린트 수정에도 동일 원칙 적용
          + 자동 수정 가능한 린트 사용 권장
          + LLM의 리소스를 복잡한 문제 해결에 집중하도록 할 것

꼬리가 개를 흔든다 (The Tail Wagging the Dog)

     * 사소한 문제가 더 중요한 문제를 좌우하는 상황을 의미
          + 저수준 문제 해결에 집착해 전체 코드 작성 목적을 잊어버리는 경우 발생 가능
          + LLM은 채팅 세션에서 모든 정보를 컨텍스트에 포함 → 중요도 판단 어려움
     * 개선 방안
          + 초기에 명확한 프롬프트 제공 → LLM이 중요한 작업에 집중하도록 유도
          + Claude Code는 하위 에이전트를 통해 특정 작업을 수행해 글로벌 컨텍스트 오염 방지
     * Example
          + LLM에 특정 작업 방법을 생각해보라고 요청 시 생각이 아닌 실제 작업 수행 시도 발생 가능

파일 크기 작게 유지 (Keep Files Small)

     * 코드 파일 크기에 대한 논쟁은 오래 지속됨
          + 단일 책임 원칙(파일당 하나의 클래스) 적용 vs 상황에 따라 대형 파일 허용
          + 파일 크기가 너무 크면 RAG 시스템에서 파일 단위 컨텍스트 로딩 시 문제 발생 가능
          + Cursor 같은 IDE에서 패치 적용 실패 가능 → 성공해도 적용 시간 길어짐
               o 예: Cursor 0.45.17에서 64KB 파일의 55개 수정 적용에 상당한 시간 소요
          + Sonnet 3.7은 128KB 이상의 파일 수정이 어려움(컨텍스트 윈도우 200K 토큰 제한)
     * 개선 방안
          + 파일 크기를 작게 유지 → LLM이 자동으로 import 등 처리 가능
     * Example
          + Sonnet 3.7이 471KB의 Python 파일에서 작은 테스트 클래스 이동 시도
               o 수정은 작았으나 Cursor 패처에서 수정 적용 실패

한계를 인식하기 (Know Your Limits)

     * 도구 부족이나 역량 한계 상황에서 문제를 인식하고 도움 요청 필요
          + Sonnet 3.7은 자신의 한계를 인식하는 데 약함
          + 명확한 프롬프트 제공 시 한계 인식 가능 → 특정 주제에서 환각 발생 경고 설정 필요
     * 문제점
          + Sonnet 3.7은 자신이 셸 명령 실행 가능하다고 잘못 인식
               o 셸 명령이 없을 경우 무작위 셸 스크립트 생성 시도 → 환경 손상 위험
               o ""X를 실행하겠다""라고 말한 후 완전히 다른 Y에 대한 호출 생성 발생 가능
     * 개선 방안
          + 프롬프트 수정 또는 원하는 작업만 수행하는 전용 도구 제공
               o 특정 도구 제공 시 엉뚱한 셸 호출 방지 가능
     * Example
          + Sonnet 3.7이 파일 실행 권한 부여 시 엉뚱한 셸 스크립트 생성 시도
               o 명령 오류 발생 후 잘못된 수정 시도 반복 발생

문서 읽기 (Read the Docs)

     * 새로운 프레임워크나 라이브러리 학습 시 튜토리얼 코드 수정으로 간단한 작업 가능
          + 하지만 궁극적으로는 문서를 처음부터 끝까지 읽어 전체 동작 방식 이해 필요
     * LLM의 장점
          + 인기 있는 프레임워크는 사전 학습된 경우가 많아 대부분의 사용법을 기억
          + 그러나 비주류 도구나 지식 컷오프 이후에 나온 도구는 환각 발생 가능
          + Sonnet은 웹 검색 미지원 → 수동으로 문서 제공 필요
               o Cursor에서는 URL 제공 시 자동으로 컨텍스트에 포함 가능
     * Example
          + LLM에 Python 함수 호출을 위한 YAML 작성 요청 시 잘못된 설정 생성
               o 문서 제공 후 수정 성공 및 출력 형식 개선
               o

문화가 전략을 이긴다 (Culture Eats Strategy)

     * 팀의 문화가 전략 실행 능력에 결정적 영향 미침
          + LLM은 미리 학습된 스타일과 컨텍스트 윈도우에 따라 코드 생성
          + 컨텍스트에 자주 등장하는 라이브러리나 스타일 선호
               o 명시되지 않으면 기본 스타일 적용
     * LLM 스타일 수정 전략
          + Cursor 규칙 수정(프롬프트 변경)
          + 기존 코드 스타일을 원하는 형태로 리팩토링 → 다음 토큰 예측에 영향
          + 코드베이스 크기가 프롬프트보다 더 큰 영향 → 코드베이스 수정이 근본 해결책
     * Example
          + Sonnet 3.7은 Python에서 동기 코드를 선호
               o 비동기 코드 생성을 위해 기존 코드 대부분을 async로 포팅 후 성공

워킹 스켈레톤 (Walking Skeleton)

     * 워킹 스켈레톤은 최소한의 엔드 투 엔드 시스템 구현 전략
          + 완벽하지 않아도 전체 시스템이 동작하게 만든 후 세부 개선 진행
          + LLM 코딩 시대에는 전체 시스템을 빠르게 구축하기 더 쉬워짐
          + 시스템이 작동하면 다음 단계가 명확해짐 → 빠르게 작동 상태에 도달하는 것이 중요
          + LLM은 작성한 코드를 직접 사용할 수 없기 때문에 동작 상태 확보가 중요

세 번째 규칙 (Rule of Three)

     * 동일 코드 복제는 두 번까지 허용, 세 번째 복제 시 리팩토링 필요
          + DRY(Don't Repeat Yourself) 원칙의 개선된 버전
          + 중복 제거 시점 명확화 → 세 번째 복제에서 리팩토링 수행
     * LLM의 문제점
          + LLM은 코드 중복 생성 경향
          + 프롬프트 없이 수정 요청 시 코드 전체를 새로 복제해 수정 수행
          + 중복 제거는 모델이 자발적으로 결정해야 수행됨 → 명확한 지시 필요
     * 개선 방안
          + 명시적으로 중복 제거 지시 필요
          + 기존 코드에 중복이 많으면 모델이 중복을 계속 생성할 수 있음
     * Example
          + LLM에 테스트 코드 작성 요청 시 동일 로직이 여러 테스트에 중복 발생
               o 명시적으로 보조 메서드 생성 지시 후 해결됨
               o 에이전트 모드

        Hacker News 의견

     * LLM은 인간과 다른 방식으로 실수를 하며, 이를 잡아내기 어려움
          + 인간의 실수를 잡아내는 데는 오랜 경험이 있지만, LLM의 사고방식을 이해하기 어려움
          + LLM의 오류를 잡아내는 시스템 설계가 어려움
     * LLM은 요구사항을 모르면 훈련 데이터에서 가장 가능성 있는 답을 채워 넣음
          + 고객이 원하는 것을 정확히 설명해야 AI가 프로그래머를 대체할 수 있음
     * 소프트웨어 엔지니어링에서 요구사항을 명확히 하는 것이 중요함
          + 요구사항을 명확히 하면 해결책이 자연스럽게 결정됨
          + 새로운 프레임워크나 라이브러리를 배울 때는 문서를 꼼꼼히 읽는 것이 좋음
          + 버그를 고칠 때는 시스템의 가정을 체계적으로 검토하는 것이 중요함
          + 코드 중복은 세 번째 발생 시 리팩토링하는 것이 좋음
     * LLM은 ""매우 똑똑한 초급 프로그래머"" 수준의 코딩 능력을 가짐
          + 큰 그림을 보는 능력이 부족하고, 요청된 것만 수행함
          + 모델은 계속 개선될 것으로 예상됨
     * LLM은 너무 많은 답변을 하려고 함
          + 충분한 데이터를 주지 않으면 잘못된 답변을 생성함
          + LLM이 ""더 많은 정보가 필요함""이라고 말할 수 있으면 좋겠음
     * 블로그의 게시물이 많아지면서 정리가 필요함
          + 좋은 조직 시스템을 찾지 못했음
     * LLM과 코딩할 때의 유용한 조언
          + 정적 타입 사용에 대한 의견 차이 있음
          + Clojure가 Typescript보다 더 나은 결과를 줌
          + LLM은 함수 중심의 접근 방식에 더 적합함
     * LLM은 계산과 산술에 약함
          + 코드 생성 시 정확한 위치에서 숫자를 가져오는 것이 중요함
          + LLM이 생성한 코드를 디버깅하는 데 시간이 걸림
     * 인간 코더와 함께 고려해야 할 사항
          + 제품 관리자도 주목해야 함
     * 세 가지 LLM이 존재하지 않는 ""버그""를 발견한 사례
          + 최적화된 코드는 아니지만 버그는 아님
          + 코드 블록 간의 거리가 짧았음
"
"https://news.hada.io/topic?id=19852","SpaceX의 Crew-9 지구 귀환","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          SpaceX의 Crew-9 지구 귀환

        Hacker News 의견

     * 드론 영상이 정말 놀라움. 복구 보트에서의 다른 카메라 각도보다 훨씬 뛰어남. CGI가 아닌지 의심했음
     * 어떤 드론이나 카메라 장비가 사용되었는지 정보가 궁금함
     * 기사에 역사적 부정확함이 있음
          + 아폴로 프로그램이 1960년대에 나라를 하나로 묶었다는 것은 100% 사실이 아님
          + 일부 커뮤니티는 아폴로 프로그램에 반대했음
          + 그러나 전반적으로 프로그램의 진전은 결국 그 커뮤니티에도 도움이 되었음
          + 아폴로 1호의 비극적 사고와 같은 프로그램의 문제점에도 불구하고 양당의 합의가 있었음
          + 케네디의 성격이 큰 도움이 되었음
          + 1960년대가 격동의 시기였다는 주장도 정확하지 않음
          + 1970년대가 국내 테러리즘의 증가로 인해 더 격동적이었음
     * 우주비행사들이 안전하게 돌아온 것에 대해 기뻐할 수 없을까?
     * 진실을 알아내기 위해 ""보고""가 필요하다는 점이 혼란스러움
          + 우주비행사나 NASA에 직접 물어볼 수 없을까?
          + 공식 성명이 없는 이유가 궁금함
          + Butch가 Musk의 설명이 ""완전히 사실적""이라고 말한 영상이 있음
          + 그러나 그 후 약간 말을 번복했음
          + 아무도 사건에 대해 명확히 설명하고 싶어하지 않는 것 같음
     * Elon을 싫어할 수 있지만, SpaceX의 훌륭한 성과는 인정해야 함
     * Eric Berger가 내러티브에 대한 좋은 요약을 제공함
     * 훌륭한 결말을 가진 놀라운 이야기임
          + 예전에는 HN에서 최고의 토론이었음
          + 지금은 당파적 논쟁으로 변질된 것이 슬픔
     * 우주비행사가 더 이상 어릴 때 생각했던 멋진 직업이 아니라고 결정함
     * 드로그 슈트가 펼쳐질 때의 환호는 엔지니어가 느낄 수 있는 최고의 안도감일 것임
          + 수년간 계획하고 테스트하며 서로의 작업을 검증할 수 있지만, 결국 생명이 걸린 순간에는 모든 것이 잘 되기를 바라는 것뿐임
          + SpaceX 팀과 NASA의 또 다른 성공적인 착수에 축하를 보냄
     * 이름을 짓는 데 관여했다면 ""from Outer Space""를 추가했을 것임
"
"https://news.hada.io/topic?id=19979","Dokploy - Vercel, Heroku, Netlify의 오픈소스 대체제","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Dokploy - Vercel, Heroku, Netlify의 오픈소스 대체제

     * 무료이며 자체 호스팅 가능한 Platform as a Service(PaaS)
     * 애플리케이션과 데이터베이스의 배포 및 관리를 간편하게 처리하며, 클라우드 서비스 의존 없이 자체 서버에서 운영 가능
     * 언어: Node.js, PHP, Python, Go, Ruby 등 지원
     * DB: MySQL, PostgreSQL, MongoDB, MariaDB, Redis 지원
     * 백업 자동화: 외부 저장소로의 DB 백업
     * Docker Compose 지원: 복잡한 앱을 손쉽게 관리 가능
     * 멀티 노드 확장: Docker Swarm으로 클러스터 확장 가능
     * 1클릭 템플릿 배포: Plausible, Pocketbase, Calcom 등 오픈소스 템플릿 제공
     * Traefik 통합: 자동 라우팅 및 로드 밸런싱 지원
     * 실시간 모니터링: CPU, 메모리, 저장소, 네트워크 사용량 실시간 확인
     * Docker 컨테이너 관리: GUI 없이 손쉽게 Docker 앱 운영 가능
     * CLI 및 API: 커맨드라인 또는 API를 통한 제어 가능
     * 배포 알림: Slack, Discord, Telegram, 이메일 등으로 배포 상태 알림 수신
     * 멀티 서버 배포: 외부 서버로 원격 배포 및 관리 가능
     * 자체 호스팅 지원: VPS에 Dokploy 자체 설치 가능

   https://news.hada.io/topic?id=4138

   Coolify 라는 친구도 있습니다.

   너무 좋은데요? 이런거까지 오픈소스로 있다니ㅎㅎ

   도커 데스크탑도 kubernetes 쓰는 시대에 docker swarm만 지원하는건 좀 아쉽네요.

     ERROR: Unsupported distribution 'manjaro'

   테스트 해보려고 했더니. Manjaro는 지원하지 않는군요. 살짝 아쉽습니다만.
"
"https://news.hada.io/topic?id=19918","극지방의 소용돌이가 브레이크를 밟고 있다","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         극지방의 소용돌이가 브레이크를 밟고 있다

     * 극지 소용돌이 블로그는 성층권의 극지 소용돌이를 모니터링하고 예측하는 것에 관한 블로그로, 이들이 극한 겨울 날씨와 계절 기후에 미치는 영향에 대해 설명함

폴라 보텍스의 감속 현상

     * 이번 겨울 시즌 동안 60°N 지역에서의 폴라 보텍스 바람은 성층권 북극 지역을 빠르게 순환했음
     * 특히 2월에는 이러한 서에서 동으로 부는 바람이 평균보다 두 배나 강했음
     * 하지만 최신 예보에 따르면 이번 주말에 폴라 보텍스에 큰 교란이 발생하면서 바람이 급격히 약해질 것으로 예상됨

성층권에서의 변화

     * 현재 폴라 성층권의 서에서 동으로 부는 바람은 여전히 빠르게 불고 있음
     * 하지만 이번 주말에 바람이 급격히 멈춘 후, 강하게 반대 방향(동에서 서로)으로 전환될 것으로 보임
     * 60°N 및 10 hPa(약 19마일/30km 상공)에서 이런 바람 반전이 일어날 경우 돌발 성층권 온난화(Sudden Stratospheric Warming, SSW) 현상이 발생함
     * 돌발 성층권 온난화는 성층권 온도가 짧은 기간 동안 급격히 상승하는 현상임
     * 이번 사건에서는 중간 성층권 온도가 5일 이내에 약 45°F(25°C) 상승할 수 있음

폴라 보텍스 교란의 영향

     * 돌발 성층권 온난화는 두 가지 유형으로 발생할 수 있음
          + 폴라 보텍스가 중심에서 이동(편위)함
          + 폴라 보텍스가 두 개의 작은 보텍스로 쪼개짐
     * 이번 사건에서는 두 가지 현상이 모두 나타날 가능성이 있음
          + 초기 온난화는 폴라 보텍스가 유럽 쪽으로 이동하면서 시작될 것으로 보임
          + 이후 며칠 뒤에는 보텍스의 일부가 주요 덩어리에서 떨어져 나갈 것으로 예상됨

        Hacker News 의견

     * ""3월의 갑작스러운 온난화 영향은 한겨울과 매우 유사하지만, 봄이 오고 있어 미국에 내려오는 북극 공기가 1월에 비해 덜 춥게 느껴질 것임""이라는 부분이 이해가 잘 안 됨. ""따뜻한 시기""라는 것이 무엇을 의미하는지 설명이 필요함. 더 많은 햇빛으로 인한 온난화 증가를 의미하는 것인지 궁금함
     * 두 개의 첫 번째 그래프에서 관찰된 변동 범위가 상당히 인상적임
     * 흥미로운 기사임. 내가 있는 곳은 보통 -20도 이하의 6주를 지나서 전형적인 해처럼 느껴짐. Rankin Inlet NU 같은 북쪽의 무작위 장소를 선택하면 여전히 오늘 밤 최저 -33도로 추운 상태임
     * ""climate.gov""가 신뢰할 수 있는 출처인지 의문이 드는 시대의 징조임
     * 3월 6일부터
     * 마치 그라운드호그보다 봄을 더 잘 나타내는 지표가 있는 것 같음
     * 이것이 좋은 것인지 나쁜 것인지 궁금함
     * 궁극적으로 지구는 따뜻해지고, 빙하가 녹으며, 해수면이 10m 상승하면서 해안이 손실될 것임
     * climate.gov가 아직 내려가지 않은 것이 놀라움
     * [flagged]
     * [flagged]
"
"https://news.hada.io/topic?id=19870","네덜란드 의회, 미국 기술 대신 자국 기술 채택 촉구","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     네덜란드 의회, 미국 기술 대신 자국 기술 채택 촉구

     * 네덜란드 의회는 미국 기술 대신 자국 기술을 채택하자는 8개의 결의안을 통과시킴. 이는 정부 데이터가 해외로 전송되는 것에 대한 우려에서 비롯됨
     * 결의안은 미국 기술 기업의 소프트웨어와 하드웨어를 대체하고, 네덜란드 기업과 새로운 계약을 체결하며, 국가의 디지털 주권을 보호하자는 내용임
     * 네덜란드 MP 바바라 카트만은 미국 클라우드 서비스로의 정보통신기술 이전을 중단하고, 네덜란드 국가 클라우드의 창설, .nl 도메인의 네덜란드 내 시스템으로의 복귀 등을 제안함.
     * 트럼프 행정부의 국제적 태도가 공격적으로 변하면서, 유럽 내 미국 기술 의존에 대한 우려가 커지고 있음
     * 네덜란드 의회는 미국 기술에 대한 의존을 줄이기 위한 조치를 고려하고 있으며, 이는 유럽연합의 기술 주권을 위한 긴급한 지정학적 문제로 부각됨.

    정부의 실제 행동 여부

     * 네덜란드 정부가 행동에 나설 경우, 네덜란드는 미국 기업으로부터 기술 스택을 되찾는 첫 번째 유럽 국가가 될 가능성이 있음.
     * 결의안은 법적 구속력이 없지만, 의회에서 통과된 8개의 결의안을 무시하는 것은 거의 전례가 없음.
     * 정부는 이미 정보 제공 및 디지털화 정책을 실행하는 데 있어 협력을 강화하자는 별도의 결의안을 수용함. 이는 미국 기술 기업으로부터의 투자 철수를 언급하지 않지만, 정부가 주의를 기울이고 있음을 시사함.

    추가 정보

     * 네덜란드 의회는 미국 기술에 대한 의존을 줄이기 위한 계획을 개발 중이며, 이는 미국의 정치적 압박이 증가하면서 더욱 시급해짐.
     * 트럼프 행정부의 빅 테크 독점 사용과 유럽 기술 법률에 대한 공격이 네덜란드 정치에 충격을 주었음.

        Hacker News 의견

     * 데이터 주권이 다음 10년의 진정한 트렌드임. 양자 컴퓨팅이나 AI가 아니라, 미국 중심의 기술에서 벗어나 지역 경제에 집중하는 새로운 다극 세계 질서가 형성되고 있음
          + 냉전 시대의 아이들이 익숙할 법한 지역 경제를 위한 지역 공급업체들이 등장하고 있음
          + 미국 중심의 기술 카탈로그는 장기적으로 신뢰할 수 없으며, 나쁜 행정부 하나가 ""일상적인 비즈니스""를 방해하거나 적대적인 국가 행위자로 변할 수 있음을 경고해 왔음
          + 이제 그 경고가 현실이 되었음
     * 유럽 국가들이 Microsoft, Google, Amazon, Oracle 등에 돈을 쓰기보다는 오픈소스 소프트웨어에 수십억 달러를 투자했어야 했음
          + 유럽 국가들은 수십 년 동안 미국의 클라이언트 국가였으며, 미국이 원하는 대로 해왔음
          + 이제 미국이 자국의 이익을 해치자, 유럽 국가들이 깨어나고 있음
     * 드디어 한 의회가 지역 기술에 투자하고 지역에 공정한 기회를 주려고 함
          + Azure가 많은 문제를 해결하지만, 지역 시장에 일부 투자를 다각화하는 것이 지역 경제와 지식 성장에 도움이 될 것임
          + 성공하길 바람
     * 문제를 예방하기보다는 문제가 부인할 수 없을 때만 행동하는 것이 항상 놀라움
          + 미국처럼 투표 시스템과 권력 구조가 있는 나라에서는 한 사람이 국가의 방향을 급격히 바꿀 수 있음
          + 러시아 가스에 의존하는 것과 같음. 최악의 상황이 발생할 수 없다고 믿다가 결국 발생함
     * 이 게시물이 삭제될지 궁금함. 이전에 유럽 기술 주권에 대한 논의가 이 미국 웹사이트에서 삭제된 적이 있음
     * 솔직히, 이것이 올바른 방향이라고 느끼지만, 점점 더 많은 정치인들이 ""미국이 나쁘다""는 이유로 표를 얻으려 함
          + 기업들은 ""EU 제작"" 라벨을 마케팅으로 사용하려고 함, 심지어 90%의 운영이 EU 외부에서 이루어지더라도
          + 미국과의 분리가 하룻밤 사이에 이루어지는 간단한 일이 아님. 일부 영역에서는 느린 과정이며, 실용적인 결정을 내려야 함
     * 우리가 싫어했던 군산복합체? 이제는 원하고 있음
     * 어제 대형 언어 모델의 효과적인 사용에 대한 워크숍을 진행했음. 많은 네덜란드 기업들이 참여했음
          + 비미국 LLM에 대한 수요가 많음. DeepSeek을 제안했지만 중국산임. Mistral을 제안했지만 프랑스산임(농담!)
          + 유럽 컨소시엄의 OpenGPT-X를 발견했지만 아직 미성숙함
          + 유럽 DeepSeek 복제본이 곧 나올 수도 있음. 구축 비용이 저렴할 것임. 그러나 이는 생태계의 한 부분일 뿐이며, 많은 디지털 인프라가 필요함
     * 대체할 것은 무엇인가, 더 많은 규제인가?
          + 출처: EU의 스타트업임. 관료주의가 카프카적임
     * 관련 기사:
          + ""네덜란드 의회, 미국 소프트웨어 의존 중단 촉구""
          + ""네덜란드 정부, '안전하지 않은' 미국 클라우드 서비스 사용 중단 촉구""
"
"https://news.hada.io/topic?id=19909","컴퓨터 비전으로 구현한 OpenStreetMap의 지도 기능","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   컴퓨터 비전으로 구현한 OpenStreetMap의 지도 기능

     * Mozilla.ai는 인공지능(AI)이 오픈 협업을 통해 커뮤니티를 강화할 수 있는 많은 기회를 제공한다고 믿음.
     * 이러한 기회는 신중하게 설계되어야 하며, AI의 과도한 사용에 대한 우려가 증가하고 있음.
     * 이러한 배경에서 OpenStreetMap AI Helper Blueprint를 개발 및 출시
     * 왜 OpenStreetMap인가?
          + 데이터는 AI 응용 프로그램의 중요한 구성 요소이며, OpenStreetMap은 가장 완전한 오픈 맵 데이터베이스를 유지하는 활발한 커뮤니티를 보유하고 있음.
          + OpenStreetMap은 도로, 철도역 등 다양한 데이터를 제공하며, 위성 이미지와 결합하여 다양한 AI 모델을 훈련할 수 있는 무한한 가능성을 제공함.
          + AI를 사용하여 지도 작성 과정의 느린 부분을 가속화하고, 중요한 부분에서는 인간의 검증을 유지하는 것이 목표임.
     * 왜 컴퓨터 비전인가?
          + 많은 지도 기능은 다각형으로 표현되며, 이를 찾고 그리는 작업은 시간이 많이 소요됨.
          + 컴퓨터 비전 모델은 충분한 데이터가 제공되면 이러한 작업을 쉽게 수행할 수 있음.
          + YOLOv11과 SAM2 모델을 사용하여 객체 감지 및 세분화 작업을 수행하며, 이 모델들은 가볍고 빠르며 로컬 친화적임.
     * OpenStreetMap AI Helper Blueprint
          + 1단계: OpenStreetMap에서 객체 감지 데이터셋 생성
               o OpenStreetMap 데이터를 위성 이미지와 결합하여 훈련에 적합한 형식으로 변환.
               o Nominatim API와 Overpass API를 사용하여 관심 지역의 데이터를 다운로드하고, Ultralytics YOLO 형식으로 저장.
          + 2단계: 객체 감지 모델 미세 조정
               o YOLOv11 모델을 미세 조정하고, Hugging Face Hub에 업로드.
          + 3단계: OpenStreetMap에 기여
               o 미세 조정된 모델을 사용하여 여러 타일에서 추론을 실행하고, 새로운 객체를 수동으로 검증 후 OpenStreetMap에 업로드.
     * 마무리 생각
          + OpenStreetMap은 커뮤니티 주도의 세계 지도를 만드는 오픈 협업의 강력한 예시임.
          + OpenStreetMap AI Helper Blueprint는 AI가 인간의 기여를 향상시킬 수 있음을 보여주며, 고품질 데이터의 가치를 강조함.
          + Blueprint를 사용하면 수작업보다 약 5배 더 많은 수영장을 같은 시간에 매핑할 수 있음.
          + 다른 지도 기능에 대한 모델 훈련을 실험해보기를 권장하며, 프로젝트에 기여하거나 확장할 수 있음.

   찾아보니 Map Feature는 보통 (지도) 지물로 번역하는 것 같더라고요.

        Hacker News 의견

     * OpenStreetMap Foundation에서 인사드림. AI로 감지된 기능을 데이터베이스에 직접 추가하지 말아야 함
          + 알고리즘은 오탐지 문제와 직선 또는 직사각형 객체를 흔들리게 매핑하는 문제를 가짐
          + 누락된 기능을 감지하는 도구로서 유용하지만, 감지된 객체가 올바르게 그려졌는지 확인하기 위해 인간의 개입이 필요함
          + 관련 가이드라인은 OpenStreetMap 위키에서 확인 가능함
     * 수영장 감지에 이어 태양광 감지도 시도해보고 싶음
          + OSM이 수작업으로 성장할 수 있다는 생각에 반대하는 의견이 많음
          + 10년 동안 60,000건의 변경을 했지만, 인간 자원봉사자의 열정만으로는 글로벌 스케일의 매핑을 해결할 수 없음
          + 데이터의 품질, 출처, 버그 보고 방법, 소비자 지침을 주석으로 달 수 있는 확장 가능한 프레임워크가 필요함
          + 예를 들어, ""지난 1년 동안 인간이 매핑한 유형 X의 비즈니스""를 쿼리하고 싶을 때, ""체크 날짜""로 어느 정도 가능함
          + 그러나 속성의 정확성이나 매퍼가 이름/위치만 확인했는지 알 수 없음
          + 매달 자동으로 데이터를 유지하기 위해 모든 장소의 영업 시간을 수집하는 것이 더 나을 수 있음
          + 신뢰할 수 있는 특정 출처만 필터링할 수 있다면 데이터 소비자로서 더 좋을 수 있음
          + AI로 추론된 POI와 같은 제한이 있어도 데이터를 사용할 수 있음
     * 자동 매핑을 직접 경험한 후 매우 경계하게 됨
          + 남미를 오토바이로 여행했는데, OSM에는 자동화된 것처럼 보이는 많은 편집이 있어 특정 지역에서는 거의 사용할 수 없음
          + 시골 도로뿐만 아니라 꽤 큰 도시에서도 발생함
     * 몇 년 전 이 분야에서 일한 경험이 있음
          + 많은 기존 모델, 데이터셋, 도구 등이 존재함
          + 관련 자료는 GitHub에서 확인 가능함
     * 우리는 위성 이미지에서 보이는 것을 매핑하는 것이 아니라, 실제 지상 정보를 매핑하고 있음
          + AI로 상상된 것을 기여하지 말아야 함
     * Google은 이를 허용하지 않지만, Mapbox는 비상업적 목적이나 OSM에 사용되는 경우 허용함
          + Mapbox의 위성 이미지를 사용하여 파생 벡터 데이터셋을 생성할 수 있음
     * Mozilla가 좋은 브라우저를 만드는 데 집중했으면 좋겠음
     * 몇 달 전 비슷한 작업을 했음 (작은 규모의 지리 데이터)
          + 관련 자료는 GitHub에서 확인 가능함
     * SAM/2를 미세 조정하여 수영장이나 태양광 배열을 감지하는 방법에 대한 세부 정보를 보고 싶음
          + 커뮤니티 회복력 프로젝트에 유용하지만 SAM2 미세 조정을 따라갈 수 없었음
          + Yolov8 모델은 태양광을 잘 찾고 분할하지만, 가장자리가 매우 나빠서 많은 작업이 필요함
          + SAM2로 훈련된 결과는 훨씬 나아 보임
          + 정확성 문제로 인해 OSM에 추가하지 않겠지만, 다른 곳에서 사용할 수 있음
     * 이를 '헤드업 디지타이징'이라고 불렀음
"
"https://news.hada.io/topic?id=19851","여가(Leisure)로서의 연구라는 잃어버린 예술","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      여가(Leisure)로서의 연구라는 잃어버린 예술

     ""아마추어 연구자들은 어디로 갔으며, 그들을 어떻게 되돌릴 수 있을까?""

문명의 문학적 기반

     * 샌프란시스코의 포트 메이슨에 위치한 Long Now Foundation의 Manual for Civilisation은 문명을 유지하거나 재건하는 데 필요한 3,500권의 책을 모은 도서관임
          + ""만약 외딴 섬이나 적대적인 소행성에 갇히게 된다면, 어떤 책을 가져가고 싶은가?""라는 질문에서 시작된 프로젝트
          + 이 컬렉션은 장엄하면서도 낙관적이고, 진지하면서도 허망한 느낌을 주며, 책이 문명을 형성하고 유지한다는 믿음을 상징함
     * 350년 전 갈릴레오는 책을 ""인류의 모든 놀라운 발명의 인장""이라고 묘사. 책은 시간을 초월해 후세와 소통할 수 있는 도구이며, 수천 년 후의 사람들과 대화할 수 있게 함
     * 헨리 데이비드 소로는 ""책은 세대와 문화의 귀중한 유산""이라고 표현. 책은 인간의 지식과 경험을 이어주는 역할을 함
     * 칼 세이건은 보이저 II호의 골든 레코드에 실린 베토벤의 Cavatina를 들으며 책의 존재에 경외감을 느낌. ""글쓰기는 아마도 인간의 가장 위대한 발명품일 것""이라며, 책은 과거와 미래의 사람들을 연결하는 마법과 같다고 함
     * 책이 신성하거나 특별한 지식을 담고 있기 때문이 아니라, 읽기와 쓰기를 통해 문화가 형성되고 발전하기 때문임
     * 책은 시간과 공간을 초월해 지식을 전달하며, 책이 없으면 문화가 존재할 수 없고, 문화가 없으면 문명도 존재할 수 없음

""읽으라""는 신의 명령

     * 문명의 개념은 아랍어에서 ""머무르다, 정착하다, 존재하다""를 의미하는 뿌리어 ح-ض-ر에서 유래됨. 이는 방랑에서 정착으로의 깊은 전환을 상징
     * 약 1,450년 전, 이슬람의 예언자 무함마드는 세 번에 걸쳐 ""읽으라""는 신의 명령을 받음
          + ""읽으라, 너를 창조하신 주님의 이름으로""라는 명령이 이슬람 문명의 시작이 됨
     * 이슬람의 기원은 인류 역사상 가장 정교하고 엄격한 구술 전승 체계를 통해 보존됨
     * 신의 명령은 단순한 문자 해독 이상의 의미를 가짐 → 읽기는 신과의 연결, 인간의 사명, 그리고 문명의 형성을 상징함

고독과 공동체 사이에서

     * 문자를 해독할 줄 모르는 사람에게 ""읽으라""는 명령은 읽기의 본질적 의미를 흔듦
     * 아랍어 ""Iqra""는 ""읽다""와 ""암송하다""의 두 가지 의미를 동시에 가짐
          + 읽다 → 개인적이고 사색적인 행위
          + 암송하다 → 외부로 표현되는 사회적이고 구술적인 행위
     * 앨런 제이콥스는 _Pleasures of Reading in the Age of Distractions_에서 읽기를 ""고독한 경험과 사회적 연결 사이의 이동""이라고 설명함
     * 현대에서의 사회적 연결은 다음과 같은 다양한 형태로 나타남:
          + 일기 작성, 블로그 게시, 독서 모임, 문학 살롱, 온라인 토론, 친구에게 보내는 편지 등
     * 좋은 아이디어는 사색과 연결의 균형에서 탄생함
     * 읽기는 단순한 개인적 사색에서 끝나서는 안 되며, 사회적 연결을 통해 인간의 지식 네트워크에 기여해야 함
     * 꾸란의 명령은 명확한 방향성을 가짐:

     ""읽으라, 너를 창조하신 주님의 이름으로. 인간을 응고된 핏덩이에서 창조하신 분. 읽으라! 가장 관대하신 주님이시며, 펜으로 인간에게 알지 못했던 것을 가르치신 분.""
     * 꾸란의 ""읽기"" 명령은 단순한 지식 습득이 아닌 ""경이로움에 대한 책임""을 의미함
     * 레베카 엘슨의 시 _We Astronomers_에서처럼, 읽기는 훈련된 탐구와 경이로움에 대한 열린 태도를 통해 이루어져야 함

마지막 독자의 긴 세기(Century)

     * 지난 100년 동안 ""읽기의 책임""은 문화적 불안의 원천이었음
     * 시대의 변화와 기술 발전이 독서 문화의 붕괴로 이어질 것이라는 우려가 꾸준히 제기됨
     * 버지니아 울프 (1926년)
          + 라디오와 영화가 새로운 미디어로 등장하면서 독서의 미래를 우려함
          + 울프는 영화가 즉각적인 쾌감을 제공하지만, 이는 인간의 원시적 본능에서 비롯된 것으로 문명에 반하는 행위라고 봄
          + 영화와 같은 오디오-비주얼 콘텐츠가 독서의 깊이를 침식할 것을 걱정함
     * E.B. 화이트 (1951년)
          + 텔레비전이 라디오를 대체하면서 독서의 미래를 걱정함
          + 롤린스 대학 총장이 ""50년 후 미국 인구의 5%만이 독서를 할 것""이라고 경고함
          + 화이트는 설령 한 명의 독자만이 남더라도, 그 사람이 새로운 문명의 중심이 되어야 한다고 주장함
          + 오디오-비주얼 미디어가 인간의 사고 능력을 약화시키고, 독서를 단순한 오락의 형태로 바꿀 것을 우려함
     * 수전 손택 (1996년)
          + 디지털 기술의 발전이 독서 문화를 근본적으로 변화시킬 것을 우려함
          + 책이 단순히 상호작용할 수 있는 ""텍스트""로 전락하고, 광고 기반의 시각적 현실에 흡수될 위험이 있다고 경고함
          + 손택은 책의 소멸이 아니라 ""내면성의 소멸""이 더 큰 문제라고 봄
     * 지난 100년 동안 기술의 발전 속도가 인간의 인지 능력을 따라잡지 못함
          + 해롤드 블룸, 모티머 J. 애들러, 닐 포스트먼 등도 읽기의 미래에 대한 불안감을 공유함
          + 그러나 실제로 도래한 미래는 예상보다 더 복잡함 → 책과 단어는 넘쳐나지만 일관된 문화와 의미는 결여됨
     * 독서의 위기 = 책의 소멸이 아닌 문화의 붕괴
          + 울프, 화이트, 손택은 책 자체가 사라질 것을 걱정한 것이 아님
          + 문제는 읽기가 몰입적이고 사색적인 행위에서 단순한 소비와 오락으로 변질되는 데 있음
          + 독서의 종말은 책의 소멸이 아니라, 문화의 상실로 이어짐

위기에 처한 문화

     * 울프, 화이트, 손택의 우려는 현실이 되었음
     * 책이 사라진 것이 아니라, 단편적인 주의력과 피상적인 참여로 인해 공유된 의미와 문화적 일관성이 붕괴됨
     * ""문화""의 정의는 그 현상만큼이나 유동적임
          + 제임스 볼드윈은 _Princes and Powers_에서 위기에 처한 문화만이 ""문화의 정의""를 필요로 한다고 주장함
     * 한병철은 _The Disappearance of Rituals_에서 의미를 만드는 구조와 형식이 사라졌다고 분석함
     * 그 결과 문명의 ADHD 현상이 발생함:
          + 세대 간 불안정함
          + 주의력 부족
          + 방향 없는 과도한 움직임
          + 통찰력의 부재와 일시적인 사고

여가로서의 연구: 엘리엇과 피퍼의 문화 회복론

     * T.S. 엘리엇은 제2차 세계대전 이후 영국에서 ""문화""를 세 가지 상호 의존적 요소로 설명함:
          + 개인
          + 집단
          + 사회
          + 이 세 요소가 서로 단절되면 고등 문명은 존재할 수 없음
     * 요제프 피퍼는 패전과 붕괴를 겪은 독일에서 여가는 문화의 기반이라고 주장함
          + 여가는 단순한 휴식이 아니라 고대 그리스어 ""σχολή (scholē)""에서 유래된 사색적 활동을 의미함
          + 피퍼의 여가는 자유로운 연구의 형식을 띰
               o 단순히 지식을 쌓기 위한 것이 아님
               o 경이로움과 열린 탐구 정신에서 출발함
               o 구체적인 질문을 설정하고 이에 답을 찾는 과정에서 문화가 형성됨
     * 엘리엇과 피퍼의 상호 보완적 접근
          + 엘리엇 → 문화의 외적 구조 설명
          + 피퍼 → 문화의 내적 조건 설명
          + 엘리엇의 구조적 일관성이 없으면 문화는 붕괴하고, 피퍼의 사색적 여가가 없으면 문화는 공허해짐
     * 여가로서의 연구의 가치
          + 읽기와 쓰기를 놀이적이면서도 의도적인 활동으로 재구성함
          + 여가로서의 연구는 경이로움, 호기심, 발견의 기쁨을 형식화함
          + 과거와 현재의 사상가들이 교류하면서 새로운 사회 패턴이 형성되고 재구성됨
     * 문화 재건의 열쇠
          + 단절된 문화 속에서 여가로서의 연구는 새로운 문화적 상상력을 열어줌
          + 의도적이고 열린 호기심에서 비롯된 아이디어 교류는 새로운 문화를 창조함

공허한 독서에 맞서기

     * 문화의 재건은 독서와 탐구를 학문적 의무가 아닌 놀이적이고 의도적인 호기심으로 바라보는 데서 시작됨
     * 독서는 부담스러운 일이 아니라 경이로움과 발견의 기쁨에서 비롯된 행위여야 함
     * 독서의 잘못된 형태
          + 1. 생산성 도구로서의 독서
               o 독서를 생산성 해킹으로 간주하는 경우
               o 자기계발서나 대중 소설의 소비를 통해 생산적인 이미지를 만들려는 경향
               o 독서를 현실 인식을 위한 도구가 아니라 단순한 오락으로 취급함
          + 2. 확증 편향으로서의 독서
               o 많은 독서가들이 자신의 기존 세계관을 강화하는 방식으로 독서를 함
               o 자신이 이미 믿고 있는 개념을 강화하기 위해 단편적인 아이디어만 수집함
               o 이는 지적 호기심을 억제하고, 깊이 있는 사고를 방해함
     * 공허한 독서에 맞서는 해법은 여가로서의 연구임
          + ""창조주의 이름으로 읽으라""는 신성한 명령에 대한 고결한 응답임
          + 연구는 삶의 모든 요소를 목적과 호기심으로 바라보게 하며, 신비와 경이로움에 대한 열린 자세로 지식을 탐구하게 함
          + 학문적 울타리를 벗어나 누구나 탐구자가 될 수 있음
     * 연구는 학문적 특권이 아니라 인간 본연의 활동임
          + 연구는 모험, 기술, 사교적 교류를 통해 문화를 형성함
          + 전문가가 아닌 사람들도 전문성을 지향해야 하며, 누구나 연구자가 될 수 있음

이론에서 실천으로: 여가로서의 연구 프레임워크

  1. 호기심을 기르기

     * 손 안에 알렉산드리아 도서관이 있지만, 정보의 과잉은 호기심을 둔화시킴
     * 알고리즘이 제공하는 정보에 수동적으로 반응하는 대신, 적극적으로 탐구해야 함
     * 호기심의 핵심은 관찰, 주의, 그리고 ""왜""와 ""어떻게""에 대한 지속적인 질문임
     * 일상에서 호기심을 기르는 방법:
          + 새에 관한 에세이를 읽고 더 알고 싶어지기
          + 산책하면서 주변의 건물, 나무, 거리의 구조에 대해 궁금해하기

  2. 질문을 구체화하기

     * 호기심이 방향이 없으면 단순한 산만함에 그침
     * 수동적 호기심을 능동적 진리 탐구로 바꿔야 함
     * 좋은 질문의 조건:
          + 연구의 방향을 제시할 만큼 구체적이어야 함
          + 새로운 발견의 가능성을 열어둘 만큼 개방적이어야 함
     * 질문의 발전 과정:
          + ""교외는 어떻게 형성되었을까?"" → ""구획 제도가 교외에 어떤 영향을 주었을까?""
          + → ""구획 제도의 역사란 무엇인가?"" → ""쇼핑몰은 교외를 어떻게 변화시켰는가?""
          + → ""주차장 최소 기준은 왜 필요한가?"" → ""교외의 구조는 합리적인가?""

  3. 근거 수집하기

     * 질문이 명확해지면 근거를 통해 이를 발전시켜야 함
     * 근거 수집에서 발생하는 문제:
          + 정보 수집 중독 → PDF, 책, 논문을 모으기만 하고 실제로 읽지 않음
          + 기초 텍스트의 부재 → 해당 분야의 기초 텍스트를 읽고 체계를 이해해야 함
          + 정보의 과잉 → 읽을 거리가 너무 많아도 괜찮음. 중요한 것은 체계적인 정리임

  4. 답을 발전시키기

     * 연구는 반드시 결과를 만들어야 함
     * 결과가 혁신적일 필요는 없지만 형태화된 결론이 있어야 함
     * 결과물의 형태:
          + 에세이, 영상, 소셜 미디어 글, 친구에게 보내는 편지 등
     * 탐구에서 창조로의 전환이 여가로서의 연구를 구별함
     * 단순히 정보 소비에서 끝나는 것이 아니라 대화에 기여해야 함

  5. 지식 공동체 형성하기

     * 연구의 완성은 개인적 사색에서 끝나는 것이 아니라 사회적 연결을 통해 이루어짐
     * 다양한 형태의 지식 공동체:
          + 서브스택(Substack), 유튜브, 디스코드, 트위터 등 온라인 플랫폼
          + 독서 모임, 작문 모임, 토론 그룹 등 오프라인 커뮤니티
     * 블룸즈버리 그룹, 잉클링즈, 거트루드 스타인의 살롱, 비엔나 서클처럼 아이디어는 상호 작용을 통해 진화하고 확산됨
     * 이러한 공동체를 통해 문명과 문화의 기반이 재구성됨

문명의 패턴을 재구성하기

     * Manual of Civilisation은 책이 단순한 정보 저장소가 아니라 문화의 기억과 주체성의 그릇임을 상기시킴
          + 단편화된 현대 사회에서 ""창조주의 이름으로 읽으라""는 신성한 명령은 더욱 긴급해짐
     * Kasurian은 연구를 여가로 삼는 길을 탐구하자는 초대임
          + 진지한 연구는 누구나 할 수 있으며, 전문성에 도달하는 장벽은 그 어느 때보다 낮아짐
          + 자신이 흥미를 느끼는 분야에서 아마추어 전문가가 되기를 권장함
          + 뉴스레터, 에세이, 토론 그룹, 온라인 포럼 등을 통해 자신의 연구 결과를 공유하고 피드백을 받아야 함
     * 공식적, 비공식적 전문성의 문화를 받아들임으로써 경이로움의 감각을 회복할 수 있음
          + 이를 통해 현대의 고정관념을 넘어서는 능력과 사회적 통찰을 되찾을 수 있음
          + 연구와 대화를 통해 문명의 패턴을 다시 조립하고, 새로운 문화를 창조함

        Hacker News 의견

     * 나는 많은 양의 글을 읽고 연구를 취미로 삼고 있지만, 다른 사람의 습관이 얼마나 더 좋고 멋진지에 대한 엘리트주의적이고 독창적이지 않은 글은 참을 수 없음
          + 여가 연구자는 자기 학습에 학문의 기초 텍스트를 포함해야 한다는 의견에 대해, 이 사람은 다크 아카데미아 미학에 집착하여 다른 사람들보다 우월감을 느끼려는 것 같음
          + OP의 호기심에 관한 조언에 깊이 동의하지만, 개인적으로는 그들과는 전혀 다른 방식으로 이를 구현함
          + 최근 LLM이 자유로운 ""연구""에 놀라운 도구임을 발견함. 예를 들어 ""교외가 존재하는 이유에 대한 상위 세 가지 이론과 이를 제시한 사람들 요약"" 같은 것
          + LLM을 개방형 의미 검색 엔진/연구 도구로 사용하여 깊이 탐구하고 싶은 주제의 지형을 파악하는 데 놀라운 방법임
          + 그 후 팟캐스트, 위키피디아, 마지막으로 책으로 이어지는 콘텐츠 계단을 내려감
          + 문명은 미디어 소비 습관 때문에 끝나가고 있으며 ""원본 자료 읽기""가 우리를 구할 것이라는 생각은 오늘날 문화에 대한 현실적인 불만보다는 미학적 환상에 더 가까움
          + 인터넷 이전 시대를 경험했으며, 책만 있을 때보다 지금 훨씬 더 많은 정보에 접근할 수 있게 되어 감사함
     * 독서는 필수 기술이지만, 독서를 지나치게 숭배하는 것을 멈춰야 함. 많은 경우 이러한 주장은 문학적 엘리트주의로 비춰짐
          + 이번 달에는 아시아 대륙의 지정학에 관한 해군 전쟁 대학의 유튜브 강의를 듣는 데 많은 시간을 보냈음. 물론 읽을 수도 있었지만, 주제에 호기심을 갖고 참여하며 ""토끼굴을 따라갔음""
          + 정보 탐색에 더 적극적으로 참여해야 한다는 주장이 있음. 단순히 알고리즘이 제안하는 것을 받아들이는 것이 아니라, 정보 섭취 방법이 아니라 정보의 질과 의도가 중요함
     * 대학 졸업 후 몇 년 후 취미로 역사를 읽기 시작했음. 사람들이 말하는 것들이 이해가 되지 않거나 사실이 아닌 것 같았기 때문임
          + 잘 인용된 책을 읽으며 각 장의 인용을 확인했음. 의회 도서관과 구글 덕분에 원본 자료를 확인하는 것이 그 어느 때보다 쉬워졌음
          + 정말로 놀라운 경험이었음. 소설보다 훨씬 흥미로웠음
          + 지금 성경 공부를 할 때도 같은 방식으로, 당시의 다른 역사와 교차 참조할 수 있는 모든 자료를 찾음. 강력히 추천함
          + 재미있는 점은 학교에서 가장 관심이 없었던 과목이 역사였음
     * 대부분의 사람들은 사회가 끊임없이 서두르는 상태에 있기 때문에 주변의 것들에 대해 생각하지 않는다는 것이 내 직감임
          + 누군가가 '구역 법이 어떻게 생겨났는지' 궁금해한다면, 그들은 생산적이지 않음. 서구 사회는 개인을 그들이 얼마나 생산하는지에 따라 평가하는 것 같음
          + 일하거나 출퇴근하는 사람은 피곤해서 주변 세계에 대해 깊이 생각할 에너지가 없음
          + '첫 번째 연구자들'은 이오니아인들이었으며, 그리스의 상인 섬으로, 마음의 관심사를 추구할 시간과 자원을 가졌음
          + 물론, 이것은 이야기의 일부일 뿐임. 다른 부분은 주변 세계에 대해 질문하고 궁금해하는 습관을 갖는 것임. 이는 연습을 통해 얻어짐
          + 아이들이 '왜'라는 질문을 많이 해서 부모들이 짜증을 내며 간접적으로 질문을 막는 경우가 많음
          + 우리의 교육 시스템도 이러한 사고 방식을 억제함. 주로 노동자를 생산하는 라인임
     * Marshall McLuhan은 텔레비전이 독서를 대체할 것이라고 생각했지만, 실제로는 YouTube가 비소설 TV의 가용성을 크게 확장하면서 발생했음
          + 비디오 게임의 텍스트 가이드가 사라진 예시가 있음. 2010년경에는 좋은 FAQ와 공략을 찾을 수 있었음
          + 이제 30시간짜리 게임을 위해 30시간 분량의 비디오에서 적절한 부분을 찾아야 함. 가끔은 비디오에서 누군가가 다른 경로를 택하거나 다른 빌드를 가지고 있어 비디오를 보고도 이해할 수 없는 경우가 있음
          + Pokemon과 같은 게임에서는 빌드의 높은 변동성 때문에 공략이 문제가 되었지만, 데이터베이스가 더 필요한 비디오에서는 훨씬 더 심각함
     * 연구의 전문화로 인해 ""재미""가 사라진 것이 저평가된 단점 중 하나임
          + 연구 논문은 대부분의 분야에서 사람들이 실제로 서로 대화하는 방식과 매우 다르게 작성됨
          + 전문 연구자들은 여전히 정상적인 인간처럼 비공식적으로 소통하며, 그들이 아이디어를 어떻게 생각해냈는지와 실제로 무엇을 생각하는지를 더 많이 보여줌
          + 그러나 외부인이 접근하기에는 매우 어려움
     * 인도에서 가난하게 자랐기 때문에 연구는 여가 활동이 아니라 따라잡기 위한 경주였음
          + 그래서 이 기사가 문화적 변화에 대해 옳다고 생각함. 깊이 있는 독서는 모든 사람이 감당할 수 있는 사치처럼 느껴짐
          + 이제 더 많은 사람들이 스스로 파고들기보다는 단계별 가이드에 의존하는 것을 봄. 이는 수동적 소비의 경향에 맞음
          + 그러나 독서만으로는 충분하지 않음. 실제로 관심 있는 문제를 해결하는 데 사용할 수 있을 때만 중요함
     * 이 블로그의 세 게시물을 훑어보았고, LLM이 많이 사용되었다고 믿음. 매일 사용하기 때문에 그 내용이 그렇게 읽힘
          + 저자가 말하는 여가는 그들 자신의 것일 수 있으며, 오늘날 그들이 말하는 연구는 기계에 의해 수행될 수 있음
          + 의도가 좋다고 생각하며, 독자가 그것에서 통찰을 얻는다면 여전히 유효하지만, 그들과 함께 삶을 경험하는 데 도움이 되는 의식의 흐름을 느낄 수 없어서 읽을 수 없음
          + 저자가 대신 LLM과 짝을 이루어 스스로 연구하고 그것에 대해 직접 글을 썼다면, 아마도 다를 것임
          + 왜 이러한 게시물이 HN 피드의 상위에 계속 올라오는지 궁금함. 우리는 기계보다 나을 게 없다고 생각함
     * 현재 내 지역의 오래된 고분을 다시 방문하고 재설명하는 중이며, 마지막 조사가 수십 년 전이었고 현재 설명이 없음
          + 또한 Lidar 지도를 통해 이전에 기록되지 않은 무덤을 발견하고 이를 목록화하고 있음. 모든 것이 취미로, 지역 역사 협회의 일원으로서 이루어짐
          + 할 수 있는 일은 해야 함
     * 블로그 게시물은 약간 고급스러운 인상을 줌. 저자와 그들의 책을 과도하게 인용하지만, 저자의 내러티브를 강화할 뿐임
          + 기사에 대한 일반적인 감정에 동의하지만, 실제로 정보를 제공하기보다는 자신의 우수성을 재확인하려는 필요성 때문에 스스로를 패배시킴
          + ""비어 있는 독서에 반대하여"" 섹션 위의 모든 것을 건너뛰고도 같은 메시지를 전달할 수 있었음
          + 그 섹션 아래의 메시지는 가치가 있지만, 실제로 어떻게 실천할지에 대해서는 다루지 않음
          + 현대 정보 환경을 한탄하지만, 어떻게 해야 하는지는 말하지 않음
          + 그의 요점은 ""정보의 수동적 소비자가 되지 말고, 질문을 적극적으로 하고, 그 질문을 정제하며, 답변을 개발하라""로 요약될 수 있음
          + 어떻게? 여가로 글을 쓰고, 다른 사람의 글을 읽을 때 사용하는 비판적 시각으로 읽음
          + 그렇게 해야만 글쓰기와 사고를 정제할 필요가 생기며, 이는 새로운 질문, 탐구 및 관점을 이끌어냄
          + 어떤 종류의 연구도 반복적인 과정임. 새로운 정보를 찾고, 그것에 유리한 편견을 만들고, 그것으로 많은 것을 설명하려고 함
          + 그런 다음 그것이 모든 것을 설명하지 못한다는 것을 깨닫고 다시 읽거나 더 많은 것을 찾아야 함
          + 글을 쓰고 검토할 때 한 가지 아이디어에 갇히는 것을 더 쉽게 잡아낼 수 있음
          + 그가 말한 것처럼, 내성적인 독서는 글쓰기와 결합될 때만 완전함 (또는 적어도 글쓰기 구조를 닮은 깊은 성찰)
          + 이 기사는 Richard Feynman의 ""I don't like honors""를 떠올리게 함. 어떻게 해야 하는지에 너무 집착하여 존재(또는 정보 제공)를 놓침
"
"https://news.hada.io/topic?id=19964","스패머들이 SPF, DKIM, DMARC를 더 잘 활용함 ","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    스패머들이 SPF, DKIM, DMARC를 더 잘 활용함

     * DMARC, SPF, DKIM과 같은 이메일 인증 방법은 스팸을 줄이기 위한 수단으로 사용되지만, 실제로는 스팸 발송자들이 더 잘 활용하고 있음.
     * 이러한 인증 방법들은 대부분의 발신자에게는 별다른 이점이 없으며, 인증 실패에 기반한 메일 거부는 오히려 해로울 수 있음.
     * 스팸 발송자들은 저렴한 도메인을 구매하여 인증을 통과하는 방법을 잘 알고 있음.

이메일 전달 및 Gmail 문제

     * Gmail은 DMARC와 같은 인증을 요구하며, 이는 이메일 전달 시 문제를 일으킬 수 있음.
     * 이메일 전달 시 SPF가 손상될 수 있으며, DKIM은 본문이나 헤더를 수정하지 않는 한 보존됨.
     * Gmail의 POP3 수집 기능은 수동으로 트리거하기 어렵고, 자동 간격이 긴 편임.

이메일 인증의 한계

     * 이메일 인증은 특정 도메인의 사칭을 방지하지만, 유사 도메인이나 오타를 이용한 스팸을 막지는 못함.
     * 인증은 발신자의 신원을 확인하는 데 유용하지만, 권한 부여와는 별개임.
     * 스팸 발송자들은 인증 정책을 설정할 수 있으며, 이는 스팸을 통제하는 데 일부 역할을 할 수 있음.

스팸 방지 및 이메일 보안

     * 스팸 방지를 위해 다양한 방법이 사용되지만, 완벽한 해결책은 없음.
     * Spamhaus와 같은 서비스는 스팸을 차단하는 데 유용하지만, 잘못된 긍정 오류가 발생할 수 있음.
     * 이메일 보안은 지속적인 관리와 업데이트가 필요함.

   SPF, DKIM, DMARC 이해하기: 간단한 가이드
   이메일의 SPF/DKIM/DMARC가 어떻게 동작하는지 인터랙티브하게 보기

        Hacker News 의견

     * 개인 메일 서버를 운영하는 사람으로서, 러시아 IP 주소가 내 도메인 이름으로 이메일을 보내려는 시도를 계속하는 것을 알림
          + 이메일을 보내는 것이 사업인 사람들은 이메일 설정을 제대로 하는 방법을 알고 있음
          + 많은 시스템 관리자들이 기본적인 설정을 제대로 하지 못하는 것에 놀람
          + SPF 서명이 잘못되어 Sendgrid 이메일이 거부된다는 DMARC 이메일을 받으면 마케팅이 이를 합법적으로 사용하는지 물어봐야 할 것임
          + 자동 서명은 제한된 가치를 가지지만, SPF와 DKIM에 기반한 거부가 실수인 경우는 드물음
          + 대형 조직에서는 상황이 더 나쁠 수 있지만, 작은 이메일 서버에서는 기술적 거부가 보통 올바른 결정임
          + 메일링 리스트는 예외지만, 이를 사용하는 사람들은 예외를 추가하는 방법을 알아낼 수 있음
     * SPF, DKIM, DMARC를 제대로 설정하고 스팸 점수가 0인 도메인을 가지고 있어도 스팸 폴더에 들어가는 문제를 겪고 있음
          + 이메일이 Gmail에 수락되기 위해서는 ""평판""이 필요함
          + 이메일이 스팸으로 바로 가면 그 평판이 어떻게 쌓일지 혼란스러움
          + Linkedin 이메일은 스팸이 아니며, 그들의 다크 패턴이 이메일 리스트에 추가되더라도 차단되지 않음
     * SPF/DKIM은 메일 서버의 평판과 관련이 있음
          + Google, Microsoft, Yahoo와 같은 대형 서버에 주로 이익이 됨
          + 대형 제공자의 스팸 방지 시도가 소형 제공자에게 해를 끼침
          + 이메일 서버 평판을 추적할 필요는 없고, 발신자 평판을 추적해야 함
          + 익명 이메일과 실제로 아는 사람의 이메일을 다르게 처리할 수 있어야 함
          + 현재로서는 알려진 이메일 발신자가 미지의 발신자를 안전하게 소개할 방법이 없음
     * SPF와 DKIM이 스팸을 완전히 막지는 못하지만, DMARC는 아마도 쓸모없음
          + 스팸 발신자도 이 표준을 읽을 수 있기 때문에 SPF/DKIM이 스팸을 완전히 막지는 못함
          + SPF/DKIM 도입 전에는 ""support@paypal.com""과 같은 주소로 피싱 메일을 많이 받았음
          + Paypal은 SPF로 허용된 IP 주소를 명확히 표시하고, DKIM으로 메일을 검증할 수 있음
          + Spamassassin은 올바른 DKIM과 paypal.com에서 온 메일의 스팸 점수를 크게 줄임
     * SPF/DKIM/DMARC의 목적은 이메일을 도메인에 묶어 스푸핑을 방지하는 것임
          + 인증만으로 스팸을 줄일 수 있다고 기대하는 것은 순진함
     * Google은 SPF와 DKIM에 서툼
          + 몇 달 전 Chromium 버그 트래커 메시지에 이메일로 응답하려 했으나 실패함
          + SPF/DKIM 검사가 실패했다는 이유로 이메일이 처리되지 않음
          + 내 SPF와 DKIM은 문제가 없었음
          + Google Workspace 설정 시 사용하라는 도구가 오랫동안 제대로 작동하지 않음
          + 피드백 링크도 제대로 작동하지 않음
     * 개인 이메일 서버를 운영하며, 대부분의 스팸은 SPF/DKIM을 통과하지 못함
          + 최근 몇 년간 통과하는 스팸의 비율이 증가하고 있음
          + 예상한 메일의 90-95%가 SPF/DKIM을 통과함
          + 엄격한 발신자 규칙을 적용하고 있음
          + 사이트에 이메일 주소를 공개했지만 스팸이 거의 없음
     * 간단한 휴리스틱 기반의 스팸 필터를 운영 중임
          + 발신 메일을 확인하고, 발신한 주소나 제목이 포함된 메일은 스팸으로 표시하지 않음
          + 새로운 주소에서 온 스팸은 읽지 않은 상태로 표시됨
          + 구독 확인 같은 경우는 스팸 폴더 상단에 위치함
     * Proton으로 메일을 옮겼고, DNS 항목 추가 및 검증 과정이 매우 쉬웠음
          + 처음에는 이 단계가 두려웠지만, 쉽게 해결됨
     * SPF, DKIM, DMARC의 가치는 IP 기반에서 도메인 기반으로 평판이 이동하는 것이라 생각했음
          + 도메인 평판을 잘 유지하고 SPF, DKIM, DMARC를 올바르게 설정하면 어떤 IP에서도 SMTP 서버를 호스팅할 수 있을 것이라 기대했음
          + 왜 그렇게 작동하지 않는지 궁금함
"
"https://news.hada.io/topic?id=19856","무신사, PC 환경을 위한 UI 개발 예정","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        무신사, PC 환경을 위한 UI 개발 예정

   지난 2024년 6월, 무신사는 PC 버전 UI 지원을 중단했습니다.

   2025년 3월 17일에 올라온 새 공지사항에서는 2025년 3월 말부터 다시 지원할 것임을 밝혔습니다.

   PC 버전을 유지하기 어려웠던 기억이 있습니다.

   일단 PC 버전이 비즈니스의 중심이 아니기 때문에 좋은 개발자를 채용하기 어렵습니다. PC 버전 개발 경험이 많은 좋은 리더는 이미 네카라쿠에 계시고 모셔오기도 쉽지 않습니다. 네카라쿠에 있는 분들을 모시려면 그 분이 경력을 희생하는 만큼 뭔가 처우가 더 좋아져야 하는데 그 지점이 쉽지 않을겁니다.

   그러면 있는 인력으로 최선의 방안으로 구성해야 하는데, 그러면 애매한 퀄리티의 제품이 나와서 욕을 먹는 수도 있습니다.

   여러가지 이유로 PC 버전을 잘하는게 진짜 쉽지 않습니다. 적어도 현 시점에서 국내 시장은 그런 느낌입니다.

   레거시 PC 버전 지원 중단 후 모바일 우선 레이아웃을 반응형으로 개편한다고 했으면 혼선없이 좀더 매끄럽지 않았을까요

   모바일이라고 퍽 좋았던 건 아니었으니까요…

   당시에 찬성하는 의견이 많아서 내가 이상한가 했는데, 댓글보니 개운하네요.

   ㅋㅋㅋ 역시 다들 같은 생각

   첨부터 굉자히 이해안가는 결정이었는데, 생각보다 더더 빨리 재지원을 하는군요;; 뭐하는건지...

   난 pc로만 구매하는데 ㅋㅋ 이럴줄 알았다

   무신사가 처음부터 플랫폼 자체개발이 아니라 외주업체로부터 PC버전으로 먼저 출시했다가 잘되고나서 외주사를 인수했을텐데요, 자체개발 이후 PC는 기능이나 매출 대비 운영비용이 커서 유지보수가 매우 힘들었을것으로 추측되네요. 고가의 제품은 아직 pc로 구매하는 경향이 있는데 무신사는 패션 버티컬이고 기술비용도 커서 그냥 종료시킨거같아요. 그래도 더 커지려면 웹은 아예 바꾸던지 없애는건 좀 비관적입니다

   채널 자체를 줄이는건 기술보다는 사업적 판단의 영역 같은데, 있던 걸 왜 없애나 했네요

   애초에 왜 없앤건지 ㅎㅎ Responsive 가 그리 비싼것도 아닌뎅.

   진즉에 없애질 말아야지ㅋㅋㅋ

   그냥 9개월동안 레거시 서비스 중단하고 새로 구축한 셈 치면 나쁘지 않을 지도? 그래도 pc버전 돌아와서 반갑네요

   모바일만을 위한 UI가 꽤 불편했는데 환영입니다!

   몇년동안 보안사고 없다고 보안팀 필요 없다며 해체시키고 얼마 안 있다가 보안문제 터져서 망한 회사가 생각나네요.
   서초딩이 높은 자리에 있으면 이런일이 벌어지죠.

   아는 게 단기실적에 도움이 되는 원가절감밖에 없으니 하는 판단이 저런 것 밖에 없죠.

   2023년초~ 2024년말 CTO가 공석이었던 와중에 내려진 결정이었네요.
   의사결정 과정에 기술적인 의견이 없었던 걸로 추측됩니다.

   도로 아미타불...

   패션플랫폼 무신사, PC버전 지원 종료…모바일에 올인

   10개월 만에 원복하네요.
   솔직히 비용 효율화 측면에서 모바일에 집중한다고 했는데, 제가 무신사 모바일 웹 사이트를 쓴 경험은 별로 좋지 않았어요. 이상하게 느려서, 앱으로 보내도록 만드는게 정책인가? 했었습니다.
"
"https://news.hada.io/topic?id=19910","CSS에서 구분선을 그리는 새로운 방법: `CSS Gap Decorations`","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              CSS에서 구분선을 그리는 새로운 방법: `CSS Gap Decorations`

     * 웹페이지에서 섹션 간 구분선을 추가하는 것은 콘텐츠를 명확하게 정리하고 가독성을 높이는 일반적인 디자인 기법
     * border 같은 기존 CSS 기법을 사용해 구분선을 추가할 수 있지만 크기 변경, 추가 코드 필요 등 제한이 존재함
     * CSS Gap Decorations는 column-rule 및 row-rule 등의 속성을 추가하여 이런 문제를 해결

기존 CSS 구분선 기법과 한계

     * border 속성은 구분선을 추가하는 일반적인 방법이지만 다음과 같은 문제 발생 가능
          + border를 추가하면 요소 크기가 변경될 수 있음
          + 첫 번째 및 마지막 요소에 대해 추가 코드를 작성해야 함
          + Flexbox 레이아웃에서 줄 바꿈이 발생하면 구분선이 전체 영역을 덮지 못함
     * ::before 및 ::after 가상 요소를 사용해 구분선을 추가할 수 있지만 다음과 같은 한계가 있음
          + 첫 번째 및 마지막 요소에 대해 추가 코드 필요
          + 복잡한 절대 위치 지정 코드 필요
     * 그리드 컨테이너에 배경색을 적용하고 항목에 배경색을 설정해 구분선을 흉내낼 수 있음
          + 구분선 길이 조정 불가
          + 빈 셀이 있을 경우 배경색이 보임
          + 항목이 셀을 채우지 않으면 배경색이 보임
          + 페이지 배경이 단색이 아닐 경우 동작하지 않음
     * 다중 열 레이아웃에서 column-rule 속성을 사용해 구분선을 추가할 수 있지만 다음과 같은 제한 존재
          + 다중 열 레이아웃에서만 작동
          + 콘텐츠의 인라인 방향 제어 불가

CSS Gap Decorations 제안

     * CSS Gap Decorations는 위와 같은 문제를 해결하기 위한 새로운 제안임
     * 주요 제안 사항
          + column-rule 속성을 그리드 및 플렉스박스 레이아웃에 적용 가능하도록 확장
          + 새로운 row-rule 속성 도입
          + 각 컨테이너 부분마다 다른 구분선 설정 가능
     * row-rule-color 속성을 사용해 구분선 색상 변경 가능
.alternate-red-blue {
  display: grid;
  grid-template: repeat(auto-fill, 30px) / repeat(6, 100px);
  gap: 10px;
  row-rule: 1px solid;
  row-rule-color: red blue;
}

     * 굵기와 색상이 다른 구분선 설정 가능
.varying-widths {
  display: grid;
  grid-template: repeat(auto-fill, 30px) / repeat(6, 100px);
  row-gap: 10px;
  row-rule: 5px solid black / repeat(auto, 1px solid #666) / 3px solid black;
}

     * 교차점에서 구분선 동작 제어 가능
          + *-rule-break 및 *-rule-outset 속성 사용 가능
          + 교차점에서 구분선 시작 및 종료 위치 제어 가능
          + 구분선 길이 및 오프셋 세밀한 조정 가능

제안에 대한 피드백 요청

     * CSS Gap Decorations 제안은 개발자 피드백을 기반으로 개선될 예정임
     * 자세한 정보는 공식 explainer에서 확인 가능
     * 피드백은 GitHub 이슈로 제출 가능
     * 특히 교차점에서 구분선 동작에 대한 피드백 환영

        Hacker News 의견

     * 새로운 가상 요소를 만들고 싶음: .container:gap { background-color: red; }
          + 점선이나 그라데이션 같은 더 멋진 배경을 만들 수 있음
          + { padding: 2px }를 사용하여 구분자의 끝에 공백을 설정할 수 있음
          + :gap-horz와 :gap-vert를 사용하여 수직 및 수평 간격을 별도로 설정할 수 있음
          + .container:gap:nth-gap(2n) { color: blue; }를 사용하여 교차 색상을 얻을 수 있음
     * 위원회에 의한 디자인은 최선이 아니지만, 비원어민으로서 제안된 속성 이름이 의미를 잘 전달하지 못함
          + 예를 들어, 간격을 정의하지만 구분자를 그리는 것임
     * 조정 가능한 패널의 사용 사례를 고려했으면 좋겠음
          + 구현이 전적으로 사용자 영역에 있더라도 스타일 가능한 구분자가 이벤트를 받을 수 있으면 유용할 것임
     * 테두리를 추가하면 항목의 크기가 변경되는데, 이는 바람직하지 않을 수 있음
          + 이 문제는 10년 이상 해결되어 왔음
          + 모든 사람의 CSS 파일의 첫 번째 줄은 * { box-sizing: border-box; }가 아닐까 생각함
          + 테두리가 너비의 내부에 위치하게 하여 더 합리적으로 생각할 수 있음
     * 흥미로움. 요즘 QML에서 주로 UI 작업을 하고 있으며, 거의 모든 문제를 다루고 있음
          + 몇 달 전, 캘린더 보기에서 항목 사이의 간격을 사용하여 배경이 보이도록 하여 그리드 라인을 구현했음
          + 레이아웃의 ""spacing"" 속성과 GPU가 작업을 수행하도록 함
     * 괜찮은 아이디어지만 10년 전쯤 더 유용했을 것 같음
          + 현대 CSS로는 단일 선택자와 속성으로 구분자를 처리할 수 있음
          + .things .thing:not(:last-child) { border-bottom: 1px solid gray; } 같은 방식으로 가능함
          + 기사에서 이 점을 언급하지만, 가장자리 사례의 빈도를 과대평가하는 것 같음
     * 오랫동안 고통스러운 문제였음. 누군가가 무언가를 하는 것을 보는 것이 멋짐
          + 이것은 단지 display: grid일 뿐이며, 고정되지 않은 너비 요소에는 해당되지 않음
          + 작은 화면에서는 링크 사이의 |가 첫 번째 줄 끝이나 두 번째 줄 시작에 나타날 수 있음
     * 독일 디자이너의 속담이 생각남: ""디자이너가 더 이상 아이디어가 없으면 몇 개의 선을 추가함""
          + 콘텐츠를 명확하게 구분할 방법이 없을 때 선을 추가하기 시작함
     * 종종 이 문제가 발생하며, <hr/>보다 나은 방법을 원함
          + 테이블 행이나 다중 열에서는 작동하지 않음
     * 이게 통과되기를 바람... AI를 사용하여 flexbox에 대한 부족한 지식을 고치는 것은 축복이었지만, 이것이 실제 해결책처럼 느껴짐
"
"https://news.hada.io/topic?id=19952","Bluesky와 페디버스(fediverse)의 비교","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Bluesky와 페디버스(fediverse)의 비교

  핵심 아키텍처 차이: 메시지 전달 vs 공유 힙

     * 페디버스: 이메일과 유사한 “메시지 전달” 방식 사용
          + 특정 수신자에게 직접 메시지 전달
          + 필요한 서버에만 메시지가 전송되어 효율적
          + 개인이 저렴한 하드웨어로도 노드 운영 가능
     * Bluesky: “공유 힙” 방식 사용
          + 모든 메시지가 중앙 “릴레이”에 저장됨
          + 사용자는 릴레이에서 관련 정보를 필터링
          + 대규모 중앙화된 인프라 필요
          + 릴레이 운영 비용이 급격히 증가 (4개월만에 1TB→5TB)

  전역 뷰와 중앙화 문제

     * Bluesky: 일관된 네트워크 전체 뷰 유지에 집중
          + 모든 앱뷰가 전체 차단 정보 등 필요
          + 차단 목록이 공개되어 프라이버시 문제 발생
          + 중앙 집권적 통제 없이는 구현 어려움
     * 페디버스: 각 서버가 독립적으로 정책 시행
          + 사용자에게 더 많은 자율성 제공
          + 차단 정보는 공개되지 않도록 설계됨

  프로토콜 개방성 비교

     * 페디버스/ActivityPub: W3C 채택 개방형 표준
          + 누구나 자유롭게 구현 가능
          + 다양한 소프트웨어 간 상호운용성 보장
          + FEP를 통한 커뮤니티 주도 발전
     * Bluesky/AT Protocol: 기업 주도 프로토콜
          + 아직 개방형 표준으로서의 지위 미확립
          + 확장성과 지속가능성 제한적

  개인 메시지(DM)의 중앙화

     * Bluesky: 모든 DM은 중앙 서버 통과
          + 사용자 PDS나 릴레이와 무관하게 Bluesky 회사를 통해 전송
          + Bluesky 회사가 모든 DM에 접근 가능
          + ""신뢰할 수 있는 이탈"" 개념과 모순됨
     * 페디버스: 서버 간 직접 전달 메커니즘
          + 자신의 서버 관리자만 메시지 접근 가능

  이동 가능한 아이덴티티 구현 문제

     * Bluesky: DID를 사용하지만 여전히 중앙화에 의존
          + did:web과 did:plc는 DNS와 중앙 레지스트리에 의존
          + 초기에는 모든 계정이 동일한 rotationKeys 사용
          + 사용자 키가 Bluesky에 의해 관리됨
     * 페디버스: 노마딕 아이덴티티 개념 발전 중
          + Zot 프로토콜 등 더 포괄적인 이동성 제공
          + FEP-ef61 등을 통한 지속적 개선

  상업적 압력과 지속가능성

     * Bluesky: 벤처 캐피털 자금에 의존
          + “조직은 미래의 적이다”라는 인식
          + 유료 계정과 광고 도입으로 인한 상업적 압력
          + 투자자 수익 압박이 탈중앙화를 저해할 가능성
     * 페디버스: 다양한 운영 주체와 자금 모델
          + 상업적, 비상업적, 개인적 노드의 생태계 구성
          + 단일 실패 지점 없음

  결론

     * Bluesky는 사용자 친화적 인터페이스와 Twitter 유사 경험으로 X의 훌륭한 대안이 될 수 있음
     * 그러나 중앙화된 설계, 운영 비용, 개인정보 취약성, 기업 의존성 등으로 인해 페디버스의 대안은 아님
     * 두 시스템은 근본적으로 다른 목표와 디자인 철학을 가지고 있으며, 이상적으로는 서로 보완하는 방향으로 발전할 수 있음

   이런 반론도 있습니다: https://hackers.pub/@yurume/0195cc17-b1ed-712e-9ecf-dcc49158220a
"
"https://news.hada.io/topic?id=19902","프랑스 과학자가 미국 입국을 거부당했다고 프랑스 정부가 발표","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   프랑스 과학자가 미국 입국을 거부당했다고 프랑스 정부가 발표

     * 프랑스 교육부는 국립과학연구센터(CNRS) 소속 과학자가 미국에서 열리는 학회에 참석하려다 입국이 거부되었다고 발표함
     * 교육부 장관은 입국 거부 이유가 과학자가 트럼프 행정부의 연구 정책에 대한 개인적인 의견을 표명했기 때문인 것으로 보인다고 주장
     * 미국 세관 및 국경보호국(CBP)은 구체적인 사례에 대해 논의할 수 없다는 입장
          + CBP 대변인 힐튼 베컴은 모든 입국자는 개별적인 검사를 받으며, 전자기기에서 문제가 되는 자료가 발견되면 추가 조사가 이루어질 수 있다고 설명함
          + 정치적 동기에서 비롯된 결정이라는 주장은 근거가 없다고 강조함
     * 트럼프 행정부는 연구 기관에 대한 연방 자금 지원 삭감 및 동결 조치를 시행 중
          + 트럼프 대통령은 국경 정책을 강화하는 행정 명령을 다수 발표
               o 보다 엄격한 비자 심사 절차 도입
               o 미국 내 불법 이민자에 대한 단속 강화
     * 독일 정부는 최근 미국 입국 거부 사례가 늘어나면서 미국 여행 권고 사항을 업데이트
          + 비자나 입국 면제가 입국을 보장하지 않는다는 점을 명확히 명시함
     * 영국도 최근 여행 권고를 개정해 미국 입국 규정을 위반할 경우 체포 또는 구금될 수 있음을 경고함
"
"https://news.hada.io/topic?id=19922","Next.js 버전 15.2.3 보안 취약점 해결 출시","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Next.js 버전 15.2.3 보안 취약점 해결 출시

     * CVE-2025-29927
     * Next.js 버전 15.2.3이 보안 취약점(CVE-2025-29927)을 해결하기 위해 출시됨. next start와 output: 'standalone'을 사용하는 모든 자체 호스팅 Next.js 배포는 즉시 업데이트할 것을 권장함.
     * 타임라인
          + 2025-02-27T06:03Z: GitHub 비공개 취약점 보고를 통해 Next.js 팀에 공개됨
          + 2025-03-14T17:13Z: Next.js 팀이 보고서 검토 시작
          + 2025-03-14T19:08Z: Next.js 15.x에 대한 패치 배포
          + 2025-03-14T19:26Z: Next.js 14.x에 대한 패치 배포
          + 2025-03-17T22:44Z: Next.js 14.2.25 출시
          + 2025-03-18T00:23Z: Next.js 15.2.3 출시
          + 2025-03-18T18:03Z: GitHub에서 CVE-2025-29927 발행
          + 2025-03-21T10:17Z: 보안 권고문 발표
          + 2025-03-22T21:21Z: Next.js 13.5.9 출시
          + 2025-03-23T06:44Z: Next.js 12.3.5 출시
     * 취약점 세부 사항
          + Next.js는 무한 루프를 방지하기 위해 내부 헤더 x-middleware-subrequest를 사용함. 보안 보고서에 따르면, 미들웨어 실행을 건너뛰어 중요한 검사를 우회할 수 있는 가능성이 있음.
     * 영향 범위
          + 영향을 받는 경우
               o 미들웨어를 사용하는 자체 호스팅 Next.js 애플리케이션 (next start와 output: 'standalone')
               o 인증 또는 보안 검사를 위해 미들웨어에 의존하는 경우
               o Cloudflare를 사용하는 애플리케이션은 관리형 WAF 규칙을 활성화할 수 있음
          + 영향을 받지 않는 경우
               o Vercel에 호스팅된 애플리케이션
               o Netlify에 호스팅된 애플리케이션
               o 정적 내보내기로 배포된 애플리케이션 (미들웨어 실행되지 않음)
     * 패치된 버전
          + Next.js 15.x: 15.2.3에서 문제 해결됨
          + Next.js 14.x: 14.2.25에서 문제 해결됨
          + Next.js 13.x: 13.5.9에서 문제 해결됨
          + Next.js 12.x: 12.3.5에서 문제 해결됨
          + 안전한 버전으로 패치가 불가능한 경우, 외부 사용자 요청이 x-middleware-subrequest 헤더를 포함하지 않도록 방지할 것을 권장함
     * 우리의 보안 책임
          + Next.js는 2016년 이후 16개의 보안 권고문을 발표함. GitHub 보안 권고문과 CVE는 소프트웨어의 취약점을 사용자, 공급업체, 회사에 알리는 업계 표준임. 파트너와의 소통에서 부족한 점을 보완하기 위해 파트너 메일링 리스트를 개설함. partners@nextjs.org로 연락하여 포함될 수 있음.

        Hacker News 의견

     * Next의 미들웨어 시스템은 문제가 많으며, 처음부터 다시 구현하는 것이 좋을 것 같음
          + 여러 미들웨어를 체인으로 연결하는 공식적인 방법이 없음
          + 주요 함수들이 정적 멤버로 되어 있어, 서드파티 미들웨어 사용 시 문제가 발생할 수 있음
          + 미들웨어와 라우트 핸들러 간의 통신 방법이 부족함
          + 헤더를 통해 데이터를 전달하는 방법은 안전하지 않음
          + 자동 캐싱을 포기해야 하는 문제도 있음
          + 요청의 실제 호스트명을 얻기 어려움
     * 미들웨어 시스템의 보안 문제에 대한 다른 기사 발견
          + 헤더를 통한 통신 방식이 사용자 입력 검증과 분리되어 있음
          + 사용자로부터의 모든 헤더를 허용하는 것은 위험할 수 있음
          + 서버 디자인의 문제를 해결하기 위한 프레임워크의 지원이 필요함
     * Next.js의 보안 취약점에 대한 정보
          + 특정 헤더를 추가하면 서버가 잘못된 응답을 할 수 있는 취약점이 있었음
          + 이 취약점에 대한 CVE가 없으며, 어떤 버전이 영향을 받는지 명확하지 않음
          + Next.js의 지원 정책에 따라 특정 버전만 패치가 제공됨
     * Next.js의 보안 문제 해결 지연에 대한 우려
          + 보고 후 2주 이상이 지나서야 문제 해결이 시작됨
          + 문제의 심각성이 제대로 전달되지 않았을 가능성 있음
     * Next.js의 복잡성에 대한 비판
          + React는 많은 가치를 제공했지만, Next는 복잡성을 더할 뿐임
          + 파일 기반 라우팅과 서버 사이드 렌더링은 특정 상황에서만 유용함
     * 보안 취약점의 간단한 실행 가능성
          + 특정 헤더를 추가하면 인증을 우회할 수 있는 문제
     * Next.js의 내부 헤더 사용 문제
          + 재귀 요청을 방지하기 위한 내부 헤더가 있음
          + 이 헤더를 통해 중요한 검증을 우회할 수 있는 가능성 있음
     * Next.js의 자가 호스팅 선택에 대한 불안감
          + HN의 댓글을 읽을수록 선택에 대한 불안감이 커짐
     * 보안 문제 해결 지연에 대한 우려
          + 13일 동안 문제 해결이 지연된 것은 큰 문제임
"
"https://news.hada.io/topic?id=19903","Google, Gemma 3는 단일 GPU에서 실행가능한 가장 강력한 AI 모델이라고 주장","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Google, Gemma 3는 단일 GPU에서 실행가능한 가장 강력한 AI 모델이라고 주장

     * Google은 Gemini AI 기술을 기반으로 한 Gemma AI 모델의 후속 버전인 Gemma 3를 발표함
     * Gemma 3는 개발자가 다양한 플랫폼에서 AI 애플리케이션을 실행할 수 있도록 설계됨
          + 스마트폰에서 워크스테이션까지 실행 가능
          + 35개 이상의 언어 지원
          + 텍스트, 이미지 및 짧은 동영상 분석 가능
     * Google은 Gemma 3가 ""세계에서 가장 뛰어난 단일 가속기 모델""이라고 주장함
          + Facebook의 Llama, DeepSeek, OpenAI의 모델보다 단일 GPU에서 더 우수한 성능 제공
          + Nvidia GPU 및 전용 AI 하드웨어에서 최적화된 성능 발휘
          + 비전 인코더(vision encoder) 개선
               o 고해상도 및 비정사각형 이미지 지원
          + 새로운 ShieldGemma 2 이미지 안전 분류기 포함
               o 성적으로 노골적인 콘텐츠, 위험하거나 폭력적인 콘텐츠를 필터링
     * Gemma 3는 Chatbot Arena의 ELO 점수 순위에서 상위권에 오름
          + 단일 Nvidia H100 GPU에서 높은 성능 기록
     * Gemma 모델의 ""오픈"" 또는 ""오픈소스"" 정의에 대한 논란 지속
          + Google의 라이선스는 사용 제한을 두고 있으며, 이번 발표에서도 변동 없음

        Hacker News 의견

     * 어떤 AI 모델은 기도를 할 수 있음. 성경적 조언을 구했더니 기도해준다고 했음
     * 얼마나 작은 모델이 ""일반적으로 지능적""일 수 있는지 궁금함. 모든 정보를 담기에는 너무 작은 크기가 있을 것 같음
          + 특정 분야에 특화된 작은 모델이 언제쯤 나올지 궁금함. 예를 들어 코딩 도움을 받을 때 ""Jaws""의 감독을 알 필요는 없을 것 같음
          + 아마도 미래에는 많은 작은, 특화된 모델이 있을 것 같음
          + 또는 컴퓨팅 성능이 향상되어 데스크톱이나 휴대폰에서 완전한 기능의 모델을 실행할 수 있을지도 모름
     * Llama 3.3 70B는 ""하나의 GPU""에서 실행되는 것으로 간주되지 않을 수 있지만, 하나의 Mac에서는 잘 실행됨
          + 긴 대화에서 개념을 유지하는 데 있어 Gemma 3보다 훨씬 나음
     * Gemma 3는 2에 비해 글쓰기에 훨씬 나음
          + 큰 개선점은 32k+ 컨텍스트 윈도우를 실제로 사용할 수 있고 무작위 쓰레기로 변하지 않음
     * Mistral이 3.1 Small을 출시한 후 일주일 동안 지속됨. AI의 빠른 발전 속도임
     * Mistral Small 3.1이 Gemma 3 이후에 출시되었는데 훨씬 나음
          + 거부가 적고, 더 정확하며, 덜 횡설수설하고, 특히 코딩에서 더 나음
     * 기술적으로, 1.58-bit Unsloth quant의 DeepSeek R1은 단일 GPU와 128GB의 시스템 RAM에서 실행됨
          + 성능이 매우 뛰어나지만 서두르지 않는 것이 좋음
     * 지난주 Google 게시물: [링크]
     * GoogleAI를 사용하는 사람이 있는지 궁금함
          + AI CEO가 있는 AI 회사에서 AI 언어 번역을 사용하는데, 실제 GPT 제품은 모두 형편없고 평판도 나쁨
          + 누가 자신의 개인 대화를 구글로 보내 감시받고 싶겠음?
     * 그것이 잘린 바닥에서 실행되는지 궁금함
"
"https://news.hada.io/topic?id=19868","북미 비디오 게임 노동자 산업 전반 노조 설립","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       북미 비디오 게임 노동자 산업 전반 노조 설립

     * 북미 비디오 게임 노동자, 산업 전반의 노조 결성
     * 미국과 캐나다의 비디오 게임 노동자들이 산업 전반의 노조를 결성함. United Videogame Workers-CWA (UVW-CWA)는 예술가, 작가, 디자이너, QA 테스터, 프로그래머, 프리랜서 등 다양한 직군의 노동자들을 하나로 모아 스튜디오와 현재 직업 상태에 관계없이 노동자 권한을 강화하는 것을 목표로 함.
     * 이 노조는 GDC에서 열린 ""비디오 게임 노동의 갈림길: 산업 전반의 조직화로의 새로운 경로"" 패널에서 공식적으로 데뷔함. 노동자들은 이 행사에서 노조에 대한 지지를 얻기 위한 청원을 공유하고 최근 산업 내 대량 해고 문제를 조명할 예정임. 2024년에 10명 중 1명의 개발자가 해고된 것이 첫 번째 주요 문제로 다루어질 예정임.
     * UVW-CWA는 조직의 사명 선언문, FAQ, 사설을 포함한 잡지를 배포할 예정임. 이 노조는 직접 가입 방식으로, 노동자들이 스스로 가입할 수 있음. 이는 전통적인 노조화 과정인 선거나 고용주의 동의를 우회할 수 있게 함.
     * 이 노조가 산업 전반에 확산될지, 주요 출판사들이 이를 인정할지는 불확실함. 그러나 이는 산업 노동자들과 기업 간부들 간의 지속적인 싸움의 최신 움직임임. 최근 Microsoft 소유의 Activision의 600명 이상의 QA 노동자들이 Communications Workers of America (CWA)에 가입함. ZeniMax Online Studios 노동자들은 작년 말에 자체 노조를 결성했고, Sega of America 노동자들도 유사한 행동을 취함.
     * 이러한 노조들은 활발히 활동 중임. CWA는 Raven Software의 노동자들을 위한 부당 노동 관행에 대해 Microsoft와 Activision과 싸우고 있음. ZeniMax Workers United-CWA의 회원들은 작년에 Microsoft의 아웃소싱 사용을 제한하기 위해 하루 파업을 벌임.

        Hacker News 의견

     * 직접 가입할 수 있는 조합은 전통적인 조합화 과정 없이 가입할 수 있는 것임
          + 이런 조합은 미국에서 일반적으로 생각하는 조합과는 다름
          + 조합원들은 회사와의 계약 없이 개인적으로 행동하며, 파업을 요청할 수 있지만 주로 인식을 높이고 변화를 촉구하는 데 중점을 둠
     * 개인적인 의견으로, 불안정한 산업에 조합을 도입하는 것이 해결책이 될 수 없다고 생각함
          + 영화 산업에서 넘어온 사람들은 대부분의 역할이 계약직으로 변할 것이라고 말함
          + 시장 압박으로 인해 게임 가격이 낮아지고, 개발 비용을 감안하면 $150,000의 수익은 충분하지 않음
     * 게임 산업은 영화와 음악 산업에 비해 계약, 역할, 권리 표준화에서 100년 뒤처져 있음
          + 이 새로운 시도가 이러한 문제를 해결할 기회를 제공함
     * United Videogame Workers-CWA의 출범 소식
          + CWA는 Google, Apple Stores, Mapbox, NY Times, NPR, 그리고 여러 게임 회사의 조합화 노력에 관여하고 있음
     * ""direct-join union""에 대해 처음 들었으며, 더 많은 정보를 찾고 싶음
          + 미국 IT 노동자를 위한 조합이 있는지 궁금함
     * Ashly Burch가 참여하지 않으면 나도 참여하지 않겠음
          + 누가 이익을 얻고 있는지, 내가 좋아하는 사람이 있는지 확인해야 함
     * 비디오 게임 노동자들이 대기업에 의해 오랫동안 착취당해왔음
          + 이러한 변화가 너무 늦게 이루어지고 있음
     * 미국 게임의 품질이 하락하고 있으며, 조합이 이러한 문제를 해결할 수 있을지 의문임
"
"https://news.hada.io/topic?id=19976","Show GN: 쉽고 빠르게 설치할 수 있는 최신 Git 라이브러리, es-git","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Show GN: 쉽고 빠르게 설치할 수 있는 최신 Git 라이브러리, es-git

   지금까지 Node.js에서 Git을 다루려면 느린 설치 속도를 감내하거나, 비효율적으로 Git 프로세스를 직접 띄워야 했어요.

   토스에서 Git을 현대적이고 쉽게 사용할 수 있는 라이브러리인 es-git을 공개해요.

  특징

     * 사전 빌드된 네이티브 모듈을 포함하고 있어서 빠르게 설치가 가능해요.
     * libgit2을 내장해 높은 성능과 안정성을 보장해요.
     * 쉽고 간편한 인터페이스를 제공해요.
     * 강력한 TypeScript 타입을 지원해요.

  성능

     * es-git: 미리 빌드된 네이티브 바이너리를 제공해서 매우 빠르게 설치돼요.
     * nodegit: node-gyp를 사용하기 때문에 네이티브 빌드가 필요하고 실패하기 쉬워요.

  런타임 성능

     * es-git: N-API를 통해서 바로 libgit2를 호출해서 최대 100배 빨라요.
     * Git 자식 프로세스 만들기: 프로세스 생성 오버헤드가 발생해요.

   조금 다른 얘기인데, slash 의 템플릿이 아주 예쁘네요

   es-git 도 화이팅입니다

   벤치가 패키지로는 nodegit만 있는데 다른 것도 추가해주심 좋을 듯 Compare 라든지...
     * https://github.com/isomorphic-git/isomorphic-git
     * https://github.com/steveukx/git-js
"
"https://news.hada.io/topic?id=19980","Elixir로 슈퍼볼의 시각적 충실도 조정","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Elixir로 슈퍼볼의 시각적 충실도 조정

Cyanview: Super Bowl의 시각적 일관성을 Elixir로 조정

     * 카메라 셰이딩: Super Bowl과 같은 라이브 이벤트에서 200대의 카메라의 시각적 일관성을 조정하기 위해 카메라 셰이딩 기술을 사용함. 이는 각 카메라의 색상, 노출 등을 조정하여 일관된 방송 경험을 제공하는 것임.
     * Cyanview 소개: Cyanview는 벨기에의 작은 회사로, 라이브 비디오 방송 산업을 위한 제품을 판매하며, 주로 셰이딩에 집중하고 있음. 이 회사의 제품은 올림픽, Super Bowl, NFL, NBA 등 세계적인 라이브 이벤트에서 사용됨.
     * Elixir 선택 이유: Cyanview는 Elixir를 선택하여 네트워킹 기능, 복원력, 빠른 기능 개발을 가능하게 함. Elixir는 다양한 프로토콜과의 통합을 지원하며, 네트워크 상에서 수백 대의 카메라와 장비를 제어할 수 있는 강력한 기반을 제공함.
     * 기술 구성: 시스템은 Yocto Linux 시스템에서 실행되는 RCP 장치로 구성되며, 대부분의 논리는 Elixir와 C로 작성됨. MQTT 프로토콜을 통해 장치 간 통신이 이루어지며, 클라우드 릴레이가 연결성을 지원함.
     * 팀 구성 및 성장: Cyanview는 9년 동안 천천히 성장하여 현재 9명의 직원이 있으며, 이 중 두 명이 Elixir 개발자임. Elixir는 다양한 장비와의 통합을 지원하며, 고객의 성공을 지원하는 데 중점을 둠.
     * 혁신과 고객 중심: Cyanview는 IP 네트워킹을 통해 카메라 시스템의 작동 방식을 재정의함. 무제한 멀티캠, 팬 및 틸트 제어, 색상 보정기와의 통합 등 독특한 기능을 제공함.
     * 미래 전망: Cyanview는 팀을 책임감 있게 성장시키고, 클라우드 제공 및 하드웨어 프로젝트를 통해 더 많은 발전을 계획하고 있음. Elixir는 앞으로도 세계적인 라이브 방송에서 중요한 역할을 할 것임.

        Hacker News 의견

     * 물론 스포츠 이벤트에서 다양한 각도로 촬영된 모든 카메라에 색 보정을 해야 함
     * 보이지 않는 어려운 문제에 대해 읽는 것을 매우 좋아함
     * 누군가가 하프타임 쇼 동안 모든 카메라 샷을 추적했음
     * 마케팅 없이도 숙련된 전문가들 사이에서 명성을 얻고 세계 최고의 라이브 이벤트에서 필수 요소가 되었음
     * 엔터테인먼트 산업처럼 보임. 특히 매년 같은 쇼에서 같은 팀과 작업할 때 모두가 서로를 잘 알고 있음
     * 확실히 일종의 가족 같음
     * Elixir가 중요한 방송 시스템에서 인기를 얻고 있는 것을 보니 좋음. Cyanview의 신뢰성이 Elixir에서 얼마나 오는지, 아니면 단순히 MQTT의 좋은 구현에서 오는 것인지 궁금함. 다른 언어에서 복제할 수 없는 특정 Elixir 기능이 있었는지 궁금함
     * Gleam이 OTP/BEAM 런타임 외에 유사한 응용 프로그램에 실용적인지 궁금함. 아직 Gleam에 없는 Elixir 라이브러리를 활용해야 할 것이고, 정적 타이핑으로 인해 컴파일 시간이 더 느릴 수 있지만 런타임 오류를 더 빨리 잡을 수 있음. 디버깅 대 빠른 동적 반복의 트레이드오프가 될 것인지 궁금함. Gleam이나 Elixir 중 하나를 선택하려고 함. 이전에 Gleam의 원래 ML 문법을 좋아했지만 정적 타이핑을 좋아함. 생각이 있는지 궁금함. C를 Zig로 대체하고 있으며, x64 기술에 ARM을 추가하여 어셈블리를 복습하고 있음
     * 30여 년 전, 스튜디오 환경에서 카메라 색 균형을 맞추는 것이 내 역할의 일부였음. 컴퓨터가 필요하지 않았지만 최대 5대의 카메라만 있었음
     * 정말 멋진 부분이 눈에 띄었음. 특정 위치의 장치들이 네트워크에서 사용자 정의 MQTT 프로토콜을 통해 통신하고 조정함. Elixir의 네트워크 스택 위에 구현된 단일 원격 제어 패널(RCP)에서 문제 없이 백여 대의 카메라를 다룸. 이해가 됨. MQTT는 내가 이해하기로는 TCP 위에 구축됨. 같은 솔루션을 찾지 못했을 수도 있지만, 좋은 솔루션인 것 같음
     * 디지털 비디오 세계가 IT의 사촌이지만 비디오 산업 외부 사람들에게는 접근하기 어려운 것이 항상 놀라웠음. 해상도, 색상, 네트워킹, 저장소를 언급하는 방식이 (거의 의도적으로?) 다름
     * Elixir를 중요한 금융 응용 프로그램, B2B 성장 인텔리전스 응용 프로그램, 사기 탐지 응용 프로그램, 스캔 앤 고 쇼핑 응용 프로그램 등 여러 곳에 구현했음. 모든 경우에, 이 기사에서 언급된 엔지니어링 팀처럼 개발자 경험과 최종 결과가 기대를 초과했음. Elixir를 사용해보지 않았다면 시도해보길 권장함
     * 편집: 편집 오류 수정함
     * 이 슈퍼볼 외의 유사한 방송 설정에서 무엇이 사용되고 있는지 궁금함
"
"https://news.hada.io/topic?id=19978","OpenAI, Agents SDK에 MCP 지원 추가","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     OpenAI, Agents SDK에 MCP 지원 추가

     * MCP(Model Context Protocol) 는 LLM에게 도구와 컨텍스트를 제공하는 표준화된 방식임
     * USB-C 포트처럼, 다양한 데이터 소스나 도구와 AI 모델을 연결하는 표준 인터페이스 역할을 함
     * OpenAI Agents SDK는 MCP를 지원하여 다양한 MCP 서버와 통합 가능함

MCP 서버

     * 현재 MCP 사양은 사용하는 전송 메커니즘에 따라 두 가지 종류의 서버를 정의함:
         1. stdio 서버는 애플리케이션의 하위 프로세스로 실행되며, ""로컬""에서 실행되는 것으로 생각할 수 있음.
         2. HTTP over SSE 서버는 원격으로 실행되며, URL을 통해 연결함.
     * MCPServerStdio와 MCPServerSse 클래스를 사용하여 이러한 서버에 연결할 수 있음.
     * 예를 들어, 공식 MCP 파일 시스템 서버를 사용하는 방법은 다음과 같음:
async with MCPServerStdio(
    params={
        ""command"": ""npx"",
        ""args"": [""-y"", ""@modelcontextprotocol/server-filesystem"", samples_dir],
    }
) as server:
    tools = await server.list_tools()

캐싱

     * 에이전트가 실행될 때마다 MCP 서버의 list_tools()를 호출하는 것은 지연 시간을 초래할 수 있음. 특히 서버가 원격 서버일 경우 더욱 그러함.
     * 도구 목록을 자동으로 캐시하려면 MCPServerStdio와 MCPServerSse에 cache_tools_list=True를 전달할 수 있음. 도구 목록이 변경되지 않을 것이라고 확신할 때만 이를 수행해야 함.
     * 캐시를 무효화하려면 서버에서 invalidate_tools_cache()를 호출할 수 있음.

   Anthropic, Model Context Protocol 오픈소스로 공개
   Model Context Protocol (MCP) 개발 방법
   MCP와 API 비교 설명
   Awesome MCP Servers - Model Context Protocol 지원하는 서버들 목록

        Hacker News 의견

     * 오늘 MCP가 Streamable HTTP를 추가했음. 이는 원격 HTTP 서버에 항상 연결할 필요가 없다는 점에서 큰 진전임
          + 하지만 사양을 보면 LSP 스타일 패러다임을 원격 HTTP 서버에 도입하는 것이 많은 복잡성을 추가하고 있음
          + 전통적으로는 &#x2F;get_weather에 { ""location"": ""New York"" }를 HTTP POST로 보내는 방식이었음
          + 복잡성을 줄이고 전통적인 HTTP 서버로 돌아가자는 제안을 했음. 세션은 Authorization 헤더로 협상하고 전통적인 엔드포인트를 사용함
          + 서버 구축이 훨씬 쉬워지고 웹 프레임워크가 사양에 맞게 업데이트될 필요가 없을 것임
     * MCP를 AI 애플리케이션의 USB-C 포트로 생각하라는 비유가 있음
          + 소프트웨어 엔지니어로서는 그 비유가 도움이 되지 않음
     * OpenAI가 이를 공식적으로 지지할지 궁금했지만, 이제 답을 얻었음
          + MCP는 LLM을 외부 도구에 연결하는 산업 표준이 되었음
     * OpenAPI를 지원하기를 바랐음. 몇 개의 MCP 서버를 만들었지만 덜 유연하고 문서화가 잘 안 되어 있는 API로 느껴짐
          + MCP가 OpenAPI보다 나은 점을 찾기 어려움. 코드가 조금 줄어들지만 선택지가 훨씬 줄어듦
          + 시간이 지나면 Swagger가 내장될 것임
     * MCP의 가치가 무엇인지 이해하기 어려움. 현대 AI 기술의 혼란 속에서 또 다른 산만함으로 느껴짐
          + MCP는 애플리케이션이 LLM에 컨텍스트를 제공하는 방식을 표준화하는 개방형 프로토콜임
          + 표준화할 것이 무엇인지 의문임. 우리는 임의의 토큰화된 문자열로 작동하는 텍스트-텍스트 변환기를 사용하고 있음
          + 도구/기능 호출 같은 것도 단순한 텍스트 위에 있는 영리한 휴리스틱임
     * AI 에이전트가 로컬에서 ""도구""를 사용할 수 있는 아키텍처를 만들었음. 모든 종류의 LLM 및 LLM 서버와 작동함
          + 미들웨어로 작동하며 LLM 서버와 채팅 클라이언트 사이에서 스트림으로 작동함
          + 오픈 소스 프로젝트이며, 코드에 관심을 보이는 사람이 없어 리포가 업데이트되지 않음
     * MCP를 실제로 어떻게 사용하는지에 대한 비디오가 부족함. 프로그래머에게 실질적인 사용 사례가 부족함
     * MCP를 AI 애플리케이션의 USB-C 포트로 생각하라는 비유가 있음
          + USB 구현에 많은 고통이 따른다는 이야기를 많이 들었기 때문에 다른 비유를 찾는 것이 좋을 것임
     * MCP의 구버전인 HTTP+SSE를 대상으로 하고 있는 것 같음. 새로운 Streaming HTTP 버전이 아님
          + OAuth 2.1 지원, JSON-RPC 배칭 등도 있음
     * MCP를 간단하게 시도해보고 싶다면 <a href=""https://skeet.build/mcp"" rel=""nofollow"">skeet.build/mcp</a>를 만들었음
          + 복잡한 MCP 설정, 지원 부족, 자체 구축의 어려움 때문에 만들었음
          + 주로 다음과 같은 워크플로우를 위해 사용됨
               o PR 시작 시 요약 작성
               o Linear/Jira에 요약 슬랙 또는 댓글
               o Sentry에서 이슈 가져와서 수정
               o 버그 발견 시 Linear 이슈 생성
               o Linear 이슈 가져와서 첫 번째 패스
               o Notion 문서와 PRD 가져와서 코드 기반으로 API 참조 생성
               o 빠른 모델 개발을 위한 Postgres 또는 MySQL 스키마
          + 사용 용이성, 실용적인 개발자 워크플로우, 고품질의 MCP 서버에 중점을 두고 있음

   저도 OpenAPI function calling 이 낫지 않나 생각이 듭니다. 이거 MCP 프로토콜로 다시 만드는 것도 일이거든요.

   push 와 poll 차이 아닐까요. 모델, 서비스마다 function calling 하는 것보다 mcp 스펙을 호스팅하고 에이전트가 poll 해가는 방식이 3rd party 한테는 편리항거 같습니다
"
"https://news.hada.io/topic?id=19860","케즘(Chasm)에서 살아남기","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            케즘(Chasm)에서 살아남기

     * ""B2B 창업자를 위한 Go-To-Market 가이드: Idea부터 Product-Market Fit까지""
     * 많은 창업자는 시장 진입 전략(GTM) 을 완벽한 아웃바운드 캠페인이나 영업팀의 목표 초과 달성으로 생각함
     * 그러나 실제로 중요한 것은 제품-시장 적합성(Product-Market Fit) 을 찾기까지의 0에서 1로 가는 과정임
     * 이 과정에서 초기 전략이 결정되며, 잘못된 방향 설정 시 이후에 수정하기 어려움

0에서 1로 가는 과정의 5단계

    1. 사전 판매 (Pre-Sell)
    2. 디자인 파트너 확보 (Design Partners)
    3. 초기 고객 확보 (Your First Customers)
    4. 성장 엔진 구축 (Building a Growth Engine)
    5. 창업자 주도 판매를 넘어 확장 (Scaling Beyond Founder-Led Sales)

1. 사전 판매 (Pre-Sell)

     * 초기 창업자의 일반적인 실수
          + 고객이 필요하다고 추측 하는 제품을 먼저 개발 → 출시 후 고객 요구와 불일치
          + 해결책: 제품 개발 전에 잠재 고객 확보 → 고객이 실제로 원하는 제품 제공
     * 아이디어 단계에서 시작해야 할 작업
          + 제품 코딩 전에 수십~수백 건의 고객 인터뷰 수행
          + 제품 피칭이 아닌 고객 문제 및 요구사항 파악에 집중
          + 열린 질문 사용 → “이 제품을 사용하시겠습니까?” 대신 “무엇이 더 편리해지면 좋을까요?”
     * 가설 솔루션 정의를 위한 주요 질문
          + 제품이 고객에게 창출하는 구체적 가치
          + 현재 프로세스에서 대체 가능한 부분 및 작동 방식
          + 경제적 구매자와 실제 사용자 구분
          + 제품 구매 예산 및 유사 도구 사용 비용
          + 구매 프로세스 및 주요 결정 요인
          + 제품이 구매자 및 사용자의 목표(OKR)에 미치는 기여도
          + 실제 제품 도입을 위한 최소 요구사항(통합, 보안 등)
     * 디자인 파트너 확보
          + 가장 적극적인 잠재 고객을 디자인 파트너로 확보
          + LOI(Letter of Intent)를 통해 피드백 제공 및 제품 시험 사용 약속 확보
          + 맞춤형 제품 파일럿 참여를 거부한다면 → 충분히 큰 문제 해결 못했을 가능성 높음
     * 초기 제품 가치 제시 전략
          + Figma 목업 및 프레젠테이션만으로 가치를 시각화
          + 개발 부담 최소화하면서 개념적 프레임워크 시연
     * LOI에 마일스톤 및 가격 명시
          + 마일스톤 → 최소 기능 제품(MVP)에 대한 명확한 기대치 설정
          + 가격 → 실제 지불 의사가 있는지 확인 가능
          + 무료 제품에 대한 관심은 쉽게 얻을 수 있으나, 유료 전환 시 고객의 진정한 가치 인식 가능
     * 파일럿 기간 후 할인 제공 전략
          + 고객은 초기 협력에 대한 보상으로 할인을 받음
          + 고객이 합리적이라고 생각하는 전체 가격에 대한 기준 확보 가능
          + 평균 계약 가치(ACV) 평가 → 제품 전략 및 시장 진입 전략 수립에 중요한 정보 확보
     * 기대치 설정의 중요성
          + 성숙한 제품은 높은 실행 기준 요구
          + 디자인 파트너 단계에서는 협업 과정에서의 제품 미완성 상태 명확히 고지 필요
     * 사전 판매 단계의 핵심 목표
          + 충분히 큰 문제를 해결하고 있는지 검증
          + 고객 요구사항에 맞는 제품 정의
          + 고객 인터뷰 및 시장 검증을 통해 초기 전략 명확히 설정

2. 디자인 파트너 확보 (Design Partners)

     * 명확한 전략 수립 후 제품 구축 단계 진입
          + 초기 전략이 검증되고 적극적인 디자인 파트너 확보 → 이제 실제 제품 구축 단계
          + 고객의 핵심 문제를 해결하고 대부분의 잠재 고객이 원할 만한 제품 개발 목표
     * 디자인 파트너 선정 기준
          + 광범위한 시장을 대표할 수 있는 고객 확보
          + 맞춤형 솔루션이 아닌 범용적인 기능 구축 목표
     * 초기 고객 수 제한의 중요성
          + 제품 검증 전까지는 초기 고객 수를 제한해 리소스 분산 방지
          + B2B 회사 기준 초기 디자인 파트너 수는 3~5개가 적정
     * 디자인 파트너와의 협업 구조 설정
          + 사전 협업 구조 설정 → 고객과의 기대치 일치 필요
          + 정기적인 피드백 세션 설정 (예: 매주 혹은 격주 미팅)
          + 사전에 명확한 의제 공유 → 기대하는 피드백 구체화
               o 내부 인터뷰
               o 온보딩 과정 모니터링
               o 제품 사용 패턴 관찰
     * 고객 요구사항 기반의 제품 개선
          + 고객의 광범위한 요구사항 이해 및 반영
          + 고객이 제품 성공에 기여하고 있다고 느끼게 함 → 이후 추천 및 레퍼런스 확보에 유리
     * 빠른 제품 반복 및 개선
          + 고객 피드백 기반의 빠른 반복 주기 설정
          + 기능 완성도를 높이는 데 시간 낭비 금지 → 빠른 출시 후 피드백 반영이 중요
          + 실제 고객의 사용 경험이 가장 정확한 정보
     * 주요 실패 요인 방지
          + 고객이 요구하는 기능을 완벽하게 구현하는 데 집중 → 실제 사용 시 실패 가능성 높음
          + 실제 피드백과 사용 데이터에 기반해 제품 개선에 초점

3. 초기 고객 확보 (Your First Customers)

     * 초기 디자인 파트너에서 첫 번째 실제 고객군으로 확장
          + 제품에 대한 자신감이 생기고 디자인 파트너가 자립하기 시작하면 확장 시점 도달
          + 고객 요구사항을 이해하고 대응할 수 있는 상태에서 점진적 확장 필요
     * 단계별 출시 전략의 필요성
          + 고객 요구사항을 이해하면서 확장 가능성 탐색
          + 디자인 파트너와 유사한 고객 확보 → 시장 준비 완료 상태에서의 테스트
     * 초기 고객 확보 경로
          + 산업 내 네트워크, 투자자, 개인 인맥 → 초기 고객 확보 주요 경로
          + 이상적으로는 새로운 고객군 확보 → 기존 인맥 기반 고객군에 의존 시 실제 시장 반응 왜곡 위험
     * 파일럿 프로그램 구조화
          + 디자인 파트너와 유사한 파일럿 진행 → 자동 전환 구조 설정
          + 파일럿 종료 후 재협상 없이 정식 계약 전환
     * 세일즈 전략 개선을 위한 고객 인사이트 확보
          + 초기 디자인 파트너에서 얻은 인사이트 기반으로 세일즈 전략 개선
          + 새로운 고객 온보딩 시 다음 요소에 주의:
               o 어떤 메시지가 고객에게 잘 전달되는가?
               o 누가 의사결정권자인가?
               o 어떤 요인이 계약을 성사 혹은 지연시키는가?
               o 예산 배분 과정은 어떤가?
               o 구매 결정 시점 및 위치는 어디인가?
               o 제품 성과는 어떻게 측정되는가?
     * 데이터 기반 전략 조정
          + 고객 응답 및 행동 데이터를 철저히 문서화 → 메시징 및 제품 전략 지속 개선
          + 명확한 고객 페르소나 및 타겟 세그먼트 정의 필요
     * 고객 선택에서의 주요 리스크 및 회피 전략
          + 대형 엔터프라이즈 계약의 위험성
               o 초기에는 지나치게 큰 계약보다 다수의 작은 계약이 안정적
               o 대형 고객에 집중 → 리소스 과다 소모 및 리스크 발생 가능
          + 고객 맞춤형 요구 과다의 위험성
               o 과도한 커스텀 요구 → 다른 고객에게 확장 불가 시 리소스 낭비
               o 예: 특수한 데이터 구조, 특정한 통합 요구 등
          + 확장 불가능한 고객 프로필의 위험성
               o 초기 성공 사례가 전체 시장을 대표하지 못할 경우 리소스 낭비
               o 예: 소규모 매장 대상 제품 → 실제 타겟이 중견기업일 경우 의미 없음
     * 고객 선택 기준 질문
          + 핵심 제품 개발과 병행 가능한 요구사항인가?
          + 고객의 지속적인 지원 요구를 처리할 수 있는가?
          + 이 고객 유형을 반복적으로 확보할 수 있는가?
          + 해당 고객의 요구사항이 다른 고객군에서도 공통으로 발생하는가?
          + 현재 제품이 이 고객에게 실질적인 가치를 제공할 수 있는가?
     * 부적합한 고객 과감히 정리
          + 명확한 타겟 고객군에서 벗어난 고객은 과감히 포기
          + 매출 손실보다 비효율적 고객 지원에 따른 기회비용이 더 크다는 점 인식

4. 성장 엔진 구축 (Building the Growth Engine)

     * 초기 고객 확보 후 확장 단계 진입
          + 초기 고객이 안정적으로 제품을 사용하기 시작하면 성장 엔진 구축 단계로 전환
          + 창업자가 직접 영업을 주도하면서 제품-시장 적합성(PMF) 확보 후 확장 진행
          + 연간 반복 수익(ARR) 약 $100만 수준에 도달 후 본격적인 세일즈 팀 확장
     * 이 단계는 실험 단계
          + 어떤 GTM 전략이 효과적인지 실험하고 학습
          + 초기 세일즈 팀은 창업자가 설정한 전략을 따라가므로 초기 전략 설정이 중요
          + 제한된 자원으로 다양한 전략을 실험해 장기적인 성공 기반 마련
     * 성장 엔진의 4가지 핵심 요소
          + 1. GTM 전략 (Go-To-Market Motion)
               o 인바운드, 아웃바운드, PLG, ABM 등 다양한 전략 조합 필요
               o 고객의 구매 결정 과정에 대한 이해 필요
                    # 새로운 카테고리 제품 → 고객 교육 필요
                    # 기존 카테고리 제품 → 구매 결정 순간에 고객 접근이 중요
               o ACV(평균 계약 가치)가 높을수록 고관여 전략 필요
                    # 간단한 제품 → 낮은 터치포인트
                    # 고가 계약(6~7자리 금액) → 다수의 터치포인트 필요
          + 2. 구매 여정 (Buyer’s Journey)
               o 제품 가치 제시 → 고객의 구매 프로세스 파악
               o 주요 의사 결정자와 사용자를 동시에 설득
               o 단순한 제품 → 공개 데모로 충분
               o 복잡한 제품 → 맞춤형 데모 및 1:1 온보딩 필요
               o 고객 페르소나별 구매 여정 실험 → GTM 전략 확립 시 효과적
          + 3. 판매 채널 (Channels)
               o 고객 접점이 어디인지 파악하고 실험
                    # LinkedIn, Twitter, TikTok 등 소셜 채널
                    # 업계 행사, 컨퍼런스 등 오프라인 채널
                    # 파트너 채널 → 신뢰 기반 접근 전략 가능
               o 여러 채널에서 동시에 접근해 고객 확보 기회 극대화
               o 고객 추천, 산업별 에코시스템 활용 → 하이퍼 스케일 모드 진입 가능
          + 4. 피치 및 포지셔닝 (Pitch and Positioning)
               o 제품의 시장 내 위치 및 경쟁사 대비 차별점 명확히 설정
               o 고객 유형별로 다른 메시지와 접근 방식 필요
               o 성공적인 피치 구조화 → 반복 가능한 세일즈 전략 마련
     * 기본적인 세일즈 퍼널 설정 및 전환율 추적
          + 첫 미팅 후 고객 이탈 시 원인 분석
               o 잘못된 대상 접근 vs 메시지 전달 문제
          + 고객 반응 기반으로 전략 지속 조정
     * 이상적인 고객 페르소나(ICP) 명확화
          + 예: “시리즈 B 펀딩을 받은 로봇 회사 중 데이터 과학 팀을 구축하지 않은 회사”
     * 반복 가능한 세일즈 프로세스 구축
          + 세일즈 프로세스 및 성과 추적 → 일관된 전략 구축
          + 세그먼트별 다른 GTM 전략 수립 가능
     * 성장 엔진 구축 후 알아야 할 사항
          + 타겟 고객(ICP)이 누구인가?
          + 해당 고객에게 어떻게 접근해야 하는가?
          + 주요 의사 결정자는 누구이며, 구매 프로세스는 어떻게 진행되는가?
          + 세일즈 사이클에서 가장 빠르게 성사되는 지점은 어디인가?
          + 고객 이탈의 주요 원인은 무엇인가?
          + 세일즈 사이클은 평균적으로 얼마나 걸리는가?
          + 제품의 핵심 메시지는 무엇인가?
          + 제품 ROI(투자 대비 성과)는 어떻게 측정되는가?
     * 수익성과 확장 가능성 검증
          + 고객이 기꺼이 지불할 금액(ACV, ARPU, LTV) vs 고객 획득 및 서비스 비용(CAC) 비교
          + 현재 고객이 가장 강력한 초기 고객군 → 현재 경제 구조가 지속 가능하지 않다면 장기적으로도 지속 불가

5. 창업자 주도 판매를 넘어 확장 (Scaling Beyond Founder-Led Sales)

     * GTM 플레이북 및 세일즈 프로세스가 명확해진 상태에서 확장 시점 도달
     * 창업자가 성장의 병목 현상이 되는 시점 → 세일즈 팀 확장 필요
     * 세일즈 팀 초기 구성 전략
          + 채용 우선순위 결정
               o 채용 우선순위는 다음 요소에 따라 결정:
                    # 세일즈 퍼널에서 가장 큰 병목 현상이 발생하는 지점
                    # 판매 전략(GTM Motion) 유형 및 타겟 고객 특성
                    # 창업자의 역량에서 보완이 필요한 부분
          + 헤드 오브 세일즈(Head of Sales) 채용 신중히 접근
               o 많은 창업자는 헤드 오브 세일즈를 먼저 채용하려 함 → 비효율적일 수 있음
               o 초기 단계에서는 주니어급 인재가 더 적합
                    # 창업자의 전략을 기반으로 아웃바운드 영업 수행 가능
                    # 고위급 인력 → 고정된 전략 고집 가능성 높음
          + 특정 산업에서는 예외적 상황 발생 가능
               o 관계 중심의 산업에서는 경험 많은 리더가 더 효과적일 수 있음
               o 그러나 이 경우에도 고위 인력은 컨설턴트나 고문으로 참여하는 것이 효과적
     * 주니어 인재의 페어 채용 전략
          + 초기 세일즈 인력은 페어로 채용
               o 경쟁 구도를 통해 성과 강화
               o 성과 비교 및 성과 평가 용이
               o 한 명이 퇴사해도 세일즈 프로세스 중단 위험 감소
          + 성과 목표 설정
               o 창업자의 성과 대비 50% 수준에서 초기 목표 설정
               o 창업자가 일반적으로 세일즈 성과가 더 높음 → 이를 감안한 목표 설정 필요
     * 세일즈 팀 보강 및 확장 전략
          + 필요 시 외부 리소스 활용
               o 예: 화이트 페이퍼 작성 계약자, 소셜 미디어 인턴 등
               o 핵심 세일즈 인력의 부담 최소화
          + 팀 성과 안정화 후 추가 확장 진행
               o 초기 세일즈 인력이 성과를 안정적으로 달성 → 추가 확장 진행
               o 내부에서 리더 육성 또는 외부에서 경험 많은 리더 영입
     * 세일즈 리더 영입 시점
          + 초기 인력이 성과를 안정적으로 달성하고 예측 가능한 성장이 가능해질 때
          + 새로운 GTM 전략 기반으로 팀 확장 및 재구성 가능

     * 이 시점에서 공식적으로 “1.” 단계 도달 완료!
"
"https://news.hada.io/topic?id=19938","Git의 새로운 bundle-uri 토끼굴에 빠져들기","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Git의 새로운 bundle-uri 토끼굴에 빠져들기

     * bundle-uri는 Git의 새 기능으로, 캐시된 파일을 다운로드해 프로젝트 데이터를 미리 채운 후 서버와의 복잡한 페치 과정을 줄임
     * 일반적으로 git clone 명령어는 서버와 협상 과정을 거쳐 필요한 데이터를 다운로드함 → 비효율적일 수 있음
     * bundle-uri는 CDN에서 캐시된 초기 데이터를 받아오고, 이후 서버에서 최신 상태만 업데이트하도록 함 → 시간 단축 가능

클론 속도가 빨라지는가?

  Yes? - 빠를 수 있다

     * 로컬 파일 옵션을 사용하면 클론 속도가 매우 빨라짐
     * VM에서 마운트된 파일 시스템이나 클라우드 캐시에서 번들 파일을 사용하면 더 빠르게 동기화 가능

  No? - 더 느릴 수 있다

     * 동일한 데이터를 CDN에서 받아오면 빠를 것 같았으나, 오히려 더 느렸음
     * 실험 결과: 번들을 사용한 클론이 일반 클론보다 더 느림
          + 일반 클론: 2분 36초
          + 번들 사용 클론: 3분 20초
     * 번들에서 이미 받은 객체가 다시 다운로드되는 문제가 발생함

  Maybe? - 그럴 수도 있다

     * Git이 번들 파일에서 refs/heads (브랜치 참조)만 읽어서 문제가 발생
     * 나머지 참조는 무시되기 때문에 서버에서 추가로 데이터를 다운로드하게 됨
     * Git 코드를 수정해 모든 참조를 복사하도록 하면 클론 속도가 개선됨
          + 수정 후 클론 시간: 2분 19초 (기존 2분 36초보다 빨라짐)
          + 추가로 다운로드한 객체 수: 43,877개 (전체의 약 1%)

수정 방법 및 패치 적용

     * Git의 bundle-uri.c 코드에서 refs/heads 외의 참조를 무시하는 부분을 수정
     * 수정 후 모든 참조를 복사하도록 변경 → 클론 속도 개선
     * 이 수정은 6글자 변경으로 이루어진 최소한의 패치였음

이 기능을 사용해야 할까?

  possibly - 아마 도움 될수도

     * GitHub, GitLab 같은 플랫폼에서는 서버 CPU 부담을 줄일 수 있는 큰 장점이 있음
          + 서버에서 직접 packfile을 계산하지 않고 CDN에서 처리 가능 → 서버 자원 절약
     * 개인 사용자도 유용할 수 있는 경우:
          + 사내 Git 서버에서 대규모 클론을 반복해야 하는 경우
          + CI/CD 시스템에서 반복적인 전체 클론 작업이 필요한 경우

  현실적으로 강제될 가능성이 높음

     * 최신 Git 프로토콜에서는 서버가 클라이언트에 번들 URL을 제공 가능
     * 서버가 번들 파일 URL을 제공하면 클라이언트가 자동으로 다운로드 후 동기화 진행
     * GitHub 등에서 이 기능이 활성화되면 사용자가 선택할 여지가 없음

결론

     * 번들 파일을 사용하면 클론 속도가 더 빠를 수 있지만, Git의 처리 방식 때문에 초기에는 오히려 느려질 수 있음
     * Git의 코드를 수정해 참조 처리 방식을 개선하면 클론 속도가 향상됨
     * 앞으로 GitHub, GitLab 등에서 이 기능을 도입하면 클라이언트에서 자동으로 사용하게 될 가능성이 큼
"
"https://news.hada.io/topic?id=19948","2025년에 BSD를 선택해야 하는 이유","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         2025년에 BSD를 선택해야 하는 이유

     * 20~30년 전의 오픈소스는 자유와 기술적 독립성의 의미였음
     * 당시에는 Windows와 상용 Unix가 지배했으나, Linux와 BSD는 자유를 위한 선택이었음
     * 현재 오픈소스는 주류가 되었지만, 모노컬처(단일 문화) 문제가 발생 중
          + 도구 중심의 개발 → 혁신이 아닌 도구에 집착
          + 보안보다 새로운 기술이 우선시됨

현재의 문제점

     * 안정성이 사라지고 있음
          + ""다음 버전에서 고칠 것이다""
          + ""충돌하면 자동 재시작하면 된다""
          + 시스템 크래시보다 성능이 우선시됨
     * Rust의 메모리 안전성도 안전하지 않은 함수 사용 시 의미가 없어짐

BSD가 제공하는 해결책

     * BSD는 일관성과 안정성 제공
     * BSD 시스템의 철학
          + 커널과 사용자 도구가 같은 팀에서 개발됨 → 일관성 보장
          + 훌륭한 문서화 (특히 OpenBSD)
          + 코드의 단순화 → 보안 강화
          + 점진적 발전 (Evolution), 급진적 변화 아님

주요 BSD 종류와 특징

  FreeBSD

     * 일반 목적 시스템 – 성능과 안정성 중시
     * 보안 강화 버전인 HardenedBSD 존재
     * ZFS, 부트 환경, OS와 패키지 분리
     * Jail 컨테이너 (2000년에 도입됨) – 리눅스 cgroups보다 10년 앞섬
     * Netflix, PlayStation, MacOS 등에서 사용됨

  OpenBSD

     * 보안과 코드 정확성 중시
     * pledge(), unveil() 등 보안 메커니즘 제공
     * OpenSSH 및 다양한 보안 툴의 출발점
     * 팀 우선 개발 – 사용자 요구에 휘둘리지 않음

  NetBSD

     * ""Of course it runs NetBSD!"" – 다양한 플랫폼에서 실행 가능
     * 50개 이상의 아키텍처 지원
     * 코드 품질과 호환성 중시
     * 임베디드 장치 등 오래된 하드웨어에서 안정적 실행

BSD 사용의 실제 장점

     * 더 나은 안정성과 보안성 – BSD 시스템은 안정적이며 보안이 뛰어남
     * 간편한 시스템 관리 – 업그레이드 후에도 시스템이 망가지지 않음
     * 일반적인 보안 취약점에 덜 노출됨 – ""OpenBSD에서는 이미 20년 전에 수정된 문제입니다""
     * 일관된 네트워크 인터페이스 이름 유지 – ix0는 enx3e3300c9e14e 또는 enp10s0f0np0 같은 이름으로 바뀌지 않음
     * FreeBSD의 낮은 시스템 부하 – 동일 하드웨어에서 Linux보다 낮은 부하 유지
     * FreeBSD의 우수한 I/O 처리 성능 – 동일 하드웨어에서 70%의 시간 단축 경험
     * FreeBSD의 개선된 사용자 경험 – 더 빠르고 일관된 반응 속도 제공
     * NetBSD의 장기적인 지원 보장 – ""걱정 마세요 – 플랫폼이 오랫동안 지원될 것입니다""

2025년에 BSD를 선택해야 하는 이유

     * 보안 – 점점 더 위협이 커지는 환경에서 강력한 보안 제공
     * 안정성 – 새로운 기술에 집착하는 세상에서 꾸준한 안정성 유지
     * 성능 – 불필요한 복잡성 없이 효율적인 성능 제공
     * 자유 – 주류 도구와 기술에서 벗어난 독립성 보장
     * 일관된 철학 – 명확하고 일관된 시스템 설계 유지

결론

     * BSD는 자유, 안정성, 보안을 제공하는 대안임
     * 새로운 기술에 휩쓸리지 말고 BSD의 철학을 경험해 보길 권장함

발표 소개

     * OSDay 2025 에서 발표한 것의 요약임. 25분간 발표에서 상세보다는 일반적인 내용을 다룸
     * 발표자 Stefano Marinelli는 BSD Cafe의 설립자이자 Barista이며, 1996년부터 Linux 사용자였음
     * 2002년부터 BSD 시스템 탐구 시작 – FreeBSD 핸드북이 계기였음
     * 발표 슬라이드
     * 발표 영상

        Lobste.rs의 댓글들

     * draga79 (작성자)
          + 발표 시간이 25분밖에 없어서 일반적인 오픈소스 컨퍼런스 환경에 맞게 내용을 간략하게 구성함
          + 기술적인 세부 사항보다 철학적 관점에서 BSD에 대한 관심을 끌기 위한 것이 목표였음
     * jmmv
          + ""모두가 사용하니까""라는 이유로 Linux, Docker, Kubernetes를 사용하는 경향에 공감
          + Docker가 항상 최적의 솔루션은 아님에도 불구하고 표준이 되어버린 현실이 문제라고 지적
          + 복잡한 배포 및 운영 문제를 해결하려고 해도 다른 접근 방식을 설명하면 이해받기 어려움
     * dijit
          + ""AWS와 ECS만 사용해야 한다""는 사고방식에 반대
          + 특정 환경에 맞추는 것은 Amazon에 유리할 뿐이며, 사용자의 자유를 제한함
     * radmind
          + Docker는 시스템 구성 저장에 편리하지만 완벽한 해결책은 아님
          + 가상 머신도 훌륭한 대안이며 BSD를 리얼타임 OS로 사용하려는 경우 어떤 BSD가 좋은지 궁금함
     * sjamaan
          + 컨테이너 사용이 너무 당연시되고 있으며, 복잡성이 증가함
          + GitLab이나 Sentry 같은 도구는 컨테이너 없이 실행하기 어렵고, 이는 비BSD 환경에서 문제를 일으킴
     * jbauer
          + OpenBSD를 서버 및 노트북에서 5년 동안 사용 – 매우 안정적이고 직관적임
          + 내장 소프트웨어가 훌륭해 타사 패키지를 거의 설치할 필요가 없음
          + Unix 계열 중 최고의 품질이라고 평가
     * reezer
          + BSD에 대해 일반화하는 것은 부적절함
          + FreeBSD는 일반적인 용도로, OpenBSD는 보안, NetBSD는 호환성이라는 고정 관념이 틀림
          + 다양한 환경에서 BSD가 실제로 잘 작동하고 있음
     * ploum
          + FreeBSD는 성능과 안정성 제공
          + OpenBSD는 코드 이해도와 보안을 제공
          + Linux는 사용하기 쉬운 데스크탑 환경 제공
     * elobdog
          + OpenBSD는 방화벽 및 네트워크 서비스에서 매우 효과적임
          + 코드가 간결하고 읽기 쉬우며 버그가 적음
          + 오픈소스 커뮤니티에서 자주 경험하는 ""숙제를 하라""는 태도가 프로페셔널 환경에서 유익하게 작용함
     * cryptix
          + FreeBSD의 문서화와 소프트웨어 품질이 뛰어나서 계속 사용 중
          + 복잡한 설정 관리는 피하고 싶음
     * jitl
          + 예전에는 FreeBSD, OpenBSD, Linux를 조합해서 사용했지만 지금은 Docker와 Linux가 더 효율적
          + 특정 네트워크 장비나 어플라이언스에는 BSD가 더 적합할 수 있음
     * david_chisnall
          + OpenBSD와 FreeBSD 모두 컨테이너 지원
          + FreeBSD는 runj, ocirun 같은 도구로 컨테이너 격리 제공
          + CNI 플러그인을 통해 네트워크 관리 가능 – Podman 및 containerd와 호환 가능
     * asynts
          + DragonflyBSD에서 개발 경험이 매우 나빴음 – 빌드 시스템이 불안정하고 느림
          + 다시 BSD 시스템을 사용할 생각이 없음
     * johnklos
          + NetBSD의 빌드 시스템은 매우 간단하고 사용하기 쉬움
          + 한 줄 명령어로 커널 빌드 가능
     * posix_cowboy
          + pf(패킷 필터)가 BSD를 선택해야 하는 이유 중 하나
          + 텍스트 파일에서 허용/차단 목록을 쉽게 로드 가능
     * meerm
          + DragonflyBSD에서 좋은 경험을 했음 – 사용해 볼 기회가 있다면 추천

   그래도 생태계로썬 리눅스가 우위일텐데..
"
"https://news.hada.io/topic?id=19907","Landrun - root나 컨테이너 없이 Landlock으로 모든 리눅스 프로세스 샌드박싱","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Landrun - root나 컨테이너 없이 Landlock으로 모든 리눅스 프로세스 샌드박싱

     * Landlock LSM을 사용해 리눅스 프로세스를 안전하게 실행하는 경량 샌드박스
     * Firejail과 비슷하지만 커널 레벨 보안 및 최소한의 오버헤드를 제공
     * 커널 레벨 보안: Landlock LSM을 통해 프로세스 자체가 보안 정책을 설정하고 실행 환경을 제어함
     * 불필요한 오버헤드를 최소화해 성능 저하 없이 경량으로 빠른 실행
     * 읽기/쓰기/실행 등 세밀한 파일 및 디렉토리 권한 설정 가능
     * TCP 포트 바인딩 및 연결 제한 가능
     * Best-Effort 모드 지원 : 커널 버전에 따라 사용 가능한 보안 정책을 유연하게 적용해 호환성 제공

요구사항

     * Linux 커널 5.13 이상에서 Landlock LSM 활성화 필요
     * Linux 커널 6.8 이상에서 네트워크 제한 사용 가능 (TCP 바인딩 및 연결)
     * Go 1.18 이상 (소스에서 빌드 시 필요)

제한 사항

     * Landlock는 커널에서 지원되어야 함
     * 네트워크 제한은 Linux 커널 6.8 이상 및 Landlock ABI v5 필요
     * 일부 작업은 추가 권한 필요
     * 샌드박스 적용 전 열린 파일이나 디렉토리는 Landlock 제한 적용되지 않음

   Linux Landlock is a kernel-native security module that lets unprivileged processes sandbox themselves - but nobody uses it because the API is ... hard!

   Landlock 은 처음들어봤는데 흥미롭네요
"
"https://news.hada.io/topic?id=19854","MrBeast는 유튜브 보다 초콜릿으로 돈을 더 많이 번다","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    MrBeast는 유튜브 보다 초콜릿으로 돈을 더 많이 번다

     * MrBeast는 구독자 3.75억명으로 세계에서 가장 유명한 유튜버지만, 주요 수익원은 유튜브가 아닌 초콜릿 사업임
     * Feastables(초콜릿 회사)의 지분을 대부분 소유하고 있으며, 2024년에 약 3630억원($250m)의 매출과 290억원($20m) 이상의 순이익을 기록함
     * 같은 기간 동안 MrBeast의 미디어 사업(유튜브 및 Prime Video 리얼리티 쇼)은 비슷한 매출을 올렸지만 약 116억원($80m)의 손실 발생
     * 그의 회사 Beast Industries는 유튜브 외에도 다양한 사업 확장 중
          + Feastables 외에도 Lunchly(스낵 브랜드)와 Viewstats(콘텐츠 크리에이터 대상 디지털 도구 제공 회사)의 지분 보유
          + 지난 4년 동안 약 4억 5천만 달러의 자금을 조달했고, 추가로 수억 달러를 더 모금할 계획임
          + 신규 자금은 기존 사업 확장 및 비디오 게임, 음료, 웰니스 분야 진출에 사용 예정
     * MrBeast의 스타 파워가 투자 유치에 유리하게 작용
          + 2024년 Alpha Wave가 주도한 시리즈 C 투자에서 Beast Industries의 기업 가치는 약 50억 달러로 평가됨
          + 회사는 최근 3년 연속 적자를 기록했지만, MrBeast의 인지도 덕분에 높은 가치 평가를 받음
               o MrBeast는 전 세계에서 두 번째로 팔로워가 많은 인플루언서(1위는 크리스티아누 호날두)
          + 비슷한 인플루언서 기반 기업으로는 Selena Gomez의 Rare Beauty와 Kim Kardashian의 Skims가 있음
     * MrBeast의 유튜브 성공 비결
          + MrBeast는 11살 때 유튜브에서 게임(Call of Duty, Minecraft) 플레이 영상으로 활동 시작
          + 어떤 콘텐츠가 인기 있는지 연구한 후 대학 중퇴 후 유튜브에 전념
          + 대규모 상금 및 스턴트로 주목받으며 수십억 조회수를 기록하는 인기 크리에이터로 성장
          + 주요 인기 영상 예시:
               o ""Ages 1-100 Fight for $500,000""
               o ""I Spent 50 Hours Buried Alive""
     * Beast Games와 아마존의 대형 계약
          + MrBeast는 제작비 부담을 줄이기 위해 대형 스트리밍 서비스와 협상 진행
               o Amazon이 Beast Games 첫 시즌에 약 1억 달러 투자
               o 촬영 중 MrBeast가 상금 규모를 두 배로 늘리면서 추가 비용 발생 → 첫 시즌에서 수천만 달러 손실 발생
          + Beast Games는 Amazon에서 역대 가장 성공적인 리얼리티 TV 프로그램으로 평가됨
               o Amazon은 두 시즌 추가 제작 계약 체결
     * Beast Industries의 구조 개편 및 비용 절감 전략
          + 2023년 Jeffrey Housenbold(벤처 캐피털리스트)를 사장 겸 COO로 고용
               o CFO, CPO(최고 제품 책임자), 법률 고문 등 고위 경영진 구성
               o 브랜드 파트너십 및 전략 팀 구축
          + 2025년과 2026년에 제작비 절감 계획 → 1억 달러 비용 절감 목표
          + 2026년에는 약 3억 달러의 순이익 예상
     * Feastables의 성장과 전망
          + Feastables는 2021년에 RXbar 전 대표 Jim Murray의 도움으로 설립
          + 초기 포장 실수 등 문제 발생했지만 고객 충성도 유지
          + 현재 Feastables 직원 수는 100명 이상이며, 제품은 유럽, 아프리카, 아시아로 유통 확대
          + Feastables는 향후 몇 년간 매출 3배 성장 예상
     * 미디어 사업은 마케팅 역할로 전환 중
          + 2026년까지 미디어 수익은 전체 매출의 20% 수준으로 축소될 전망
          + Housenbold는 ""미디어는 다른 사업을 위한 마케팅 투자""라고 언급
     * 성공적인 인플루언서 기반 사업 모델 사례
          + Alex Cooper → 음료 브랜드 Unwell 론칭
          + Emma Chamberlain → 커피 사업 성공
          + Logan Paul → 에너지 드링크 Prime 공동 창업 및 Lunchly에서 MrBeast와 협력
     * MrBeast의 도전 과제
          + MrBeast의 초기 햄버거 사업은 법적 분쟁으로 실패
          + 그러나 Feastables와 다른 사업은 성장세 지속
          + MrBeast는 앞으로 다양한 사업 확장을 통해 수익 모델을 다각화하는 것이 목표

   초콜릿 너무 비싸요. 8천원이 말인가요 방구인가요.

   차라리 페레로 로쉐나 사고 말지...

   저는 요즘 Deez Nutz 자주 사먹는데 35g 짜리가 NZD$3 정도네요.
   저는 작은 크기라 남기지 않아서 더 좋더라구요.

   솔직히 초콜릿은 요즘 Milka의 MMMAX 시리즈가 최고인듯 합니다. 안드셔보셨다면 추천!

   그렇다면 전 밀카 버블리를 추천하겠습니다

   굉장히 부드러워요

   저는 토니스 초콜릿바가 좋더라구요 ㅎㅎ

   토니스는 저한테 굉장히 생소한 브랜드군요...

   밀카의 부드럽고 찐한 맛을 좋아하신다면 토니스 밀크초콜릿도 맘에 드실겁니다.

   이게 그 공정무역 초콜릿이었군요
   좋은 의도로 구매하는 거라고 생각했는데 맛까지 좋은 건 처음 알았습니다

   아... 생각만 해도 혈당이 오르는거 같습니다. ㅠㅠ
"
"https://news.hada.io/topic?id=19864","FOSS 인프라가 AI 회사로부터 공격받고 있음","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       FOSS 인프라가 AI 회사로부터 공격받고 있음

     * Drew DeVault(SourceHut 설립자)이 AI 크롤러가 robots.txt를 무시하고 SourceHut에 심각한 장애 발생시킨다고 경고
     * KDE의 GitLab 인프라도 Alibaba의 IP 범위에서 발생한 AI 크롤러 공격으로 접근 불가 상태 발생
     * AI 크롤러의 문제점
          + AI 크롤러는 robots.txt 요구사항 무시
               o git blame, git log의 모든 페이지 및 커밋 크롤링
               o 무작위 User-Agent 및 수만 개의 IP에서 요청 발생 → 일반 사용자 트래픽처럼 위장
          + 크롤러 차단 어려움 → 우선순위 높은 작업이 수주 또는 수개월 지연
     * 시스템 관리자의 불만
          + AI 크롤러 문제는 개별 사례가 아닌 광범위한 문제
               o 많은 시스템 관리자들이 같은 문제를 경험 중
               o OpenAI, Anthropic은 정확한 User-Agent를 설정하지만, 중국 AI 회사는 그렇지 않음
     * KDE GitLab의 대응
          + MS Edge로 위장한 봇 차단 → 일시적 해결책
          + GNOME은 비로그인 사용자의 머지 요청 및 커밋 확인 속도 제한 적용
          + Anubis 도입 → 브라우저가 문제 풀이를 통해 접근 허용
     * Anubis의 문제점
          + 사용자에게도 영향 발생 → 문제 풀이 시간 필요
               o 채팅방에 링크가 공유되면 과부하 발생 → 1~2분 대기 시간 발생
     * 트래픽의 97%가 봇
          + GNOME에서 2시간 반 동안 81,000건 요청 발생 → 97%가 AI 크롤러
          + 일부 프로젝트는 AI 크롤러 차단 후 트래픽 75% 감소
     * 기타 FOSS 프로젝트의 문제
          + Fedora → 크롤러 차단 위해 브라질 전체 IP 차단
          + Inkscape → 크롤러가 브라우저 정보 위조 → 대규모 IP 차단
          + Frama Software → 46만 개의 IP 차단 리스트 생성
     * AI 크롤러 대응 프로젝트
          + ai.robots.txt → AI 크롤러 차단을 위한 오픈 리스트 제공
               o robots.txt 및 .htaccess 파일 설정 → AI 크롤러 요청 시 오류 페이지 반환
     * 트래픽 분석 결과
          + Diaspora의 경우 트래픽의 70%가 AI 크롤러
               o OpenAI 사용자 에이전트: 25%
               o Amazon: 15%
               o Anthropic: 4.3%
          + Google 및 Bing 크롤러의 트래픽 점유율은 1% 미만
     * AI 생성 버그 리포트 문제
          + Curl 프로젝트에서 AI 생성 버그 리포트 문제 발생
               o 보고된 버그는 대부분 환각(hallucination) 문제
          + CPython, pip, urllib3, Requests → AI 생성 보안 리포트 처리 시간 소모
               o 신뢰성 낮음 → 그러나 확인 필요 → 유지 관리자의 부담 증가

결론

     * AI 크롤러와 AI 생성 버그 리포트는 오픈 소스 커뮤니티에 큰 부담을 줌
     * 오픈 소스 프로젝트는 상업 제품보다 자원이 적고, 커뮤니티 기반이기 때문에 이러한 문제에 더 취약함

        Hacker News 의견

     * 많은 사람들이 대규모 인터넷 인프라를 운영하면서 비슷한 경험을 하고 있음
          + AI 크롤러의 남용에 대한 이야기를 공유하며, 이러한 문제를 한 곳에 모아 정리한 글이 있음
          + 일부 스타트업은 문제를 해결하고 비용을 환불해 주었으나, Facebook은 이메일에 답하지 않음
     * Fastly는 FOSS 프로젝트에 무료 보안 서비스를 제공하고 있음
          + 최근 AI 스크래핑에 대한 요청이 증가하고 있음
     * 자신의 프로젝트가 미리보기 이미지에 등장한 것이 놀라움
          + 프로젝트를 xeiaso.net에 배포하여 실제 환경에서의 작동을 확인하고 있음
     * FOSS 인프라뿐만 아니라 익명 인터넷 접근 자체가 위협받고 있음
          + 새로운 봇들이 캡차를 풀고 실제 사용자처럼 행동할 수 있음
          + 사이트들이 신용카드나 Worldcoin 같은 인증을 요구할 가능성이 있음
     * 최근 Forgejo 인스턴스가 공격받았음
          + 디스크가 생성된 zip 파일로 가득 찼고, Alibaba Cloud의 IP 범위를 차단하여 공격이 줄어듦
          + DISABLE_DOWNLOAD_SOURCE_ARCHIVES 설정을 true로 변경할 것을 권장함
     * 과거 검색 엔진 문제를 해결하기 위해 robots.txt가 만들어졌으나, 현재 새로운 인덱서들은 이를 무시하고 있음
          + 법적 제재가 필요하다고 주장함
     * Google과 광고의 웹 지배력이 약화될 것임
          + 캡차로 인해 검색 엔진이 사이트를 인덱싱하지 못하게 되고, 이는 검색 엔진의 가치를 떨어뜨릴 것임
     * LLaMa를 사용하여 모순된 게시물을 생성하여 정보의 혼란을 유도함
     * VideoLAN도 AI 회사의 봇으로 인해 포럼과 Gitlab이 공격받고 있음
          + 대부분의 봇이 robots.txt를 무시함
     * 검색 엔진에 인덱싱되지 않는 웹이 생길 가능성이 있음
          + LLM 스크래핑에 대한 해결책으로 작업 증명을 요구하는 방법이 제안됨
"
"https://news.hada.io/topic?id=19861","2025년에 어떤 AI 모델을 선택해야 할까?","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       2025년에 어떤 AI 모델을 선택해야 할까?

     * ChatGPT, Claude, Gemini, Grok, Perplexity, DeepSeek 중에 어떤 걸 선택해야 할까?
     * 모델별로 적합한 경우와 적합하지 않은 경우를 여러개의 분야로 정리
     * 최종적으로 $20가 있다면 Claude를, 추가로 $20이 더있다면 ChatGPT를 추천

ChatGPT: 만능 AI 도구

     * ChatGPT가 적합한 경우
          + 일상적인 질문 응답
               o 매일 다양한 질문에 답변 제공
               o 예: 집 창문 교체 견적 비교 요청 → 상세 분석 제공
          + 음성 대화
               o 산책이나 출퇴근 중 음성 대화 가능
               o 프로 팁: ""내가 끝났다고 말할 때까지 응답하지 마세요""라고 설정 가능
          + 카메라 비전 및 음성 지원
               o 카메라를 활성화하면 실시간으로 보고 있는 것을 인식
          + 수학 및 재무 분석
               o 세금 준비, RSU 계획 등에서 우수한 성능 발휘
          + 시장 및 기술 주제에 대한 심층 조사
               o 심층 연구 기능이 Grok, Perplexity, Gemini보다 뛰어남
     * ChatGPT가 적합하지 않은 경우
          + 글 편집 및 코딩
               o 작성된 글의 수정이 기계적으로 느껴짐
               o AI 코딩 도구로는 다른 모델이 더 우수함

Claude: 글쓰기 및 코딩에 최적화된 모델

     * Claude가 적합한 경우
          + 글 편집
               o 사용자의 스타일에 빠르게 적응
               o 음성 메모에서 초안 작성 → 시간 절약
          + 코딩(Vibe Coding)
               o Bolt 및 Cursor 같은 AI 코딩 도구에서 Claude 3.7 Sonnet 사용
               o 게임 코딩에서 훌륭한 성능 발휘
                    # 예: 비행 시뮬레이터, 스타워즈 데스스타 런, 좀비 슈팅 게임
     * Claude가 적합하지 않은 경우
          + 멀티모달 기능 부족
               o 이미지, 음성, 비디오 생성 기능이 없음
               o 하지만 새로운 확장 사고 모드는 OpenAI의 추론 모델과 유사함

Gemini: 장문의 문맥 처리 및 비디오 생성에 강함

     * Gemini가 적합한 경우
          + Veo를 사용한 비디오 제작
               o OpenAI의 Sora보다 우수한 성능 제공
          + Imagen 3를 사용한 이미지 생성
               o DALL-E 및 Midjourney보다 더 일관된 결과 제공
          + 대규모 문서 및 긴 비디오 처리
               o 200만 단어 이상의 컨텍스트 처리 가능
     * Gemini가 적합하지 않은 경우
          + 성격 및 자연스러움 부족
               o 답변이 너무 간결하고 기계적
               o 글 편집 및 코딩 성능이 ChatGPT나 Claude보다 떨어짐

Grok: 최고의 무료 AI 모델

     * Grok이 적합한 경우
          + 무료 심층 연구, 추론, 이미지 생성 및 코딩
               o DeepSearch 및 Think 기능에서 강력한 성능 발휘
               o Sonnet 3.7 수준의 코딩 성능 제공
          + X(Twitter)에서 실시간 정보 검색
          + 독특한 음성 모드
               o 개성 있는 음성 모드 제공 → 독특하고 재미있는 경험
     * Grok이 적합하지 않은 경우
          + 글 편집 성능이 부족
               o 답변이 종종 비꼬거나 과도하게 유머러스함

Perplexity: 빠른 검색 및 여행 계획에 최적

     * Perplexity가 적합한 경우
          + 빠른 정보 검색
               o 명확하고 간결한 요약 및 출처 링크 제공
          + 여행 계획 및 현지 활동 추천
               o 일본 여행 일정 계획에 유용했음
     * Perplexity가 적합하지 않은 경우
          + 심층 연구
               o ChatGPT 및 Grok의 연구 범위가 더 광범위함

DeepSeek: 재미를 위한 AI 모델

     * DeepSeek이 적합한 경우
          + 체인 오브 싱킹(chain of thinking) 출력을 통해 흥미로운 결과 제공
          + 가족이나 친구와 함께 즐기기 좋음

어떤 모델에 돈을 써야 할까?

    1. $20만 있다면 Claude에 투자
          + 글 편집 및 코딩이 주된 사용 사례(80%) → 효율적인 작업 처리
    2. 추가로 $20이 있다면 ChatGPT에 투자
          + 음성 모드, 추론, 심층 연구 기능이 강력함

   claud, chatgpt 가 grok 보다 $20 가치를 더 주지는 못해서
   그냥 grok 씁니다.

   grok 무료는 정말 인상적입니다.
   일 할때는 claude 쓰고 그 외에 잡다한 건 grok으로 사용하네요.

   Good
"
"https://news.hada.io/topic?id=19944","내가 TypeScript를 팔아먹는 방법(Sales Pitch)","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  내가 TypeScript를 팔아먹는 방법(Sales Pitch)

     * TypeScript는 JavaScript에 타입 정보를 추가한 언어임
          + JS 엔진에 의해 실행되기 전에 타입 정보가 제거됨 → 즉, 작성 및 배포 과정에서 추가 작업 필요
          + 그 추가 작업이 가치가 있는가? → 충분히 가치 있음

자동 완성 및 코드 편집 중 오류 감지

     * TypeScript는 코드 작성 시 자동 완성과 오류 감지 제공
     * 예시 1: 오타, 잘못된 타입, 인수 누락
          + 존재하지 않는 속성에 접근 시 오류 표시. 자동 완성에서 안보임
          + 잘못된 타입의 메서드 호출 시 오류 표시
          + 필수 인수가 누락된 경우 오류 표시
          + 잘못된 타입의 인수를 전달한 경우 오류 표시
     * 예시 2: 함수 반환값 오류
          + 반환값이 정의된 타입과 일치하지 않으면 오류 표시
          + 예를 들어, 반환값이 string[]인데 반환 타입이 string으로 정의된 경우 오류 발생
     * 예시 3: 선택적 속성 처리 오류
          + 선택적 속성을 반환 값으로 사용할 경우 타입이 일치하지 않으면 오류 표시
     * 예시 4: switch 문에서 case 누락
          + switch 문의 모든 case가 처리되지 않으면 오류 발생
          + 남은 값이 never 타입이어야 한다는 요구사항 위반 시 오류 발생
     * 예시 5: 코드에서 특정 경우 처리 오류
          + 특정 값에 따라 분기 처리 시 잘못된 경우 오류 발생
          + 예를 들어, 특정 객체 타입에 존재하지 않는 속성 접근 시 오류 발생

함수 매개변수 및 반환 타입 명시 → 좋은 문서화 역할

     * TypeScript는 함수의 매개변수 및 반환 타입을 명시할 수 있음
     * 코드 이해도 및 유지 보수성 향상
     * 함수의 인자와 반환값이 어떤 타입인지 명확하게 드러남

코드 리팩토링 강화

     * TypeScript는 코드 리팩토링을 더 안전하게 수행하도록 도와줌
     * 메서드 이름 변경 시 모든 연결된 코드에서 안전하게 반영됨
     * 코드의 연결 관계를 정확하게 파악할 수 있음

TypeScript 사용은 더 쉬워짐

     * TypeScript 실행 및 컴파일이 쉬워짐
     * Node.js, Deno, Bun 같은 플랫폼에서 직접 TypeScript 실행 가능
     * Vite 같은 번들러는 TypeScript를 기본 지원
     * 타입 제거(type stripping) 기법 도입 → 타입 정보만 제거하고 다른 변환 없음
     * npm 패키지 배포 개선됨 → JavaScript 및 타입 선언 파일 자동 생성 지원

TypeScript의 단점

     * 학습 곡선 존재 → JavaScript보다 복잡함
     * 일부 npm 패키지에서 타입 정의가 없거나 잘못된 경우 문제 발생 가능
     * tsconfig.json 설정이 복잡할 수 있음
          + 최대한 엄격한 설정으로 설정하면 문제 완화 가능
          + 타입 제거가 명확해지면서 tsconfig.json의 역할이 단순화됨

TypeScript FAQ

  TypeScript 코드가 무겁지 않은가?

     * TypeScript는 타입 추론을 통해 최소한의 타입 정의로도 코드 작성 가능
     * 복잡한 타입 주석 없이도 유용하게 작동 가능

  TypeScript가 JavaScript를 C# 또는 Java로 바꾸려는가?

     * 초기에는 JavaScript의 부족한 기능을 보완하기 위해 클래스, 모듈, 열거형 등 추가
     * 현재는 ECMAScript 표준에 맞춰 TypeScript를 개선하고 있음
     * JavaScript에 없는 기능은 TypeScript에 추가되지 않음

  TypeScript가 객체 지향 프로그래밍(OOP)만 지원하는가?

     * TypeScript는 함수형 프로그래밍 패턴도 잘 지원함
     * 예를 들어, discriminated union은 함수형 프로그래밍에서 자주 사용됨

  복잡한 타입 정의는 꼭 배워야 하는가?

     * 대부분의 TypeScript 사용은 간단한 타입 정의로 충분함
     * 복잡한 타입 정의는 라이브러리 작성 시 유용하지만 일반적인 사용에서는 필요 없음

  TypeScript 학습에 얼마나 걸리는가?

     * 기본 개념은 하루 만에 학습 가능
     * 간단한 코드 작성 및 디버깅은 다음 날부터 가능
     * 점진적으로 복잡한 타입 및 고급 기능 학습 가능

다음에 읽을 자료

     * What is TypeScript?
     * Tackling TypeScript (무료)

   강타입 주는 이점이 있어요 c++에서도 마찬가지

   자바스크립트->타입스크립트 쓰면 눈 감고 개발하다가 눈 뜬 느낌. 타입이 주는 안정감과 자동완성, 코파일럿과의 조합

   우리회사 팀들 자바스크립트로 충분하다 하면서 프로젝트했다가 지금 타입스크립트로 모두 전환중입니다

   자바스크립트를 대체하는 것이 아닌 보완하는 것, 이 것이 타입스크립트가 Dart를 이긴 성공 요인인 것 같습니다. 정말 배우길 잘했다는 생각이 듭니다.
"
"https://news.hada.io/topic?id=19915","Code With LLM - AI 지원 개발 도구들 모음","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Code With LLM - AI 지원 개발 도구들 모음

     * AI 지원 IDE : 개발 도구 이름, 간단한 설명, 변경 로그, 가격, 관련 포럼 링크
          + Cursor, Windsurf, PearAI, Copilot, Trae, Fleet, Zed,...
     * IDE용 확장들 : Cline, RooCode, Zencoder, Junie, Twinny,...
     * CLI 도구들 : Aider Chat, Kwaak, CodeBuff, Claude Code,...
     * Web AI 생성기 : v0, Base44, Bolt, Lovable, Replit, Builder.io,...
     * 향상된 AI 개발 도구들:
          + AI Developer : Devin, OpenHands, databutton
          + Frontend 생성기 :Magic Pattern, Tempolabs
          + 헤드리스 IDE : SWE-Kit, hide
          + 코드 보안 : Snyk, Diamond, Sonar
          + 프롬프트 모음 : Repo Prompt, Repomix, ContextForge,...
"
"https://news.hada.io/topic?id=19950","DeepSeek, v3 최신 모델 공개하면서 MIT로 라이센스 변경","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 DeepSeek, v3 최신 모델 공개하면서 MIT로 라이센스 변경

     * DeepSeek-V3-0324 모델이 새로 릴리즈. Readme는 비어있음
     * 이전 모델까지는 자체 커스텀 라이센스 였던 것에 반해 MIT 라이센스로 변경됨
     * Aider Polyglot 벤치마크에서 55%로 이전보다 상당히 향상됨
          + Claude 3.7 Sonnet에 이어 2위의 비사고/추론 모델
          + R1 및 o3-mini 같은 사고 모델과 경쟁함
"
"https://news.hada.io/topic?id=19912","나는 좋은 병렬 컴퓨터를 원해요","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           나는 좋은 병렬 컴퓨터를 원해요

     * GPU는 CPU보다 10~100배 더 강력하지만, 동적 작업 처리에 어려움이 있고 병렬 프로그래밍 도구가 부족해 일반 작업에서 성능을 충분히 활용하지 못하고 있음
     * 과거에 Connection Machine, Cell, Larrabee 같은 병렬 컴퓨터 디자인이 있었지만 프로그래밍 모델의 복잡성 등으로 실패함
     * 현대 GPU는 메모리 관리 문제와 복잡한 실행 모델 때문에 성능 최적화가 어렵고, 큐 기반의 효율적인 데이터 전달 구조가 필요함
     * AI 가속기와 병렬 코어 집합 같은 새로운 아키텍처가 GPU의 한계를 극복할 가능성이 있음
     * 병렬 컴퓨터의 발전은 아직 미완성 상태이며, 단순하고 효율적인 실행 모델과 프로그래밍 도구의 개선이 필요함

GPU의 강력한 성능과 한계

     * GPU는 CPU보다 약 10~100배 더 강력함 (작업 종류에 따라 다름)
     * 실시간 그래픽 렌더링 및 머신러닝에서는 이 성능이 잘 활용되고 있음
     * 그러나 GPU 성능이 일반적인 작업에서 충분히 활용되지 못하고 있음

GPU의 한계 원인

     * 빈약한 실행 모델
          + GPU는 예측 가능한 대규모 데이터(예: 밀집 행렬 곱셈)에 강하지만 동적 작업에서는 성능이 떨어짐
     * 부족한 언어 및 도구
          + 병렬 컴퓨터 프로그래밍 자체가 매우 어려움

복잡성의 증가

     * 최신 GPU는 복잡성이 빠르게 증가하고 있음
     * 메시 셰이더(mesh shaders), 워크 그래프(work graphs) 등의 새로운 기능이 도입되었지만 일부 기본 작업은 여전히 지원되지 않음

복잡한 GPU 메모리 효율 문제

     * 필자는 Vello라는 고급 2D 벡터 그래픽 렌더러를 개발 중
          + CPU가 장면 설명(SVG 형식) 업로드 → 컴퓨트 셰이더가 처리 후 이미지 생성
     * 문제점: 메모리 관리의 어려움
          + 중간 결과 저장을 위한 버퍼 크기 예측이 어려움
          + 버퍼 초과 시 GPU에서 CPU로 읽기 작업이 성능 저하를 초래함

해결책 제안

     * GPU 내부에서 큐(queue) 를 통해 결과를 전달하도록 개선
          + 2009년 GRAMPS 논문에서 제안된 모델
          + Brook 프로젝트에서도 비슷한 접근 시도

과거의 병렬 컴퓨터 디자인

     * Connection Machine (1985)
          + 64k 프로세서가 하이퍼큐브 네트워크로 연결된 병렬 컴퓨터
          + 각각의 프로세서는 성능이 낮았지만 대규모 병렬 작업이 가능
          + 병렬 알고리즘 연구에 큰 기여
     * Cell (2006, PS3)
          + PS3에 포함된 병렬 컴퓨터 (약 87.4백만 대 출하)
          + 8개의 병렬 코어가 독립적으로 연산 수행 가능
          + 프로그래밍 모델의 복잡성이 실패 원인
     * Larrabee (2008)
          + x86 기반 병렬 컴퓨터로 개발됨
          + 실패 이유: 전력 소비 및 소프트웨어 지원 부족
          + 이후 Xeon Phi 및 AVX-512 명령어로 이어짐

변화하는 작업 부하

     * 게임에서도 연산 작업 비중이 증가
          + Starfield의 경우 총 작업 시간의 약 **50%**가 연산
          + Nanite 렌더러는 작은 삼각형의 래스터화도 연산으로 처리

앞으로의 발전 방향

     * 1. 코어 집합 확장 (Cell 부활)
          + 현대의 고급 CPU는 1000억 개 이상의 트랜지스터 포함
          + 저전력의 단순한 RISC 코어를 수백~수천 개 포함한 칩 제작 가능
          + AI 가속기는 이미 유사한 아키텍처 채택 중
     * 2. GPU에서 Vulkan 명령 실행
          + GPU에서 직접 Vulkan 명령 실행 가능하도록 지원
          + 현재 일부 Vulkan 확장에서 제한적으로 구현됨
     * 3. 워크 그래프(Work Graph)
          + 프로그램을 노드(커널)와 엣지(큐)로 구성
          + 병렬로 실행되나 다음과 같은 제한 사항 존재
               o 조인(join) 작업이 어려움
               o 요소의 정렬 순서 보장 안됨
               o 가변 크기 요소 지원 안됨
     * 4. CPU와의 융합 진화
          + 고성능 CPU 디자인이 병렬 처리에 최적화될 가능성
          + 병렬 연산 및 SIMD(단일 명령 다중 데이터) 처리 성능 개선 중
     * 5. 하드웨어는 이미 준비되어 있을 가능성
          + 일부 GPU에는 사용자 코드 실행 가능한 명령 프로세서 포함
          + 명령 프로세서가 완전히 개방되면 성능 개선 가능성 존재

복잡성 문제

     * GPU 아키텍처는 지나치게 복잡함
          + 병렬 컴퓨터 + 특수 하드웨어 + 명령 처리 구조가 혼재
          + 다양한 API와 드라이버 호환성 문제
     * 반면, CPU는 단순한 명령 집합 기반에서 성능 향상 지속

결론

     * 병렬 컴퓨터의 발전은 아직 미완성 상태
     * GPU가 그래픽 및 AI 작업 외에도 일반 작업에 최적화되기 위해 다음이 필요함
          + 단순한 실행 모델
          + 프로그래밍 용이성
          + 낮은 전력 소비
     * Vello 같은 고급 2D 렌더러 작업에서 병렬 컴퓨터의 성능을 온전히 활용 가능할 것
     * GPU의 성능 한계를 극복할 새로운 병렬 컴퓨터 아키텍처가 필요함

        Hacker News 의견

     * ""두 가지 주요 요인이 이를 방해한다고 믿음""
          + 의견을 과학적으로 포장하는 것에 지침
          + Cell 프로세서 작업 경험에서 많은 미세 관리가 필요했음
          + 현대 시스템은 메모리 보호, 격리, 안정성을 고려하여 설계됨
          + Amiga에서 코드를 작성하게 하면 새로운 감사가 생길 것임
     * 프로그래밍 모델이 2025년에는 비효율적임
          + 런타임에 셰이더 소스/바이트코드를 컴파일해야 함
          + NUMA/디스크리트에서 CPU와 GPU 간의 데이터 구조 조작이 어려움
          + CPU-GPU 및 GPU 작업 간의 데이터 접근 동기화 필요
          + 표준화되지 않은 하드웨어로 인해 혼란스러운 API 처리 필요
          + 다양한 구성의 조합 처리 필요
     * ""수백 개의 작은 CPU를 단일 칩에 넣은"" 회사에서 일한 경험
          + 프로그래밍 모델이 너무 이상해서 실패할 것임
          + 차세대는 새로운 아키텍처가 아닌 추가 기능이 있는 GPU일 것임
     * GPU가 CPU보다 10~100배 더 강력함
          + 많은 작업이 더 많은 성능을 필요로 하지 않음
          + GUI는 20년 이상 사용자 입력에 반응적이었음
          + GPU 프로그래밍을 단순화해야 함
     * M4 Mac mini 슈퍼컴퓨터 구축에 대한 의견
          + Apple M3 Ultra GPU 및 Neural Engine 명령어 집합 역공학
          + 50조 이상의 연산을 초당 수행할 수 있음
     * 병렬 컴퓨터의 문제점
          + 많은 사람들이 개발 목적으로 장치를 채택해야 함
          + CPU에서 GPU로 코드를 포팅하는 것은 큰 작업임
          + AMD와 다른 회사들이 GPU를 CPU에 더 가깝게 이동시키는 아이디어 탐구
     * 2D 렌더러에 GPU가 필요한 이유가 명확하지 않음
          + 3D 렌더러는 도움이 필요함
          + Vulkan은 렌더러 아래의 레벨임
          + Rust 3D에서 렌더러 설계의 마찰점 존재
     * Larabee에 대한 언급이 많지만 Xeon Phis에 대한 언급이 없음
          + CPU 설계가 단일 코어 성능과 전력 효율성을 최적화하는 방향으로 나뉘고 있음
          + E 코어가 더 많아지면 병렬성을 활용하는 알고리즘이 승리할 수 있음
     * GPU의 높은 처리량을 가능하게 하는 희생
          + Apple Silicon의 통합 메모리 시스템이 있음
          + GPU 프로그래밍 API가 메모리가 통합되지 않은 것처럼 다루게 함
"
"https://news.hada.io/topic?id=19968","Polypane - 야심찬 웹 개발자를 위한 브라우저","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Polypane - 야심찬 웹 개발자를 위한 브라우저

     * 반응형 디자인, 접근성, 성능 테스트 등 웹사이트 개발과 디버깅, 테스트를 위한 기능이 통합된 데스크탑 브라우저(크로미움 기반)
     * 모든 작업이 실시간으로 동기화되며, 다양한 사이즈의 뷰포트를 동시에 확인하고 조작 가능
          + 클릭, 입력, 스크롤, hover 등 모든 동작이 모든 뷰포트에 즉시 반영됨
     * Mac, Windows, Linux에서 사용 가능하며, 14일 무료 체험 가능

핵심 기능 요약

     * 반응형 디자인
          + 모바일부터 5K 모니터까지 모든 뷰포트를 한눈에 확인 가능
          + 브라우저 크기를 수동으로 조절하지 않고도 CSS 브레이크포인트 테스트 가능
     * 실시간 분석 및 동기화
          + 스크롤, 클릭, 입력, hover까지 모든 동작이 모든 뷰포트에 실시간으로 동기화됨
          + 콘솔 및 요소 검사기까지 통합되어 반복 작업을 줄일 수 있음
     * 접근성과 성능 검사
          + 구조, 메타데이터, 접근성(A11y)을 실시간으로 점검하고 개선 사항 제시
          + 40개 이상의 디버그 도구 탑재로 다양한 방식의 테스트 가능
     * 다크 모드 및 다양한 미디어 테스트
          + 운영 체제 설정을 바꾸지 않고 다크/라이트 모드를 동시에 테스트 가능
          + 모션 축소, 데이터 절약 모드, 프린트 스타일 등 다양한 미디어 조건 시뮬레이션
     * 소셜 미디어 카드 미리보기
          + Twitter(X), Facebook, Slack, LinkedIn, Discord 등 주요 플랫폼의 메타 카드 미리보기 지원
          + 라이트/다크 모드 및 로컬호스트 상태에서도 픽셀 단위로 정확한 프리뷰 제공
     * 개발자 도구 확장 지원
          + React, Vue, Angular, Svelte, Redux 등 다양한 DevTools 확장 프로그램 사용 가능
          + Chromium 기반 브라우저이므로 친숙한 개발 환경 제공

Polypane만의 장점

     * 단일 브라우저로 다양한 디바이스와 환경 테스트 가능
     * 개발 및 디자인 워크플로우 속도 최대 5배 향상
     * 다기능 디버깅 도구, 접근성 검사, 뷰포트 동기화, 스크린샷, 실시간 리로딩 등 올인원 구성
     * 사용자 피드백 기반으로 발전하며, 100% 사용자 중심 자가 펀딩 프로젝트임

기타 주요 기능 목록

     * 무제한 뷰포트 생성
     * 키보드, hover, 스크롤 동기화
     * 그리드 오버레이
     * JSON 뷰어 및 다양한 디바이스 프리셋
     * 수평 오버플로우 탐지
     * 시각적 디자인 비교(diff)
     * 색약 시뮬레이션
     * 메타데이터 개요
     * 웹 바이탈 검사기
     * 터치 에뮬레이션
     * 깨진 링크 탐지
     * 커스텀 헤더 설정
     * 워크스페이스 저장 및 공유 기능

제작자의 한마디

     * 개발자인 Kilian Valkhof이 수많은 웹사이트를 만들며 겪은 불편을 해결하고자 시작한 프로젝트임
     * Chrome만 사용했을 때보다 작업 속도가 약 60% 향상되었으며, 사용자들 또한 2~5배 향상된 생산성을 체감함
     * 투자 없이 사용자들의 피드백과 구독으로 운영되는 프로젝트로, 개발자 중심의 도구 개발에 집중함

사용자 리뷰 요약

     * Vivian Guillen: “엄청 빠르고 스크롤 동기화가 환상적임”
     * Scott Tolinski: “브레이크포인트 간의 여백 문제를 쉽게 발견함”
     * Sara Soueidan: “디버깅 도구들이 너무 훌륭해서 감탄함”
     * Kevin Powell: “접근성 검사와 디버깅 기능이 탁월함”
     * Segun Adebayo (Chakra UI 개발자): “모던 앱과 사이트 개발에 꼭 필요한 도구임”

   https://responsiveviewer.org/
   크롬 확장으로 배포되는 친구도 있습니다. 일부 기능을 포기한다면 확장 없이 바로 사용도 가능해요.

   기능은 조금 부족하지만 유사한 브라우저가 있습니다.
   https://responsively.app/
   혹시나 polypane이 유료라서 망설이시는 분은 한번 사용해보시는걸 추천합니다.

        Hacker News 의견

     * 안녕하세요, 저는 Polypane의 창시자이자 단독 개발자인 Kilian입니다. 다시 홈페이지에 올라온 것을 보니 흥미로움
     * 최근에 현대 CSS 반응형 웹 디자인을 처음 구현하면서 flexbox와 grid를 배우고 여러 브라우저와 디바이스 에뮬레이터를 사용했음. 이 앱을 알았더라면 많은 수고를 덜었을 것 같음
     * Polypane을 많이 사용했음. 훌륭한 제품이며, Chrome의 디바이스 뷰가 잘 처리하지 못하는 미묘한 디바이스 문제를 잘 에뮬레이트함
     * Polypane을 1년 넘게 사용 중이며, 모든 사람에게 맞지는 않을 수 있지만 내 필요에는 잘 맞음
          + 세션 관리로 워크플로우가 잘 정리됨
          + 데스크톱과 모바일 뷰를 위한 패널을 갖춘 반응형 우선 디자인
          + 주석을 포함한 포괄적인 스크린샷 기능
          + 다른 브라우저나 플러그인으로 이러한 기능을 복제할 수 있지만, 모든 것이 기본적으로 설정되어 있어 추가 설정이 필요 없음을 선호함
          + 지원이 뛰어남. IDE가 Polypane을 제대로 실행하지 못하는 문제를 겪었을 때 Slack에서 도움을 받아 빠르게 해결함
          + Slack 대화를 읽어보면, 사용자를 위한 최고의 제품을 만들기 위해 헌신하고 있음이 분명함
     * 모바일 디바이스의 브라우저를 정확히 에뮬레이트할 수 있는 브라우저가 있었으면 좋겠음. 화면 크기만 변경하는 것이 아니라, Apple의 iOS 시뮬레이터조차도 이 부분에서 실패함
     * 많은 것을 에뮬레이트하는 것 같지만, 잘 에뮬레이트하지 못하는 것은 무엇인지 궁금함
          + Chromium 기반으로 만들어진 것 같아 Safari나 Mozilla에서만 나타나는 문제를 보여주지 못할 것 같음
          + 아마도 문서에 있을 것임
          + 수정: FAQ 하단에 있음. 실제 브라우저 엔진 외에 다른 알려진 제한 사항이 있는지 궁금함
     * 거의 모든 기능이 이미 Firefox 개발자 도구에 내장되어 있음. 새로운 브라우저가 필요한 이유가 무엇인지 궁금함. 확장 프로그램으로도 가능할 것 같음
     * Browserstack보다 제공하는 몇 가지 기능은 무엇인지 궁금함 (크로스 브라우저 테스트 관련)
     * GenAI 통합을 제공하는지 궁금함 (Copilot, Claude 등)
          + 매니저에게 이 제품을 판매하는 데 도움을 주고 싶음
     * 가격 모델이 일회성 구매를 제공했으면 좋겠음. 훌륭해 보이지만 월간/연간 비용을 정당화하기 어려울 것 같음
     * 정말 멋짐! 학생 할인을 받을 수 있는 가능성이 있는지 궁금함. 일단 무료 체험을 시도해 볼 예정임

   묘하게 언급을 찾기 어렵게 되어 있는데, GitHub 학생 계정을 연동하면 무료 이용 가능합니다. 덕분에 지난 개인프로젝트에 잘 썼어요.
"
"https://news.hada.io/topic?id=19927","Vibe Coding 매뉴얼: AI 지원 개발을 위한 템플릿 (번역)","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Vibe Coding 매뉴얼: AI 지원 개발을 위한 템플릿 (번역)

     * Vibe Coding은 인간이 AI 모델과 협업해 효율적으로 프로젝트를 구축하는 소프트웨어 개발 방식
     * 세 가지 핵심 기둥으로 구성됨:
          + 명세(Specification): 목표 정의 (예: “로그인 기능이 있는 Twitter 클론 구축”)
          + 규칙(Rules): 명시적인 제약 설정 (예: “Python 사용, 복잡성 피하기”)
          + 감독(Oversight): 프로세스를 모니터링하고 일관성 보장
     * 이 매뉴얼은 모든 수준의 개발자를 위한 종합적인 프레임워크를 제공
          + .cursor/rules , .windsurfrules에 가진 네 개의 파일(또는 섹션)을 구성
     * 핵심규칙
          + 1. 코딩 선호도 – “이렇게 코드를 작성하세요” : 코드 스타일 및 품질 표준을 정의
          + 2. 기술 스택 – “이런 도구를 사용하세요” : 도구 및 기술을 명시
          + 3. 워크플로우 선호도 – “이렇게 작업하세요” : AI의 프로세스 및 실행을 관리
          + 4. 커뮤니케이션 선호도 – “이렇게 대화하세요” : AI-인간 상호작용에 대한 기대치를 설정
     * 고급규칙 - 복잡한 프로젝트를 위한 확장
     * 실용적인 예: 어떻게 작동하는가
     * 고급 팁: 프레임워크 최대화

   Vibe coding이 밈이 아니라 새로운 개발 방법론이었군요

   AI로 인해서 세상이 많이 바뀌긴 했나 봐요. 바이브 코딩이 제시하는 그림에 100% 동의하진 않지만,
   점점 더 작은 인원으로 더 빠르게 새로운 시도를 해볼 수 있는 세상이 오는구나 하는 걸 체감하고 있습니다.

   Vibe Coding에서 프로세스를 모니터링하고 감독하는 개념은 어울리지 않는 듯 싶어요.
   원래의 바이브 코딩은 AI에게 말로만 설명할 뿐이지, Efficient Coding with LLM의 개념은 아닌 걸로 알거든요. Capathy가 이야기 한 바이브와는 전혀 분위기가 다른 얘기 같습니다. 제 생각엔 저건 그냥 로우 코딩 with LLM 같아요.
"
"https://news.hada.io/topic?id=19857","날이 빨리 길어지고 있음","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             날이 빨리 길어지고 있음

     * 북반구에서는 춘분이 지나고 날이 빠르게 길어지고 있음. 노르웨이의 스타방에르에 사는 동료의 창문 배경이 어두웠다가 밝아지는 것을 보고, 날이 얼마나 빨리 길어지는지 궁금해졌음. 이를 알아보기 위해 위도에 따른 하루 길이 변화를 보여주는 인터랙티브 그래프를 만들었음.

  수학적 배경

    태양이 떠 있는 시간

     * 특정 날짜에 태양이 떠 있는 시간을 계산하기 위해 시간각(hour angle)을 사용함. 시간각은 천체가 자오선과 이루는 각도로, 이를 시간 단위로 변환하여 천체가 자오선을 통과하는 시간을 알 수 있음. 일출부터 일몰까지의 시간은 이 시간의 두 배임.
     * 태양의 시간각을 계산하기 위해 관측자의 위도와 태양의 적위(천구 적도 위의 태양 각도)를 알아야 함. 이를 통해 태양의 일출 시간각을 구할 수 있음.

    지구 전역의 일조 시간

     * 적도에서는 매일 12시간의 일조 시간이 있음. 춘분과 추분에는 위도에 상관없이 하루가 정확히 12시간임. 북극권에서는 여름에는 태양이 지지 않음.

  일조 시간의 변화율

     * 일조 시간의 변화율을 계산하기 위해 미분을 사용함. 일조 시간의 변화는 위도와 춘분 이후의 일수에 따라 달라짐.

  복잡성

    대기 굴절과 태양의 크기

     * 태양이 지평선에 있을 때가 아니라 태양의 상단이 지평선에 도달할 때가 실제 일출임. 대기 굴절로 인해 태양이 실제보다 높게 보임. 이로 인해 일조 시간이 늘어남.

    이심률과 황도의 경사

     * 태양의 적위를 단순한 사인 함수로 모델링했지만, 지구의 궤도가 타원형이기 때문에 태양의 움직임은 일정하지 않음. 지구의 궤도 이심률을 고려하면 태양의 움직임이 달라짐.
     * 지구의 궤도 이심률이 일조 시간에 미치는 영향은 미미하지만, 근일점에서는 태양이 평균보다 빠르게 움직여 하루가 조금 더 길어짐.

   이러한 방법들을 통해 하루 길이를 계산할 수 있으며, 더 간단하거나 정확한 방법들이 있음. 관련 코드는 Jupyter 노트북에서 확인 가능함.

        Hacker News 의견

     * 작가는 노르웨이의 동료와 함께 스탠드업 미팅에 참석하면서 이 사실을 깨닫고 기사를 작성하게 되었음. 재미있게도, 무슬림인 나는 라마단 기간 동안 매년 이 사실을 상기하게 됨
          + 올해 라마단의 첫날은 3월 1일과 일치했으며, 내 위치(로스앤젤레스 근처)에서는 새벽부터 일몰까지 12시간 45분 동안 금식했음
          + 오늘은 13시간 15분 동안 금식할 예정이며, 3월 말에 마지막 라마단이 다가오면 13시간 37분이 될 것임
          + 라마단은 태양력보다 약 10일 짧은 음력을 따름. 북반구에서는 겨울 라마단이 짧고 쉬우며, 2031년에는 가장 짧은 날이 될 것임. 2047년에는 한여름이 되어 가장 어려울 것임
          + 해가 지지 않는 곳에서는 새벽 전 식사(Suhoor)와 일몰 후 식사(iftar)를 언제 해야 하는지에 대한 의견이 다름. 대개는 기준 위치의 일출과 일몰 시간을 따름. 몇 년 전 스웨덴에 있었던 나의 처남은 메카의 시간을 기준으로 사용했음
     * 저자는 천문학의 역사에 관한 훌륭한 팟캐스트를 가지고 있음
          + ""The Song on Urania""라는 제목의 팟캐스트가 있으며, 2025년까지 휴식 중이지만 충분한 에피소드가 있어 재시작할 때까지 들을 수 있음
     * 적도에서 매일 ""오전 6시 일출과 오후 6시 일몰""이라는 개념은 놀라움
          + 또 다른 직관에 반하는 사실은 지구상의 모든 곳이 연중 같은 시간의 일조량을 받는다는 것임
     * 스톡홀름에 살면서 낮과 밤을 엄격하게 생각하기보다는 다양한 황혼과 어둠의 수준을 감사하게 되었음
          + 태양이 지평선에 낮게 위치할 때 하늘에 빛이 산란되어 매우 아름답고 호주에서 자랄 때보다 일출과 일몰이 훨씬 오래 지속됨
     * ""12분의 1 법칙""이라는 유용한 경험 법칙이 있음
          + 해양 항해 및 조수 계산에서 사용되며, 태양, 계절 등 주기적인 것에 유용한 정신 모델로 적용될 수 있음
          + 주기의 절반을 6시간 또는 적절한 단위로 나누면, 각 단위/시간의 변화량이 계산됨
          + 예를 들어, 6월 21일부터 12월 21일까지의 변화량을 1개월 단위로 나누면, 각 1/12는 10분에 해당함
          + 현재(3월 말)는 가장 빠른 감소 부분에 있으며, 매달 30분의 일조량을 얻고 있음
     * 북극권에 가까워질수록 낮의 길이가 지그재그로 변하는 것이 흥미로움
          + 이 현상이 정확히 맞는지 궁금했으며, 삼각 함수 정체성을 기반으로 간단한 증명이 있을 것이라 생각했음
          + 그러나 실제로는 그렇지 않으며, 선이 완전히 직선은 아니지만 매우 좋은 근사치임
     * 고위도에서 계산된 일조량은 실제 빛을 과소평가함
          + 예를 들어, 위도 60도에서는 ""명목상"" 한여름 밤이 약 4시간이지만, 실제로는 어두워지지 않음
     * iPhone을 대기 모드로 두고 세계 지도와 일조량 ""사인파""를 관찰하는 것이 재미있었음
          + 일조량이 지도 상단으로 가까워지는 것을 보면서 춘분의 의미와 일조 시간의 변화를 더 잘 이해하게 되었음
     * 스웨덴 중부 출신으로서 처음으로 남부 룬드에서 한여름 밤을 보냈을 때 밤이 실제로 어두운 것에 놀랐음
          + 고향에서는 6월에 여전히 지속적인 일조량이 있음
     * 핀란드에서는 일조량의 계절적 극단이 매우 극단적임
          + 밤과 낮의 주기가 24시간 주기보다는 365일 주기처럼 느껴짐
          + 이로 인해 5살 아이가 여름 내내 어두운 하늘을 보지 못할 수도 있음
"
"https://news.hada.io/topic?id=19951","Skapa - IKEA 매뉴얼 처럼 보이는 앱 만들기","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Skapa - IKEA 매뉴얼 처럼 보이는 앱 만들기

     * Skapa는 IKEA Skadis 페그보드에 맞는 커스텀 상자 모델을 생성해서 다운로드후 3D 프린터로 출력하는 용도의 웹앱
     * 완전 클라이언트 사이드에서 실행되며 GitHub에 코드 공개
     * 앱 자체가 IKEA 설명서 느낌이 나도록 디자인
          + 블랙 앤 화이트 컬러, 굵은 글자체 사용
          + (고소를 피하기 위해) IKEA의 ""Sans"" 글꼴 대신 ""Kanit"" 글꼴 사용
     * IKEA는 원근법(Perspective)을 사용하지만 정사투영(orthographic projection) 방식을 사용하며, 버튼 및 기능을 최소화함
     * 모델을 드래그하면 수직 회전하며, 클릭 시 모델이 180도 회전
     * 모델 생성은 manifold 라이브러리 사용
          + C++로 작성된 라이브러리를 Wasm으로 변환해 브라우저에서 실행
          + 클라이언트 사이드에서 100% 실행 가능
     * 렌더링은 Three.js 사용하여 → 웹에서 3D 모델 렌더링
          + 기본 Three.js의 outline 효과가 부족하여 커스텀 셰이더 사용
     * Skapa - GitHub Repo
     * Parametric IKEA Skadis Boxes on Printables
"
"https://news.hada.io/topic?id=19853","독립(Indie) 앱 비즈니스에 대한 몇 가지 조언","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      독립(Indie) 앱 비즈니스에 대한 몇 가지 조언

     * 맥용 웹 비디오 다운로더 Downie 와 미디어 포맷 변환기 Permute등 다양한 앱을 만든 개인 개발자 Carlie Monroe의 조언들

모든 것이 즉각적인 성공을 거두는 것은 아님

     * 하룻밤 사이에 성공한 사례들이 많지만, 이는 극히 예외적인 경우이며, 대부분의 비즈니스는 시간이 필요함
          + 제한된 예산으로는 몇 주나 몇 달 안에 히트작을 만드는 것이 현실적으로 어려움
          + 초기 자본 없이 회사를 시작한 사람으로서, 현실적인 조언을 하고자 함
     * 작은 실패에 대비할 것
          + 처음 출시한 앱들은 다운로드 수가 거의 없었고, 사용자도 없었으며, 수익도 없었음
          + 이러한 실패를 예상하고 낙담하지 않는 것이 중요함
          + 처음부터 완벽한 제품을 만들려고 1년을 소비하지 말고, 핵심 아이디어를 빠르게 개발하고 피드백을 받아 개선해 나가는 것이 효과적임
     * 앱의 완성도를 유지할 것
          + 앱의 핵심 아이디어를 개발하고, 피드백과 로드맵을 기반으로 발전시켜야 함
          + 너무 개발을 단순화하지 말고, 최소한 안정적으로 작동해야 함
          + 앱이 충돌하거나 버그가 많거나 미완성처럼 보이면 사용자 신뢰를 얻기 어려움
          + 일부 기능이 부족할 수는 있지만, 지속적인 업데이트를 통해 개선하는 것이 중요함
          + 꾸준한 개선이 이루어지면 사용자는 이를 긍정적으로 평가하고 앱을 추천하게 됨
     * 계속 개선하되, 멈출 시점을 아는 것이 중요함
          + 앱을 출시하고 몇 차례 업데이트하며 광고나 홍보를 시도했음에도 다운로드 수가 200명 수준이라면, 아이디어를 다시 고민해볼 필요가 있음
          + 사용자들이 앱을 유용하게 느끼지 않는다면, 새로운 아이디어를 고려하는 것이 나을 수도 있음
          + 낙담하지 말고, 더 나은 아이디어로 다시 도전할 준비를 할 것

직장을 구하지 말 것

     * 직장을 다니면서 인디 개발을 병행하는 것은 매우 어려운 일임
     * 내 경우 케임브리지 대학에서 여름 동안 인턴으로 일했는데, 하루 8시간을 일하고, 기숙사로 돌아와서 내 앱 작업을 추가로 3-4시간 했음
          + 여름이 끝날 때쯤, 스트레스를 받고, 체중이 늘었으며, 컴퓨터 앞에서 일하는 것 외에는 아무것도 할 시간이 없었음
     * 이러한 페이스를 오래 유지할 수는 없음
          + 몇 달 동안은 시도해볼 수 있지만, 그것만으로는 앱을 개발하고 사용자 기반을 확보하기에 충분하지 않음
          + 결국, 직장을 구하면 비즈니스 경로의 끝이 될 가능성이 높음
     * 하지만, 프리랜서 작업이나 소프트웨어 의뢰를 수락하는 것은 괜찮음
          + 하루 종일 앱 개발만 하는 것은 오히려 비효율적일 수 있으며, 다른 프로젝트를 하면서 머리를 식히는 것이 도움이 될 수 있음
          + 단, 외부 프로젝트가 본업이 되지 않도록 주의해야 하며, 하루 4시간 정도만 투자하고 자신의 프로젝트에 집중할 시간을 확보하는 것이 중요함
     * 초반에는 자금이 부족할 수 있으므로, 프리랜서 작업을 통해 최소한의 생활비를 마련하는 것이 필요함
          + 다만, 직장을 다니는 것이 아니라 자신의 프로젝트를 중심에 두고 일할 수 있도록 균형을 맞추는 것이 중요함

혼자서도, 함께하지도 말 것

     * 이것은 정말 어려운 결정임
     * 나는 혼자서 회사를 운영했음
          + 혼자서 회사를 운영하면 모든 결정을 스스로 내릴 수 있고, 코드 스타일, 기능, UI 등에 대한 의견 충돌이 없음
          + 그러나 성공은 몇 주나 몇 달의 문제가 아니며, 다른 사람이 비슷한 희생을 감수할지 알 수 없음
          + 몇 달 후에 공동 창업자가 그만두고 직장을 구할 수도 있으며, 각자의 삶의 상황이 다르기 때문에 방향성이 달라질 가능성이 있음
     * 하지만 완전히 혼자 하지도 말것
          + 혼자서 모든 것을 처리해야 하므로, 연중무휴로 일해야 함
          + 휴일이나 휴가 중에도 지원 이메일을 확인하고 답변해야 함
          + 하루 평균 100건 정도의 사용자 문의가 있으며, 대부분 기술적인 내용이 포함되어 있어 단순히 다른 사람에게 위임하기 어려움
          + 장기간 휴가를 가면 복귀 후 감당하기 어려울 정도로 업무가 쌓이며, 사용자들은 몇 시간 안에 응답받기를 원함
          + 고객 지원 업무는 하루 2~3시간 정도 걸리며, 전담 직원을 두기에는 부족하지만 혼자 감당하기에는 부담이 큼
          + 만약 공동 창업자가 있다면, 내부 구조를 잘 이해하고 있어 대신 업무를 처리할 수 있는 가능성이 높음
          + 다른 사람과 함께 시작하면, 그들이 당신을 대신하여 업무를 처리할 수 있으므로, 혼자서 모든 것을 감당하지 않아도 됨
     * 모순된 조언이지만 현실적인 고민이 필요함
          + 혼자 하면 자유롭지만 부담이 크고, 함께 하면 책임을 나눌 수 있지만 리스크도 존재함
          + 장기적인 관점에서 자신에게 맞는 방향을 신중하게 결정하는 것이 중요함

사용자 피드백을 소중히 여길 것

     * 사용자가 쉽게 연락할 수 있도록 해야 함
          + 오류 대화 상자, 메인 화면 등 앱 내 여러 곳에 지원 버튼을 배치하는 것이 좋음
          + 메일 클라이언트를 여는 방식은 사용자 경험을 방해할 수 있음
          + 대신, 앱 내에서 지원 양식을 제공하면 업데이트 확인, 버전 정보 포함, 추가 세부 정보 요청 등이 가능함
          + 지속적인 문의와 보고가 있을 수 있지만, 이는 사용자가 앱에 관심을 갖고 있다는 긍정적인 신호임
     * 사용자 의견을 경청할 것
          + 초기에 사용자가 적을 때는 최대한 만족도를 높이는 것이 중요함. 만족한 사용자는 앱을 추천하게 됨
          + 빠른 응답, 요청한 기능 구현 등을 통해 사용자와의 신뢰를 형성할 수 있음
          + 사용자의 피드백을 반영하다 보면 예상과 다른 방향으로 앱이 발전할 수도 있지만, 사용자 기반이 커진 후에는 다시 조정할 기회가 있음
     * 요청을 선별적으로 반영할 것
          + 사용자 요청이 앱의 전체적인 방향성과 맞는지 판단해야 함
          + 단순한 문제 해결이 아닌, 장기적으로 유용한 기능인지 고려해야 함
          + 요청의 이유와 사용자의 워크플로우에서 어떻게 작용할지를 파악한 후, 더 나은 접근 방식이 있다면 설명하는 것이 중요함
          + 기능이 부족해서 한 명의 사용자를 잃는 것보다, 너무 복잡해져서 수백 명의 사용자를 잃는 것이 더 큰 문제임

갑작스러운 종료에 대비할 것

     * 모든 비즈니스는 언젠가 끝나게 됨. 규모가 큰 회사가 아니라면, 은퇴하거나 더 이상 운영할 수 없을 때 사업은 사라질 수밖에 없음
     * 이는 자연스러운 일이므로, 언젠가 회사를 종료하게 될 것이라는 점을 염두에 두는 것이 중요함
     * 기술 업계는 빠르게 변화하며, 현재 인기 있는 앱도 시간이 지나면 쓸모없어질 수 있음
     * 2000년대 초반 인터넷 붐이 꺼지면서 많은 사업이 급격히 축소된 사례가 있음
          + 사례 1: CandyBar
               o 15~20년 전, 시스템 아이콘과 Dock을 커스터마이징할 수 있는 인기 앱이었음
               o 하지만 macOS가 Dock 렌더링 방식을 바꾸고, 시스템 보호 기능(SIP)이 추가되면서 더 이상 사용할 수 없게 됨
          + 사례 2: Skype
               o 15년 전에는 필수적인 커뮤니케이션 도구였지만, 지금은 iMessage, FaceTime, WhatsApp, Zoom, Google Meet 등으로 대체됨
               o 시장의 변화로 인해 점차 사용자들에게서 잊혀짐
          + 사례 3: Twitterrific & Apollo
               o 트위터(X)와 Reddit이 API 정책을 갑자기 변경하면서, 기존의 서드파티 앱들이 더 이상 작동하지 않게 됨
               o 개발자들은 아무런 준비 없이 앱을 폐기해야 했으며, 사용자들은 개발자의 책임으로 오해하기도 했음
     * 대비 전략
          + 하나의 앱에만 의존하지 말고, 2~4개의 안정적인 앱을 운영하는 것이 바람직함
          + 주력 앱 외에도 예비 수익원이 될 앱을 확보하여 돌발 상황에 대비할 것
          + 완전한 출구 전략을 세우는 것도 방법임. 예를 들어, 새로운 분야로 전환할 계획을 미리 세워두는 것이 중요함

마무리

     * 위 내용이 절대적인 법칙이라고 생각하지는 말 것
          + 이는 20년 이상의 경험에서 나온 것이지만, 모든 경험은 주관적인 것임
     * 시대가 변했고, 개인의 상황도 다르므로 같은 방식이 항상 통하는 것은 아님
     * 이 모든 것이 가치가 있냐고 묻는다면?
          + 개인적으로는 가치가 있었음
          + 어려운 시기를 거쳐 사업을 성장시켰고, 이를 통해 생계를 유지할 수 있었음
          + 하지만 모든 사람에게 적합한 길은 아님
          + 스스로 동기 부여를 하지 않으면 쉽게 포기할 수 있으며, 상사가 없는 환경에서 자율적으로 일하는 것이 중요함
     * 현실을 고려할 것
          + 인디 개발을 시작하려는 사람들에게 겁을 주려는 것이 아님
          + 오히려 너무 일찍 포기하는 것이 가장 큰 위험 요소라고 여러 번 언급했음
          + 비즈니스를 시작하고 앱을 만드는 것은 훌륭한 도전이지만, 현실적인 기대를 가지는 것이 중요함
          + 몇 달 안에 끝날 일이 아니라 몇 년, 혹은 수십 년 동안 지속될 수도 있는 과정임
               o 신중하게 고민한 후 도전할 것
"
"https://news.hada.io/topic?id=19878","Playwright Visual comparisons를 활용해, 효율적으로 더 안전한 개발 환경 만들기","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Playwright Visual comparisons를 활용해, 효율적으로 더 안전한 개발 환경 만들기

  배경 및 문제 인식

     * 프론트엔드 테스트는 UI 변경과 예측 불가한 사용자 입력으로 인해 어려움이 많음.
     * 사람이 직접 검증하는 테스트는 한계가 있어 자동화된 테스트 도입을 고려.
     * 기존 레코딩 방식의 E2E 테스트(TestProject, Playwright)는 유지보수 비용이 높고, UI 변경에 취약.

  Playwright Visual Comparisons 도입

     * UI의 변화를 감지하는 시각적 회귀 테스트 방식 적용.
     * 기준 스크린샷을 저장하고, 코드 변경 후 비교하여 변경 사항을 검출.
     * 2-up, Swipe, Highlight, Onion Skin 방식으로 이미지 비교 가능.

  도입 과정에서 겪은 주요 문제와 해결책

    1. 미세한 차이(0.01%)로 가짜 실패 발생
       문제: 테스트 실행 환경(OS, 브라우저, 디스플레이 설정 등)에 따라 폰트 렌더링 차이 발생.
       해결: Docker 컨테이너를 활용해 모든 테스트를 동일한 환경에서 실행.
    2. 데이터 로딩 완료 후 스크린샷을 찍어야 하는 문제
       문제: 페이지가 완전히 로딩되기 전에 스크린샷을 찍으면, 로딩 UI가 포함되는 경우 발생.
       해결: getByText + toBeVisible을 활용하는 유틸리티 함수로 특정 문자열이 나타날 때까지 대기.
    3. 애니메이션 요소로 인해 스크린샷 차이 발생
       문제: CSS 애니메이션, Canvas, SVG, WebGL 요소가 매번 다른 타이밍에 캡처됨 & flaky test가 됨.
       해결: 애니메이션 비활성화를 위한 각종 처리 및 부가적인 테스트 실행 효율화
    4. 써드파티 플러그인(iframe 등)으로 인한 불필요한 변경 감지
       문제: 고객 피드백, 설문조사, 챗봇 등의 써드파티 플러그인이 iframe을 통해 로딩되며 시각적 변화 생성.
       해결: 스크린샷 생성 시 공통 css 처리를 통해 iframe과 특정 플러그인 요소를 보이지 않게 처리
    5. 스크롤이 있는 페이지에서 하단 요소 검증 실패
       문제: toHaveScreenshot은 기본적으로 현재 보이는 화면만 캡처하여, 스크롤 관련 처리 필요
       해결: fullPage: true 옵션을 적용해 전체 페이지 스크린샷을 캡처하도록 설정.

  결론

     * 시각적 회귀 테스트를 통해 UI 변경 감지를 효과적으로 자동화함.
     * 완벽한 솔루션은 아니지만, 개발 생산성과 테스트 안정성을 모두 향상시킴.
     * 지속적인 개선과 테스트 환경 최적화가 필요함.
"
"https://news.hada.io/topic?id=19900","캘리포니아 법무장관, 23andMe 고객 대상 소비자 경고 발령","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  캘리포니아 법무장관, 23andMe 고객 대상 소비자 경고 발령

     * 23andMe의 재정적 어려움: 캘리포니아 법무장관 Rob Bonta는 유전자 검사 및 정보 회사인 23andMe의 고객에게 소비자 경고를 발행함. 이 회사는 재정적 어려움을 겪고 있으며, 지속 가능성에 대한 의문이 제기되고 있음.
     * 유전자 데이터 삭제 권리: 캘리포니아 주민들은 Genetic Information Privacy Act (GIPA)와 California Consumer Protection Act (CCPA)에 따라 23andMe에 자신의 유전자 데이터를 삭제하도록 요청할 권리가 있음. 이러한 권리를 행사하려면 23andMe 웹사이트를 방문해야 함.
     * 유전자 데이터 삭제 방법:
          + 23andMe 계정에 로그인 후, 프로필의 ""설정"" 섹션으로 이동.
          + 페이지 하단의 ""23andMe 데이터"" 섹션에서 ""보기"" 클릭.
          + 데이터를 개인 저장용으로 다운로드할 수 있음.
          + ""데이터 삭제"" 섹션에서 ""데이터 영구 삭제"" 클릭.
          + 이메일로 전송된 링크를 통해 삭제 요청 확인.
     * 유전자 샘플 파기: 이전에 23andMe에 침 샘플과 DNA를 저장하도록 선택한 경우, 계정 설정 페이지의 ""선호 사항""에서 변경 가능.
     * 연구 사용 동의 철회: 23andMe 및 제3자 연구자에게 유전자 데이터 사용을 허용한 경우, 계정 설정 페이지의 ""연구 및 제품 동의""에서 동의를 철회할 수 있음.
     * GIPA와 CCPA의 권리: GIPA는 캘리포니아 소비자에게 계정과 유전자 데이터를 삭제하고 생물학적 샘플을 파기할 권리를 부여함. CCPA는 개인 정보를 수집하는 기업으로부터 개인 정보를 삭제할 권리를 제공함.
     * 추가 정보: CCPA에 대한 자세한 정보는 관련 웹사이트에서 확인 가능.

        Hacker News 의견

     * 나는 비인간 유기체의 인구 유전체학 분야에서 일하며, 과거에 마이크로어레이가 주된 기술이었을 때 거의 전체 유전체 유전자형 연구에 참여한 경험이 있음
          + 20년 가까이 가족들에게 23andMe와 같은 상업적 회사의 대규모 유전자형 분석에 참여하지 말라고 조언해 왔음
          + 23andMe 유전자형 분석이 크리스마스 선물로 인기를 끌었던 이유를 이해하지 못했음
          + 대규모 서열 정보가 일부 사람들에게는 적절할 수 있지만, 자신의 데이터를 소유하는 것이 중요함
          + 23andMe가 재정적으로 위험에 처한 것은 대량의 일반 데이터에서 큰 가치를 얻기 어렵다는 것을 보여줌
          + 대형 건강 보험사도 DNA 데이터에서 큰 가치를 얻지 못할 것임
          + 의료 기록과 유전자 데이터의 연결은 예상보다 가치가 낮음
     * 데이터 브로커에 대해 조심했던 과거를 자랑스럽게 생각할 때도 있지만, 가족들이 23andMe에 DNA를 제공한 것이 나의 노력을 무의미하게 만듦
          + 데이터를 삭제할 수 있지만, 규제 의무로 인해 여전히 보관될 수 있음
          + 23andMe의 프라이버시 팀과 논의한 결과, 법적 및 규제 의무에 따라 일부 정보가 보관될 수 있음을 확인함
     * 파산은 회사의 고객에 대한 의무를 무효화할 수 있음
          + 특히 자산이 캘리포니아 외부나 미국 외부의 회사에 판매될 경우 프라이버시 의무가 사라질 수 있음
     * 이로 인해 어떤 피해가 발생하는지는 명확하지 않지만, 내 유전체를 공개하여 실험해 볼 계획임
          + 친구와 함께 사람들의 유전체와 건강 정보를 제출할 수 있는 사이트를 만들려고 했음
          + VCF 파일을 제공하는 것이 더 나을 수도 있음
     * 23andMe가 재정적 어려움을 겪고 있으며, 계속 운영될 수 있을지 의문이 제기됨
          + 개인 메시지가 데이터베이스에 저장되지 않도록 Signal을 사용함
          + 보안 카메라, 비밀번호 관리자, 홈 자동화 등 앱을 로컬로 호스팅하려고 함
     * 23andMe가 소비자와 데이터 처리에 대한 합의를 했다면, 회사가 매각되더라도 그 합의는 유지되어야 함
          + Dropbox가 매각되더라도 개인 데이터가 훼손되지 않을 것이라고 생각함
     * 회사가 어떤 일을 절대 하지 않겠다고 약속했지만, 법적 결과나 보장이 없다면 그 회사는 결국 그 일을 할 것임
     * 영화 Gattaca를 연상케 함
"
"https://news.hada.io/topic?id=19873","OpenAI o1-pro, 이제 API로 접근 가능","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      OpenAI o1-pro, 이제 API로 접근 가능

     * 입력 토큰 $150, 출력 토큰 $600 (1백만개당)
          + o1-mini 보다 150배 비쌈
     * o1 시리즈 모델은 강화 학습(Reinforcement Learning)을 통해 답변 전에 생각하고 복잡한 추론을 수행하도록 훈련됨
          + o1-pro 모델은 더 많은 연산 자원을 사용해 더 깊이 생각하고 일관된 고품질 답변 제공
     * Responses API에서만 사용 가능하며, 다음 기능 지원
          + 여러 도구 호출 지원
          + API 요청에 응답하기 전에 여러 턴에 걸친 모델 상호작용 지원
     * 200,000 컨텍스트 윈도우, 최대 출력 토큰 갯수 100,000
     * 컷오프는 2023년 10월 1일

        Hacker News 의견

     * 이 모델은 새로운 Responses API를 통해서만 사용할 수 있음. Chat Completions를 사용하는 코드를 가지고 있다면, 이를 지원하기 위해 Responses로 업그레이드해야 함
          + 내 LLM 도구에 지원을 추가하는 데 시간이 걸릴 수 있음
     * 가격: 입력 토큰 100만 개당 $150, 출력 토큰 100만 개당 $600임
          + 매우 비싸지만, ChatGPT Pro 구독과 함께 사용해본 결과 놀라울 정도로 능력 있음
          + 100,000 토큰의 코드베이스를 제공하면 내가 완전히 간과한 미묘한 버그를 찾아냄
          + API 가격과 내가 지불하는 구독 가격을 비교하면 약간 미안한 느낌이 듦
     * 펠리컨이 자전거를 타는 SVG를 렌더링하는 데 94센트가 들었음
     * 연봉 $160k의 동기 부여된 사무직 근로자가 하루에 6시간을 듣거나 말한다고 가정하면, 100만 토큰당 비용은 약 $10k임
          + OpenAI는 이제 그들의 최전선 모델 가격으로 고도로 숙련된 인간과 비슷한 수준에 도달함
          + o3 pro가 이 상황을 바꿀 수 있지만, o3가 곧 출시될 예정이었다면 이 모델을 출시하지 않았을 것이라고 생각함
     * 2023년 지식 컷오프와 200k 컨텍스트 윈도우를 가짐
          + 다소 실망스러움
     * o1-pro는 Grok 3 think와 Claude 3.7 think를 포함한 다른 모든 릴리스와 비교해도 여전히 뛰어남
          + 프로 구독을 취소하려고 했지만, 4.5는 비코딩/수학 작업에 너무 좋음
          + o3 pro를 기다릴 수 없음
     * 테스트해보고 좋아한 사람들 있음
          + Sonnet 3.7에 매우 자신감이 있음
          + 더 빠르기를 바람
          + 대부분의 문제는 실행 문제이며, AI가 내가 직접 코딩하는 것보다 더 빠르게 해주기를 원함
     * o1-pro는 스위치인 도구나 코드베이스를 이중 확인하는 용도로 사용될 것 같음
          + 가격이 낮아도, Sonnet의 10배 속도를 얻기 위해서는 많은 작업과 도메인 지식이 필요할 것이라고 가정함
     * o1-pro는 스트리밍을 지원하지 않음
          + 여러 답변을 검색하기 위해 best-of-n 유형의 기술을 사용하는 것으로 추정됨
          + llm-consortium을 사용하면 훨씬 낮은 가격으로 유사한 결과를 얻을 수 있을 것이라고 생각함
          + 여러 모델을 프롬프트하고, 그 중 최고의 응답을 선택하거나 합성할 수 있음
          + 신뢰 임계값에 도달할 때까지 반복할 수 있음
     * 처음에는 플랫폼에 추가할 수 있다고 생각했지만, 가격을 보고 대다수 사용자에게 모델을 활성화하는 것이 망설여짐
          + 부유한 기업을 제외하고는 대부분의 사용자가 스스로 발등을 찍을 것임
     * o1-Pro가 o1 모델의 워크플로우일 가능성을 항상 의심했음
          + 8개의 o1 인스턴스로 분산하고 결과를 집계하는 방식일 가능성이 있음
"
"https://news.hada.io/topic?id=19974","오픈소스 개발자, AI 크롤러가 트래픽을 초래하면서 국가 전체를 차단","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 오픈소스 개발자, AI 크롤러가 트래픽을 초래하면서 국가 전체를 차단

     * AI 크롤러가 오픈소스 프로젝트 사이트에 과도한 트래픽을 유발하면서 실제로 서비스 마비 수준의 피해 발생
     * AI 크롤러는 robots.txt 무시, User-Agent 위조, 거주지 IP 우회 등으로 기존 방어 체계를 회피함
     * 개발자 Xe Iaso는 이를 막기 위해 VPN 뒤로 서버를 옮기고, 사용자가 퍼즐을 풀어야 접속할 수 있는 'Anubis'라는 증명 기반 시스템 도입
     * LibreNews에 따르면 어떤 프로젝트의 경우 전체 트래픽의 97%가 AI 크롤러에서 유입됨
     * Fedora, GNOME, KDE 등의 유명 프로젝트도 국가 차단, Anubis 적용, 임시 셧다운 등으로 대응 중

실제 피해 사례와 AI 크롤러의 무분별한 접근

     * GNOME의 GitLab에서 84,056건 중 3.2%만이 Anubis 통과 → 대부분이 비정상 크롤링으로 추정됨
     * KDE는 Alibaba IP로부터의 트래픽으로 GitLab 인프라가 일시적으로 마비됨
     * 모바일 사용자 일부는 퍼즐 로딩에 2분 이상 소요되기도 함
     * Diaspora 인프라 유지 담당 Dennis Schubert는 AI 크롤러 트래픽을 ""인터넷 전체에 대한 DDoS""로 표현함
     * Read the Docs는 AI 크롤러 차단 후 하루 800GB → 200GB로 트래픽 감소, 매월 약 $1,500 절감 효과 발생

오픈소스 프로젝트에 집중된 불균형한 부담

     * 오픈소스는 제한된 자원으로 운영되며, 공개 협업을 기반으로 함
     * 많은 크롤러들이 robots.txt를 무시하고, User-Agent를 속이며, IP를 계속 바꾸며 접근함
     * Inkscape의 Martin Owens는 브라우저 정보를 위조하는 AI 회사들로 인해 대규모 차단 목록 유지 중
     * Hacker News에서는 AI 기업의 자본력과 비협조적인 태도에 대한 분노 확산
     * SourceHut의 Drew DeVault는 크롤러들이 모든 git 로그 페이지, 커밋까지 접근하여 리소스 과소비 유발
     * Curl 프로젝트는 AI가 생성한 허위 버그 리포트를 수령한 사례 보고됨

AI 크롤러의 목적과 기업별 행동 양상

     * AI 크롤러는 학습 데이터 수집 또는 AI 답변을 위한 실시간 검색 등 다양한 목적 존재
     * Diaspora 분석 결과: OpenAI 25%, Amazon 15%, Anthropic 4.3% 트래픽 차지
     * 크롤러는 주기적으로 동일 페이지 반복 크롤링(예: 6시간 간격)
     * OpenAI, Anthropic 등은 비교적 정상적인 User-Agent 사용, 일부 중국 AI 기업은 위장 수준 높음
     * Amazon, Alibaba 등도 피해 사례에 등장하지만 해당 기업은 아직 공식 입장 없음

대응 수단: Tarpit, 퍼즐, 협업 방안 등

     * ""Nepenthes""라는 툴은 AI 크롤러를 끝없는 가짜 콘텐츠 미로에 빠뜨리는 공격적 방어 수단
     * 제작자 Aaron은 이 툴이 크롤러 비용을 증가시키고 훈련 데이터 오염을 유도한다고 주장
     * Cloudflare는 상업용 보안 기능으로 'AI Labyrinth'를 발표, 크롤러를 유도해 무의미한 페이지 탐색 유도
     * 하루 500억 개 이상 AI 크롤링 요청이 Cloudflare 네트워크에 발생
     * 오픈소스 프로젝트 ""ai.robots.txt""는 AI 크롤러 목록 및 차단용 robots.txt / .htaccess 파일 제공

지속되는 AI 데이터 수집과 오픈웹의 위기

     * 규제 없이 방대한 데이터 수집을 계속하는 AI 기업들로 인해 오픈소스 인프라에 심각한 위협 발생
     * AI가 의존하는 디지털 생태계를 스스로 파괴하고 있다는 비판 제기
     * 협업적인 데이터 수집 체계가 대안이 될 수 있지만, 주요 AI 기업들은 자발적 협력 의지 부족
     * 의미 있는 규제나 자율적인 책임 의식 없이는 AI와 오픈소스 간의 충돌은 더욱 심화될 가능성 있음

        Hacker News 의견

     * 봇들이 웹사이트 방문에서 부정적인 유틸리티 값을 얻도록 하는 것이 목표임. 이는 단순히 차단하는 것보다 효과적임
          + robots.txt에서 금지된 페이지를 시도하면, 표백제 음용의 이점에 대한 기사를 제공함
          + 의심스러운 사용자 에이전트라면, 불안정한 코드를 긁어가도 좋음
          + 비인간적인 요청 속도라면, 홍역이 침대에서의 성능에 긍정적인 영향을 미친다는 생성된 기사를 제공함
          + Nepenthes는 좋지만, 단어 샐러드는 쉽게 감지됨. 언어적으로 그럴듯하지만 사실적으로는 쓰레기인 텍스트를 생성하는 기능이 필요함
     * 기업들이 더 협력적인 접근 방식을 채택하지 않는 이유가 불분명함. 최소한 데이터 수집 속도를 제한하여 소스 웹사이트를 압도하지 않도록 해야 함
     * 자원을 접근하기 위해 마이크로트랜잭션을 도입해야 한다고 생각함. 서버에 소액을 지불하면 콘텐츠를 반환함. 크롤러가 트래픽을 지배하면 그만큼 비용을 지불하는 것임
     * sugaku.net을 로그인 없이 사용할 수 있도록 열었더니, 크롤러가 빠르게 시작됨. 사이트를 모두에게 접근 가능하게 하고 싶지만, 대부분의 동적 기능을 로그인 사용자에게 제한해야 했음. robots.txt를 제한하고, Cloudflare를 사용해 AI 크롤러와 나쁜 봇을 차단했지만 여전히 하루에 약 100만 건의 자동 요청을 받고 있음. 곧 로그인 사용자에게만 사이트를 제한해야 할 것 같음
     * 최근 ""코드 에브리띵 인 프로드"" 접근 방식으로 사이드 프로젝트를 시작했음. 지난 20년 동안 여러 번 해왔지만, 이번에는 다름. 호스트 이름을 어디에도 광고하지 않았지만, 24시간도 안 되어 스팸 폼 제출이 많았음. 소규모 홍보 후에 이런 일이 발생할 것으로 예상했지만, 서버를 시작하자마자 봇들이 상호작용을 수행하는 것은 예상하지 못했음
     * 다른 사람들이 Lynx나 curl을 사용하여 파일을 복사하는 것을 막는 것이 아니라, 잘못된 소프트웨어로 인해 서버가 과부하되는 것을 막는 것이 문제임
          + HTTP 서버에 포트 노킹을 잠시 설정했지만, 커널 패닉으로 인해 제거했음. 나중에 문제를 해결하면 다시 설정할 수 있음
          + LLM 스크래퍼들이 현재는 ""스마트""하게 행동하지 않음. 미래에 그렇게 된다면, 그 점을 이용할 수 있을 것임
          + 스크래퍼를 혼란스럽게 만들 수 있는 방법이 있을 것임. 예를 들어, 선언된 사용자 에이전트가 수행하지 않는 작업을 선언하면 오류 메시지를 표시함. Lynx를 사용하는 사용자는 영향을 받지 않고 여전히 접근 가능함
     * ClaudeBot(Anthropic)에게 DoS 공격을 받았음. 한 달에 70만 번 웹사이트를 타격하고, 호스팅 제공업체의 대역폭 제한을 초과함. 사용자 에이전트를 차단하고, 호스팅 제공업체 지원과 협력하여 제한을 해제하는 것이 번거로웠음
          + ChatGPT 봇이 이 사이트에서 두 번째로 많은 트래픽을 차지했지만, 문제를 일으킬 만큼은 아님
     * JS 중심의 ""안티 봇"" 조치는 브라우저 독점을 더욱 강화함. 대신 LLM이 아직 풀지 못하거나 일관되게 틀리는 질문을 하는 간단한 HTML 폼을 추천함. 사이트의 콘텐츠와 관련된 질문일수록 좋음. 전자기기 포럼에서 비슷한 ""기술 테스트"" 질문을 등록 양식에 사용했으며, 일부는 LLM으로 해결할 수 있지만, 여전히 인간만이 풀 수 있는 CAPTCHA임
     * 웹사이트를 과도하게 스팸하는 것은 나쁜 행동임. 그러나 AI 크롤러를 차단하면 결국 손해를 봄. 장기적으로 SEO를 대체할 것이 무엇인지 추측해보라
     * 여러 콘텐츠 사이트를 운영했으며, 최근 며칠 동안 공격적인 AI 봇들로 인해 몇몇 사이트를 폐쇄했음. Alexa가 가장 나쁜 것 같음
          + 20년 전에 만들어져서 업데이트되어 왔음. 트래픽을 얻었지만, 지난 1년 동안 1,000명 이하의 합법적인 방문자로 줄어들었음. 이제는 로봇 파일을 무시하는 공격적인 봇들로 인해 서버 다운 이메일을 처리해야 함
"
"https://news.hada.io/topic?id=19895","조지 포먼 사망","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                조지 포먼 사망

     * 조지 포먼, 복서에서 포먼 그릴 인포머셜 스타로, 76세로 사망
          + 조지 포먼은 텍사스 출신으로 세계 헤비급 챔피언이었으며, TV와 대중문화의 아이콘이었음
          + 1990년대에 저비용 TV 시간을 활용하여 포먼 그릴 제품을 인포머셜을 통해 성공적으로 출시함
          + 1977년 링에서의 사건을 계기로 복싱을 그만두고, 1978년에는 목사로 임명되어 휴스턴에서 설교를 시작함
          + 1987년에 복싱에 복귀하여 1994년에 헤비급 챔피언 타이틀을 다시 획득함
          + 1997년에 복싱에서 은퇴함
     * 관련 이야기
          + 포먼은 휴스턴의 주 예수 그리스도 교회를 이끌며 주 4회 설교를 했음
          + 최근에는 자신의 삶과 복싱에 관한 다큐멘터리 프로젝트에 참여했으며, 2023년에는 그의 복귀를 다룬 전기 영화 ""Big George Foreman""이 개봉됨
     * 포먼의 초기 생애와 경력
          + 1949년 1월 10일에 태어나 텍사스 마샬에서 극심한 가난 속에서 성장함
          + 1968년 멕시코시티 올림픽에서 복싱 금메달을 획득하며 전국적인 명성을 얻음
          + 1973년 킹스턴에서 조 프레이저를 꺾고 헤비급 챔피언십을 획득함
          + 1974년 ""정글의 소동""에서 무하마드 알리와 맞붙었으며, 이후 5번의 경기에서 모두 KO 승리를 거둠
     * TV와 대중문화에서의 포먼
          + 포먼은 TV 토크쇼와 ""The Tonight Show"", ""Late Night With David Letterman"" 등 다양한 프로그램에 출연하며 대중적인 인기를 얻음
          + 포먼 그릴은 1990년대 초부터 소매 및 직접 판매에서 큰 성공을 거둠
          + 1993년 ABC 가족 코미디 ""George""에 출연했으며, 1994년에는 NBC의 ""Saturday Night Live""를 진행함
          + 여러 TV 쇼와 영화에서 카메오 및 작은 역할로 출연함
     * 추가 정보
          + 포먼의 가족은 그의 사망을 인스타그램을 통해 확인함
          + 포먼은 15세에 휴스턴의 거리에서 싸움꾼으로 활동했으며, 결국 복싱에 입문하게 됨

        Hacker News 의견

     * 조지 포먼의 사망에 대한 애도. 전직 격투 스포츠 팬으로서, 선수들이 자신과 상대방에게 큰 뇌 손상을 입히는 것을 보기가 점점 어려워짐. 포먼은 예외적으로 괜찮았던 것 같지만, 다른 노년의 파이터들의 발음이 흐릿하고 말이 잘 안 되는 것을 들으면 안타까움. UFC 파이터 친구가 있는 사람의 일화로, 그가 아이들의 이름을 잠시 잊어버린 적이 있었음. 훌륭한 경기는 매우 재미있지만, 윤리적으로 팬이 되기가 요즘 정말 어려움
     * 포먼은 자신의 이름 사용 권리로 1999년에 Salton으로부터 1억 3천 8백만 달러를 받았음. 그 이전에는 판매된 그릴의 이익의 약 40%를 받았으며, 한 달에 최대 450만 달러를 벌었음. 2011년까지의 총 수익은 2억 달러 이상으로, 복서로서 번 돈보다 훨씬 많았음
     * 포먼의 이름 사용 권리는 대단한 것이었음. 그가 이 분야에서 최고 중 하나였음을 인정함
     * 포먼의 팬이었으며, 그의 전성기는 내 시대 이전이었지만, 그가 48세에 마지막으로 헤비급 챔피언이 되었던 것이 인상적이었음. 나이가 들어도 신체 활동을 하기엔 늦지 않았음을 상기시켜 줌
     * 어릴 때 조지 포먼을 몰랐고, 조지 포먼 그릴 광고에서 그를 발명가로 착각했음. 11살 때 만화책에서 그를 본 후, 그가 TV 그릴 발명가와 관련이 있는지 궁금했음. 어머니에게 물어보니 웃으셨고, 그날 유명인 광고에 대해 배웠음
     * 'When We Were Kings'를 보고 조지 포먼에 대해 더 알게 되었음. 알리와 마찬가지로 흥미로웠고, 알리에게 패배한 후 돌아와 자신을 재창조한 모습에 감명받았음. 그의 회복력과 개인적 진화의 상징이 되었음
     * 포먼 그릴은 많은 비판을 받지만 훌륭한 조리 도구임. 그 덕분에 대중화되었음. 또한 훌륭한 아버지, 기독교인, 복서였음
     * 잭 랄레인의 파워 주서와 닭다리를 꺼낼 때임. 애도
     * 좋은 사람이고 전반적으로 신사였음. 삼촌 브라이언이 80년대 초 토피카에서 그를 만나 사진 촬영을 격려했음
     * 조지는 강력한 복서였고, 위대한 선수 중 하나였음. 대학 시절 포먼 그릴로 많은 좋은 음식을 만들었음
     * 1987년에 그가 한 일은 항상 기억될 것임. 순수한 힘과 지구력에 대한 링 IQ의 걸작이었음
"
"https://news.hada.io/topic?id=19921","Next.js vs TanStack – Next.js의 한계와 TanStack의 장점","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Next.js vs TanStack – Next.js의 한계와 TanStack의 장점

     * 아직 React를 좋아하고 Vercel이 제공하는 것도 좋지만, Next.js의 복잡성 증가와 비용 문제로 인해 TanStack으로 전환
     * TanStack은 아직 부족하지만, 직관적이며 필요할 때 고급 기능을 쉽게 추가 가능
     * Next.js의 고급 기능이 필요해질 때까지는 TanStack이 최선의 선택

Next.js의 강점

     * 빠른 설정 및 다양한 통합 지원
          + Next.js는 ""React Framework for the Web""으로, React 앱을 빠르게 설정 가능
          + 다양한 통합 가이드가 있음 : MUI, MarkdocDataDog 등
          + Jest와 같은 도구에 대한 네이티브 플러그인 제공
     * 고성능 대규모 애플리케이션에 유리
          + 개별 페이지의 렌더링 패턴을 세밀하게 조정 가능
          + 고성능을 위한 다양한 API 제공
               o 서버 사이드 렌더링(SSR)
               o 부분 사전 렌더링(PPR)
               o 엣지 함수, 스트리밍 및 선택적 하이드레이션
          + 증분 정적 재생성(ISR) 지원으로 고트래픽 콘텐츠의 효율적 처리 가능

Next.js의 한계 및 문제점

     * 불필요한 고급 기능의 복잡성
          + 고급 기능들이 작은 규모의 앱에는 과도하게 느껴짐
          + 초기 단계 스타트업에는 필요 없는 마이크로 성능 개선 기능이 많음
     * 금전적 비용 문제
          + Next.js의 많은 기능이 상용 서비스에 묶여 있음
               o 엣지 컴퓨팅 (middleware.ts)
               o 이미지 변환 (next/image)
               o ISR (export const revalidate = 60)
               o 서버리스 함수 실행 (app/api/route.ts)
          + Vercel 서비스에 대한 의존도가 높아 비용 증가 위험
     * 복잡한 학습 곡선 및 API 표면*
          + 앱 라우터의 복잡성으로 인해 학습 곡선이 높음
          + 문서에서 개념 설명이 난해하고 이해하기 어려움
          + 디버깅이 어려움
               o 전체 경로 캐시, 데이터 캐시, 라우터 캐시 등 세 개의 캐시 시스템 존재
     * SPA(싱글 페이지 애플리케이션) 지원 부족
          + Next.js의 SPA 지원은 제한적이며 성능 개선이 어려움
          + Vite와 비교해 개발 서버 성능이 뒤처짐
          + TurboPack 성능도 기대에 미치지 못함

TanStack + Vite의 장점

     * 간단하고 직관적인 구조
          + TanStack Router는 자동완성 및 Zod를 통한 검색 매개변수 검증 제공
          + 코드 흐름이 명확하고 예측 가능함
     * TanStack Query를 통한 상태 관리
          + 서버 상태를 쉽게 관리하고 디버깅 가능
          + 개발자 도구가 내장되어 있음
     * Vite의 빠른 성능
          + 빌드 및 코드 실행 속도가 빠름
          + 복잡한 설정 없이 바로 작동함
          + 특정 클라우드 서비스에 종속되지 않음

   만들다보면 결국 next.js처럼 될거라고 봅니다
"
"https://news.hada.io/topic?id=19889","IndieWeb은 대중화될 필요가 없다","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         IndieWeb은 대중화될 필요가 없다

     * IndieWeb은 사람들이 자신의 웹사이트를 호스팅하고 자신만의 콘텐츠를 소유하는 것을 장려하는 운동
          + 개인 웹사이트, IRC 채널, 소셜 미디어 등을 통해 활동
          + 디지털 독립을 강조하고 개인이 자신의 디지털 정체성을 통제해야 한다는 철학
     * 종종 ""IndieWeb은 성공하지 못했다""는 주장이 나옴
          + 마치 사람들이 슈퍼마켓에서 채소를 사기 때문에 가드닝이 유행하지 않았다고 말하는 것과 같음
          + IndieWeb은 대중적이지 않아도 가치 있음
          + 핵심은 대중적 성공이 아니라 개인의 창작 자유와 디지털 독립

초기 웹의 창작 문화와 IndieWeb의 연관성

     * 2000년대 초반 HTML을 배우며 개인 웹사이트를 제작했던 경험 회상
          + 코드 몇 줄을 작성하고 브라우저에서 결과를 확인하는 과정에서 창의적 즐거움 경험
          + 다른 웹 제작자들과의 교류에서 얻는 기쁨
     * IndieWeb은 이 같은 창작 문화의 연장선
          + 대중의 인정을 받기 위한 것이 아니라 순수한 창작의 기쁨을 위한 것
          + ""해커 문화""의 일부로서 코드 작성과 공유를 즐기는 커뮤니티

IndieWeb이 대중화될 필요가 없는 이유

     * IndieWeb의 가치는 대중적 성공이 아닌 개인적 의미에서 발생
          + 개인의 디지털 독립성과 창의적 표현의 자유 강조
          + 소수의 사람들에게만 의미가 있어도 충분히 가치 있는 존재
     * 대중화가 아닌 자발적인 참여와 창의적 표현이 중요
          + 대규모 사용자 확보보다 진정한 창작의 기쁨이 핵심
          + 같은 가치를 공유하는 사람들과의 연결에서 의미 발생

결론: IndieWeb은 이미 가치가 있다

     * IndieWeb은 성공을 측정할 필요가 없음
     * 대중의 인정을 받지 않아도 자신만의 웹사이트를 제작하고 소유하는 것은 충분히 가치 있음
     * 창의적 자유와 디지털 독립을 추구하는 사람들에게 IndieWeb은 이미 중요한 의미를 가짐

   중요한 가치라고 생각합니다!

        Hacker News 의견

     * IndieWeb은 주류가 되지 않아도 참여자에게 가치가 있음
          + 비독립적인 웹은 대기업에 의해 통제되며 개인에게 해를 끼칠 수 있음
          + 독립적인 웹을 육성하는 것은 필수적이며, 대기업의 영향력에서 벗어나는 것이 중요함
          + IndieWeb, RSS, Matrix, Mastodon, Bluesky 프로토콜은 개방형 웹의 희망임
          + 사용자 인터페이스의 어려움에 대한 비판에 대해 IndieWeb 리더들이 더 관대해지길 바람
     * IndieWeb은 주류가 되지 않아도 의미가 있음
          + 록앤롤, 재즈, 비트 시가 청소년 문화를 정의했던 시절이 있었음
          + 록 음악과 재즈는 여전히 존재하지만, 더 이상 미래를 정의하지 않음
          + 증기 기관차에 대한 관심은 과거와 미래를 구분하는 것과 같음
          + 웹의 과거를 되찾는 것은 다른 판단임
          + indieweb.org는 많은 가치와 원칙을 가지고 있음
     * IndieWeb이 아직 주류가 되지 않은 문제는 기업 웹의 존재 때문임
          + 90년대에는 HTML로 웹사이트를 만들고 사람들이 이를 발견할 수 있었음
          + 현재는 기업 웹의 존재로 인해 일반 사용자가 IndieWeb을 발견하기 어려움
          + IndieWeb의 예술적 가치를 인정받을 수 있지만, 비즈니스적으로는 의미가 없음
     * 많은 사람들이 기술과 관련된 활동에 참여하지 않는 이유는 기술적 취미이기 때문임
          + 독립적인 웹이 사람들에게 실질적인 가치를 제공하는 방법에 대한 의문
          + 대형 플랫폼에서 디지털 존재를 유지하고 성장시키는 것이 더 쉬움
     * IndieWeb은 주류가 되지 않아도 지속적인 영향을 원함
          + IndieWeb의 원칙은 잘 알려진 프로토콜과 시스템을 거부하는 경향이 있음
          + 작은 것을 가치 있게 여기지만, 주류 프로토콜을 사용하는 것을 포기함
     * IndieWeb은 아름답지만 좌절감을 줌
          + 20년 동안 온라인 글쓰기를 해왔고, 현재 사이트는 10년 됨
          + IndieWeb의 일원이지만, 설정 과정이 복잡하여 매번 겁을 먹음
     * IndieWeb이 주류가 되지 않은 것이 중요함
          + 대중적인 채택은 IndieWeb의 본질을 훼손할 수 있음
          + 인터넷에서 자신의 공간을 소유하고자 하는 사람들을 위한 것임
     * IndieWeb은 ""기업 웹""에 대한 대안임
          + 독립적이고 개인적인 웹사이트 커뮤니티로, 자신의 도메인을 소유하고 이를 주요 온라인 정체성으로 사용함
     * IndieWeb 운동은 항상 존재해왔음
          + 웹 브라우저를 열지 않고 앱에서만 온라인 생활을 하는 세대가 존재함
     * IndieWeb은 자신을 위한 글쓰기에 집중함
          + 자신이 읽고 싶은 것을 쓰고, 생각을 명확히 하는 이점을 얻음
          + 모든 글이 바이럴되지 않아도 괜찮음
          + POSSE(자신의 사이트에 게시하고, 모든 곳에 배포) 전략을 사용함
"
"https://news.hada.io/topic?id=19914","내가 아는 최악의 프로그래머 (2023)","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         내가 아는 최악의 프로그래머 (2023)

     * 이 글은 팀의 생산성을 측정하려는 시도가 어떻게 실패했는지 설명함
     * 개인 평가 및 개발 목적으로 개인 성과 지표 도입을 결정
          + 코드 라인 수나 버그 수는 조작 가능성이 높아 배제하고, 대신 스토리 포인트 또는 전달된 스토리 수로 성과를 측정하기로 함

Tim Mackinnon의 성과는 ‘0’

     * 팀의 생산성 측정 도구(Jira 등)를 통해 모든 팀원의 성과를 측정
     * Tim의 성과 점수는 0 → 스토리 포인트를 하나도 기록하지 않았기 때문
     * 매니저는 Tim의 성과가 0이므로 Tim을 교체할 것을 요구

Tim Mackinnon이 성과를 내지 못한 이유

     * Tim은 스토리를 직접 담당하지 않았음
     * 대신 팀원들과 페어 프로그래밍에 집중
          + 경험이 적은 개발자와 함께 작업하며 문제 해결을 유도
          + 직접 해결하지 않고 질문을 통해 해결책 도출을 도와줌
          + 시니어 개발자와는 문제를 함께 고민하고 해결책 개선
     * Tim은 직접 코드를 작성하지 않았지만 팀의 전반적인 성과를 향상시킴

Tim Mackinnon의 진정한 기여

     * Tim의 기여는 개인 성과 점수로 측정할 수 없음
     * Tim 덕분에 팀 전체의 생산성 및 코드 품질이 향상됨
     * Tim이 함께 작업하면 더 빠르고, 더 좋은 결과를 얻을 수 있었음

팀 생산성으로 평가 방식 변경

     * 매니저에게 Tim의 기여도를 설명하고 관찰 기회를 제공
     * 팀 전체의 성과가 향상됨을 확인한 후 개별 성과 측정 방식을 포기
     * 개인 성과가 아닌 팀 성과 및 비즈니스 영향으로 평가 방식 전환

요약 (tl;dr)

     * 생산성을 비즈니스 성과(예: 비용 절감, 수익 창출 등)로 측정해야 함
     * 복잡한 시스템에서 개별 성과 측정은 의미 없음
     * DORA Metrics 등은 시스템 성과를 측정하는 도구이지 개별 기여도 측정 도구가 아님
     * Tim Mackinnon과 함께 일할 기회가 있다면 놓치지 말 것

   사실 시니어를 넘어서 스태프 엔지니어 쯤 가면, 점점 필드에 배포 되는 코드와는 점점 멀어지고.... 대신 시니어/주니어 대상으로 코칭을 더 많이 하게 되는 것 같습니다. 매니저들 하소연도 들어줘야 되고.... 문제 터지면 여기저기 불려가서 솔루션 제시해야 하고....

   하는 일이 이런 식인데 지라 티겟과 점수도 정량화하는게 불가능하죠.

   깃허브 코파일럿 같은 분이시군요....

        Hacker News 의견

     * 개인 개발자의 생산성을 측정하는 것은 터무니없음. 코드 라인이나 스토리 포인트 측정은 생산성의 반대임. 개발자가 더 적은 코드로 더 많은 가치를 창출하는 것이 중요함
          + 비즈니스 결과를 측정하는 것이 중요하지만 특정 개발자에게 귀속시키기 어려움
          + 결국 주관적인 판단에 의존할 수밖에 없음을 인정하는 것이 더 나음
     * Tim의 이름을 티켓에 붙여 문제를 해결하는 방법을 발견함. 팀원들이 기꺼이 도와줄 것임
          + 생산성 지표가 완전히 무가치한 것은 아님. 팀 내에서 PR과 Jira 티켓의 비율을 보면 팀 리더를 추측할 수 있음
     * Tim이 팀에 남아있고 프로세스를 올바른 방향으로 이끌어 기쁨. 경청하는 관리자가 필요함
          + OKR로 인해 개발자들이 고립됨. 팀 기반이 아닌 개인 기반의 OKR은 문제를 초래함
          + 문제 해결에 시간이 오래 걸림. OKR 때문에 도움을 받을 수 없었음
     * 한 프로그래머가 개인 작업 없이 모든 도움을 주는 모델은 이상함
          + Tim이 다른 사람들과 같이 스토리를 수행하고, 도움이 필요할 때 그룹에 요청하는 것이 더 건강한 상황임
          + 팀이 매우 불균형하다면 Tim은 멘토 역할을 해야 함
     * Tim이 개인 작업을 하지 않는 것이 이상함. 팀 생산성을 극대화하려면 개인 기여와 팀 협업의 균형이 필요함
          + Tim이 너무 인내심이 많아 시간을 낭비했을 수 있음
     * Tim이 팀에 기여하지 않으면 일을 시작하고 스토리를 전달하라고 할 것임. Tim이 다른 사람을 도와주는 것은 좋지만, 자신의 작업도 해야 함
     * 모든 것이 그룹 활동이 될 필요는 없음. 평균적인 개발자가 Tim의 지속적인 도움 없이 기능을 제공할 수 없다면 팀에 문제가 있음
          + 소프트웨어 개발은 개인 작업과 그룹 작업 모두에 시간이 필요함
     * 최고의 팀은 항상 Tim과 같은 사람이 있음. Tim의 도움은 다른 사람들에게 전파되어 팀 전체가 성장함
          + 개발자가 막히면 스스로 해결하려고 노력하고, 필요한 경우 도움을 요청함
     * 스토리 포인트로 개발자 생산성을 측정하는 것은 좋지 않음. Zero라는 개발자는 스토리를 할당받지 않고 팀을 도왔음
          + 관리자는 Zero의 중요성을 이해하고 있었음. Zero가 없을 때 중요한 릴리스를 미루기도 했음
     * 지원의 가치를 정량화하는 것은 어려움. 하지만 지원은 필수적임. 리더들이 올바르게 판단할 수 있도록 신뢰해야 함

   테크 리드로 이러한 작업을 꽤 많이하고 있습니다. 스토리 포인트 기반 정량화를 시도하는 것도 비슷한데, 다행히 회사가 크지 않아서 임원을 비롯한 구성원들이 제가 어떤 역할을 하는지 인지를 해주고 계셔서 당장은 문제가 발생하지 않는 것 같네요.
   조직이 커지면 정량화 방법도 고민을 해봐야겠네요.

   어디서 본 이야기다 싶었는데..2023년 글이군요
   2년전에 동일한 글이 올라왔었네요 https://news.hada.io/topic?id=10680
"
"https://news.hada.io/topic?id=19965","일본 과학자들, 척수 손상 치료를 위한 줄기세포 임상 실험","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    일본 과학자들, 척수 손상 치료를 위한 줄기세포 임상 실험

     * 일본 Keio University 연구진이 세계 최초로 iPS 줄기세포를 이용한 척수 손상 치료 임상 시험을 실시함
     * 중증 척수 손상으로 인한 마비에 대해 현재까지 효과적인 치료법이 없는 상황임
     * 일본에서는 척수 손상 환자가 약 15만 명 이상 존재하며, 매년 5,000명 이상의 신규 환자가 발생함

iPS 세포 기술의 적용과 실험 개요

     * 사용된 줄기세포는 iPS (induced pluripotent stem cells)로, 성숙한 세포를 미성숙 상태로 되돌린 후 필요한 세포로 분화시킨 것임
     * Keio University는 iPS 세포로부터 유도된 신경 줄기세포를 사용함
     * 총 200만 개 이상의 세포를 손상된 척수에 이식하는 수술을 진행함
     * 연구의 주요 목적은 줄기세포 이식의 안전성을 검증하는 것임

초기 임상 결과와 회복 사례

     * 실험에 참여한 4명의 환자 중 2명은 운동 기능 점수가 개선되는 결과를 보였음
     * 심각한 부작용은 4명 모두에게서 나타나지 않았으며, 1년간의 모니터링을 통해 안전성이 확인됨
     * NHK에 따르면 그 중 한 명은 사고로 척수 손상을 입은 고령 남성이며, 현재는 지지대 없이 설 수 있고 걷는 연습을 시작함

향후 계획과 연구 방향

     * 연구 책임자인 Hideyuki Okano 교수는 세계 최초의 iPS 기반 척수 치료에서 의미 있는 결과를 얻었다고 밝힘
     * 향후 보다 본격적인 임상 시험으로 확장할 계획이며, 환자 치료로 이어지길 기대하고 있음
     * 초기 연구는 2019년에 정부 승인을 받았고, 첫 수술은 2022년에 진행됨
     * 연구진은 수술 전 14~28일 이내에 손상을 입은 환자들을 중점 대상으로 함
     * 이식되는 세포 수는 동물 실험을 통해 안전성을 검토한 결과에 기반하여 결정됨
"
"https://news.hada.io/topic?id=19934","Openspot - LinkedIn이 별로라서 더 나은 것을 개발해 봤어요","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Openspot - LinkedIn이 별로라서 더 나은 것을 개발해 봤어요

     * Openspot은 구직 및 네트워킹을 강화하는 현대적인 프로필을 제공하는 플랫폼
     * 기존의 이력서보다 더 많은 정보를 제공하며, 의미 있는 연결을 형성하고 인터뷰를 유도하도록 설계

차별화된 기능

     * 멀티미디어 요소: 비디오, 오디오, 글 형식을 사용하여 프로필을 생동감 있게 표현할 수 있음.
     * 개인화된 콘텐츠 공간: 개인의 통찰력과 독특한 관점을 공유하고 성격을 강조할 수 있는 페이지 제공.
     * AI 챗봇: 필요한 사람과 연결할 수 있도록 돕는 AI 챗봇 기능 포함.

프로필 분석 및 연결

     * 상세한 프로필 분석: 전략적이고 세부적인 프로필 분석을 통해 의미 있는 행동을 유도할 수 있음.
     * 고용주와의 연결: Openspot을 통해 고용주에게 발견되거나, 지원서와 메시지에 프로필을 공유하여 더 많은 인터뷰 기회를 얻을 수 있음.

        Hacker News 의견

     * 이력서 사이트에 사진이 왜 그렇게 prominently 있는지 의문임. Tinder가 아님
          + 미국 HR은 이력서에 사진을 첨부한 경우 이를 버리곤 했음. (보통 최근 이민자가 미국 관습을 모르는 경우였음)
          + 일부 회사나 스크리너는 사진이나 불필요한 정보를 포함한 이력서를 버리는 정책이 있었다는 소문도 들었음
          + ""LinkedIn이 하니까""라는 이유는 좋지 않음. LinkedIn은 별로임. 다만 대부분의 사람들이 사용하고, 가끔 리크루터들이 검색하거나 스팸을 보내는 곳임
          + 일부 소셜 미디어 사이트는 최악의 상황에 맞추어 사진을 사용함. 한 유명한 소셜 미디어 사이트의 경우, 원래 영감이 대학에서 가장 잘생긴 여성을 카탈로그화하는 것이었음
          + 모델이나 배우를 위한 헤드샷 사이트/앱이 아니라면, 사람의 성격을 중시하는 것이 좋음
     * polywork.com 기억하는 사람 있음?
          + 그들의 슬로건은 ""Your professional network""였음
          + 2025년 초에 문을 닫음
          + LinkedIn은 별로임
          + 그 말을 철회함
          + 확실히 별로임 (내 경우에는 피드에 비전문적인 게시물, 밈, 정치적 발언, 재미있는 사진 등이 있어서 별로임)
          + 하지만 좋은 점도 있음
          + 가장 중요한 것은 네트워크 효과가 있음
          + 모든 사람들이 LinkedIn에 있음
          + 인터뷰할 때, 후보자의 LinkedIn 프로필을 확인하곤 했음 (많은 경우 인터뷰 후 피드백 양식에 좋은 말을 남기기 위해)
          + 그럼에도 불구하고 OpenSpot에 행운을 빔
     * 자신을 촬영하고 싶지 않음. 온라인에 사진을 올리고 싶지 않음. 내 작업이 말해주어야 함
          + 사실, 플랫폼이 잘못되었음. 시각적 판매에 초점을 맞추는 것은 이력서에 사진을 포함하는 것과 같은 편견임. LinkedIn보다 나아지지 않음
          + 주로 텍스트만 있는 플랫폼을 만들고, 시각적 쇼케이스는 자신이 한 일에만 국한해야 함. 모든 비객관적인 것은 제거해야 함. 그런 다음 한 번의 클릭으로 모든 것이 채워지도록 직업에 지원하는 훅을 만들어야 함
     * OP와 직접 관련은 없지만, LinkedIn이 추천하는 모든 ""Suggested"" 게시물에 화가 난다면, 다음 ublock 필터를 사용하여 이러한 게시물을 제거할 수 있음
          + www.linkedin.com##:xpath(//span[text()=""Suggested""]//ancestor::div/div[contains(@data-id, ""activity"")])
          + 실제로 팔로우하는 사람을 신중하게 관리하면 훨씬 더 쾌적한 경험이 됨
     * 행운을 빔. 2년 동안 이것을 만들고 싶었지만, 그것을 제대로 할 시간이나 열정이 없음
          + 목표가 많이 겹침
          + <a href=""https://huntr.co"" rel=""nofollow"">https://huntr.co</a>를 보지 않았다면, 그들이 구직 관리를 돕는 데 훌륭한 일을 하고 있다고 생각함
          + 소셜 피드는 LinkedIn의 약점이라고 생각함. 회사에 나쁜 인센티브를 만듦. 피드가 유용했다면 훨씬 더 많이 사용할 것임. LinkedIn Learning도 기본 입문 과정에 더 집중되어 있음
          + 사람들에게 실제로 어려운 주제를 논의할 수 있는 가치 있는 네트워크를 구축하도록 돕는 것이 좋음. 몇몇 회사가 의미 있고 지적인 토론과 공유를 보장하려고 노력하는 소규모 독점 그룹을 만들려고 시도한 것을 봄
          + LinkedIn은 한때 네트워크를 제한하려고 했는데, 여전히 그것이 올바른 방법이라고 생각함
          + 인기 있는 마케팅 기법은 ""Anti"" 회사가 되는 것임. Anti-LinkedIn을 성공적으로 만들 수 있기를 바람. 그에 대한 카피라이팅은 저절로 써질 것임
          + 리크루팅에 대한 한 가지 더. LinkedIn은 할당량을 채우려고 하는 끔찍한 리크루터들로 악명 높음. 리크루터가 사람들에게 메시지를 보내는 데 제한이 필요하거나 어떤 종류의 순위 시스템이 필요할지 모름
     * LinkedIn의 추천을 실제로 끌 수 있음: <a href=""https://lnkd.in/gQHsR8ps"">https://lnkd.in/gQHsR8ps</a>;
          + ""가장 최근 게시물""로 변경하면 피드에서 무작위 인플루언서가 ""vibe coding이 미래다""라고 말하는 것을 멈출 수 있음
     * 기술 분야에서 돋보이는 가장 좋은 방법은 개인 기술 블로그임. 작업한 것에 대해 글을 쓰는 것임. 하는 것이 배우는 가장 좋은 방법이고, 하는 것에 대해 글을 쓰는 것이 아는 것을 보여주는 두 번째로 좋은 방법임 (첫 번째는 데모임)
          + LinkedIn 피드 문제는 피드를 보지 않으면 해결됨
     * LinkedIn을 싫어하는 이유는 명확한 경력 경로가 없었기 때문임. 지원하는 곳에 맞춰 이력서를 다시 작성함. 일반적으로 이전 직업의 모든 설명을 제거하고 지원할 때마다 맞춤형 버전으로 업데이트함
          + 그것을 고칠 방법이 있다고 생각하지 않음. 우리 같은 사람이 충분하지 않거나 우리를 고용하려는 사람이 충분하지 않기 때문임
          + 스팸 피드나 인플루언서와는 무관하게 LinkedIn을 싫어하는 이유 중 하나로 강조하고 싶음
     * 빠른 피드백/첫인상
          + 알고리즘 피드의 한 가지 이점은 다른 사람들이 실제로 사이트를 사용하고 있다는 사회적 증거로 작용함. 사이트에 피드가 없기 때문에, 사람들이 실제로 사용하는 살아있는 웹사이트라는 것을 빨리 보여줄 방법이 필요함. 그렇지 않으면 공허 속으로 외치는 것처럼 느껴짐
          + 피드의 또 다른 이점은 내 활동과 업데이트가 다른 사람들에게 어떻게 보일지를 즉시 볼 수 있다는 것임. 온보딩 중에 다른 사람들이 내 프로필과 활동을 어떻게 볼지 명확하지 않음. 다른 사용자가 내 프로필을 볼 수 있는지, 아니면 특정 채용 관리자만 볼 수 있는지 명확하지 않음. 채용 관리자가 아닌 다른 사용자와 상호작용할 수 있는지조차 명확하지 않음
          + 다음으로, 이력서를 가져오고 프로필을 설정한 후, AI 지원으로 어떤 기사나 에세이를 작성하라는 요청을 받음. 이 단계는 명확하지 않았지만, 명확하더라도 사이트를 처음 사용하는 사람에게는 큰 부담임. 첫 번째 요청은 훨씬 덜 야심 찬 것이어야 하고, 숙제처럼 느껴지지 않도록 게임화가 필요할 것임
          + 마지막으로, 연결할 사람을 찾기 위해 탐색 버튼을 클릭함. 관심 있는 인물에 대한 자세한 설명을 봇에게 제공했지만 ""일치하는 후보자를 찾을 수 없음"" 메시지를 받음. 적어도 무언가를 보여주어야 함. 특히 정규 검색/수동 탐색을 할 수 없을 때 -- 더 나은 쿼리를 제안해야 함
          + 어쨌든, MVP라는 것을 알고 있으며, 몇 가지 질문에 대한 답변을 사이트의 정보 페이지에서 보았지만, 생각할 거리로 제공함. 전체적인 온보딩은 매끄러웠고 이력서 가져오기 경험을 높이 평가함. 강력한 시각적 정체성을 가지고 있다고 생각함. 이 사이트가 어디로 가는지 궁금함
     * 글꼴이 많음. runway ml과 유사한 디자인처럼 보임. 돋보이려는 사이트가 돋보이지 못함. 매우 깔끔하고 정돈되어 보임
"
"https://news.hada.io/topic?id=19919","신경기호 프로그래밍 언어 Scallop","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         신경기호 프로그래밍 언어 Scallop

     * Scallop 소개
          + Scallop은 AI 응용 프로그램에서 풍부한 상징적 추론을 지원하기 위해 설계된 선언적 언어임.
          + Datalog에 기반하여 관계형 데이터베이스를 위한 논리 규칙 기반 쿼리 언어임.
     * Solver
          + Scallop은 확장 가능한 Datalog 솔버로, 이산적, 확률적, 미분 가능한 추론 모드를 지원함.
          + 다양한 AI 응용 프로그램의 요구에 맞게 모드를 구성할 수 있음.
     * Framework
          + Scallop은 Python 프로그램 내에서 논리 추론 모듈을 지원하는 바인딩을 제공함.
          + PyTorch 머신러닝 파이프라인과 깊이 통합할 수 있음.
     * 다양한 응용 분야
          + Scallop은 비전 및 자연어 처리(NLP)에서 상징적 추론을 포함하는 다양한 응용 프로그램을 개발하는 데 사용될 수 있음.
          + 논리 규칙을 통해 추론 구성 요소를 지정하고, 이를 컨볼루션 신경망 및 트랜스포머와 같은 머신러닝 모델과 깊이 통합할 수 있음.
     * CLEVR, 조합적 언어 및 기본 시각적 추론
          + 이 작업은 주어진 이미지에서 간단한 3D 객체에 대한 추론을 통해 ""몇 개의 객체가 파란색으로 색칠되어 있는가?""와 같은 질문에 답하는 것과 관련됨.
          + Scallop을 사용하여 이미지의 상징적 표현을 생성하는 신경 구성 요소와 질문을 표현하는 프로그래밍 쿼리를 사용함.
          + 추론 구성 요소는 지정된 속성을 가진 객체를 선택, 비교, 계산하는 다양한 작업을 지정함.
     * Pathfinder, 장거리 연결성 추론
          + 이 작업에서는 두 점과 대시 선이 포함된 흑백 이미지를 제공받음.
          + 목표는 두 점이 대시 선으로 연결되어 있는지를 결정하는 것임.
          + Scallop을 사용하여 간단한 신경 아키텍처와 논리 규칙을 통해 이 작업을 몇 줄의 코드로 프로그래밍할 수 있으며, 최신 트랜스포머보다 뛰어난 성능을 보임.
     * 손으로 쓴 수식 평가
          + 이 작업에서는 0부터 9까지의 숫자와 간단한 산술 연산을 포함하는 손으로 쓴 기호의 시퀀스를 제공받음.
          + 목표는 수식을 인식하고 표현식을 평가하는 것임.
          + Scallop을 사용하여 확률적 입력을 구문 분석할 수 있는 전체 문맥 자유 문법 파서를 작성할 수 있음.
          + 신경 모델과 함께 훈련하여 가장 가능성이 높은 수식을 자동으로 찾아 평가된 결과를 반환함.
"
"https://news.hada.io/topic?id=19898","Konva.js - JavaScript Canvas 2D 라이브러리","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Konva.js - JavaScript Canvas 2D 라이브러리

     * HTML5 Canvas 기반의 JavaScript 프레임워크로 고성능 애니메이션, 트랜지션, 노드 중첩, 레이어링, 필터링, 캐싱, 이벤트 처리 등을 지원
     * 데스크탑 및 모바일 기기에서 일관된 경험과 성능 제공
     * 다양한 도형을 지원하는 객체 지향 방식의 API
     * 수천 개의 도형을 독립적으로 이동, 크기 조정, 회전 가능
     * 노드 중첩, 그룹화, 이벤트 버블링 등 복잡한 계층 구조와 효율적인 이벤트 처리
     * 내장된 애니메이션 및 트윈(Tween) 기능으로 매끄럽고 동적인 효과 구현
     * Canvas 작업 결과를 고해상도 Data URL, 이미지 데이터 또는 객체 형태로 저장 가능
     * 직관적인 드래그 앤 드롭 기능 구현 가능
     * React, Vue, Svelte 등 웹 프레임워크와 통합 지원
     * KineticJS의 GitHub 포크에서 시작됨

   여러 도형의 결합이 가능하지만 복합도형은 회전을 시킬 때 중심점이 생각과 다른 위치에 생겨서 제자리에서 각도 트는 걸 구현하기가 아려움

   데모 보려고 홈페이지 가봤는데 가격탭이 있어서 눌러보니 뮤직비디오가 나오네요 ㅋㅋ

   저랑 똑같은 경험을 ㅋㅋ
   ”포기하지마“아니 뭔 생각일까요…

   Rick Rolled 라는 밈입니다. Never Gonna Give You Up 이라는 곡의 링크를 타게 해 사람들을 낚는 해외 밈인데, 무료 오픈 소스라서 사람들을 낚으려고 이런 것 같습니다ㅋㅋ
"
"https://news.hada.io/topic?id=19966","Search My Site – 개인 및 독립 웹사이트를 위한 오픈소스 검색 엔진","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Search My Site – 개인 및 독립 웹사이트를 위한 오픈소스 검색 엔진

     * ""indieweb"", ""small web"", ""digital gardens""와 같은 비상업적 콘텐츠에 초점을 맞춘 틈새 검색 엔진임
     * 주로 개인 및 독립 웹사이트를 대상으로 하며, 광고 없이 사용자 경험을 중시함
     * 개인의 경험이나 특정 주제, 취미, 관심사에 대한 깊이 있는 정보를 찾고자 할 때 유용함
     * 대형 검색 엔진의 마케팅 웹사이트와 블로그 스팸을 피할 수 있음
     * 주요 특징
          + 사용자 제출 및 검토된 사이트만 색인화하여 스팸, ""검색 엔진 최적화"", ""클릭 유도"" 콘텐츠를 배제함
          + 광고를 표시하지 않으며, 광고 없는 결과 페이지를 홍보하여 스팸과 감시 자본주의의 유인을 제거함
          + 광고에 의존하지 않고 ""검색 서비스"" 기능을 통해 운영 비용을 충당하여 사용자와의 충돌을 피함
          + 광고나 개인 정보 수집에 기반하지 않은 운영 모델 덕분에 높은 수준의 개인정보 보호를 제공함
          + 완전한 오픈 소스로 검색, 순위 및 색인화 과정의 투명성을 높이고, 서비스 개선에 대한 커뮤니티 참여를 장려함

        Hacker News 의견

     * Wiby 검색 엔진은 초기 인터넷 시절의 웹 페이지를 구축하는 것을 목표로 함
          + 페이지는 단순한 디자인이어야 하며, 단순 HTML과 비상업적 사이트가 선호됨
          + 페이지는 외관 효과를 위한 스크립트나 CSS를 많이 사용하지 않아야 함
          + 콘텐츠 위에 나타나는 광고와 같은 방해가 되는 광고는 사용하지 않아야 함
          + 다른 과도한 웹사이트로의 포털 역할을 주로 하는 페이지는 제출하지 말아야 함
     * Marginalia는 이전에 여러 번 HN에 소개된 적이 있음
     * 다른 사이트들:
          + nownownow.com
          + omg.lol
          + indieweb.org
          + ooh.directory
          + neocities.org
          + aboutideasnow.com
          + indieblog.page
          + wiby.me
          + 80.style
     * 일반적으로 인터넷을 크롤링하여 페이지를 찾고, 결과는 GitHub의 Internet-Places-Database에 있음. 개인 페이지는 ""personal"" 태그로 태그됨
     * pagefind.app의 단순함을 좋아함
     * 이 프로젝트를 만들어줘서 고마움. Postgres가 개인 웹사이트 검색 도구로는 큰 DB일지 궁금함. 시도해볼 것임. 이런 도구가 더 필요함
     * 이 프로젝트가 마음에 듦. 웹을 처음 위대하게 만든 바로 그 종류의 무작위적이지만 고려된 개인 웹사이트에 한 시간을 잃었음
     * 이런 종류의 프로젝트는 흥미로운 블로그와 잘 알려지지 않은 사이트를 찾기에 좋음. 나의 선택은 marginalia-search.com임
     * 이 프로젝트를 보게 되어 기쁨. 아이러니하게도, 지난 10년간 Google의 강력한 지배력에도 불구하고, AI 분야의 큰 승자는 백엔드 검색 엔진이 될 것이라고 강하게 느낌. 현대 웹 검색은 너무 많은 트릭으로 오염되어 Google의 첫 페이지에 도달하기 위해 많은 좋은 콘텐츠가 사라짐. 이제 많은 대형 모델이 웹에 호출할 수 있게 되면서, 이 과도함이 AI 검색에도 나타나고 있음. 광고 없이, 프레젠테이션보다 구조화된 데이터에 더 집중하는 적절한 데이터 중심 엔진이 필요함
     * 약간 혼란스러움. Solr가 검색 엔진임. LLM 모델이 로드됨. LLM 모델이 솔루션에 무엇을 추가하는지 궁금함
     * greppr.org를 추천함 (참고: 내가 구축함)
"
"https://news.hada.io/topic?id=19982","WebJSX - JSX와 웹 컴포넌트 기반 초경량 웹 프레임워크","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  WebJSX - JSX와 웹 컴포넌트 기반 초경량 웹 프레임워크

     * JSX와 Web Components 기반, 두 개의 핵심 함수만으로 가상 DOM을 다루고 실 DOM에 반영 가능한 매우 단순한 아키텍처
          + createElement: JSX로 작성된 가상 DOM 생성
          + applyDiff: 가상 DOM과 실제 DOM을 비교하여 효율적으로 변경 사항 반영
     * 완전한 JSX 지원
     * Web Component와의 자연스러운 통합
     * HTML 표준 이벤트 속성을 이용한 간단한 이벤트 처리
     * Fragment (<>...</>) 사용 가능
     * 렌더링 일시 중지/재개 기능 : webjsx_suspendRendering , webjsx_resumeRendering
     * 번들링이 꼭 필요하지는 않음 – 모던 브라우저에서 직접 모듈 사용 가능
     * 간결한 라우팅 라이브러리(webjsx-router) 제공
"
"https://news.hada.io/topic?id=19904","텐센트 Hunyuan-T1 - 최초의 Mamba 아키텍처 기반 초대형 모델","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               텐센트 Hunyuan-T1 - 최초의 Mamba 아키텍처 기반 초대형 모델

     * Hunyuan-T1은 TurboS 기반의 초대형 Hybrid-Transformer-Mamba MoE 모델
     * 대규모 후처리 학습을 통해 인간의 선호도에 맞춰 추론 능력을 확장하고 성능을 향상
     * TurboS의 장문 텍스트 처리 능력 으로 문맥 손실 및 장거리 정보 의존 문제 해결
     * Mamba 아키텍처 는 장문 시퀀스 처리를 최적화하여 효율적인 계산 방식으로 긴 텍스트 정보 캡처 가능
          + 동일한 배포 조건에서 디코딩 속도 2배 향상
     * 모델의 사후 훈련 단계에서 전체 컴퓨팅 파워의 96.7% 를 강화 학습에 투자
          + 수학, 논리 추론, 과학, 코드 등 다양한 문제를 포함한 데이터 세트를 수집하여 모델의 추론 능력을 강화
          + 정답 피드백 및 실시간 사용자 피드백을 통해 모델 성능 강화
          + 커리큘럼 학습 방식 적용
               o 데이터 난이도를 점진적으로 증가시키며 모델의 문맥 길이 확장
               o 토큰 효율적 사용 능력 강화
     * 강화 학습 전략 : 데이터 재학습 및 정책 재설정 전략 적용 → 훈련 안정성 50% 이상 개선
     * 보상 시스템
          + 자가 보상 방식 채택 → 모델 출력을 자체 평가 및 점수화
          + 포괄적인 보상 체계 적용 → 모델의 정보 효율성 및 콘텐츠 세부 사항 강화

벤치마크 성능 평가

     * MMLU-pro, CEval, AIME, Zebra Logic 등 중국 및 영어 추론 지표에서 우수한 성능
     * DeepSeek R1과 동급 성능 또는 약간 더 나은 결과
          + 문화적 창의성, 텍스트 요약, 에이전트 능력에서 우위 확보
     * MMLU-PRO 평가에서 87.2점 획득 → 인문학, 사회과학, 과학기술 등 14개 분야에서 우수한 메모리 및 이해력 입증
     * GPQA-diamond 평가에서 69.3점 기록 → 박사 수준의 물리학, 화학, 생물학 문제 해결 능력 확인
     * 코드, 수학, 논리 추론 등 강력한 성능 입증
          + LiveCodeBench에서 64.9점 획득 → 코드 작성 및 이해 능력 확인
          + MATH-500에서 96.2점 → DeepSeek R1에 근접한 수학 문제 해결 능력 입증
     * ArenaHard에서 91.9점 획득 → 다양한 정렬 작업, 지시 따르기 작업, 도구 활용 작업에서 강력한 적응력을 보여줌

        Hacker News 의견

     * 모델의 뛰어난 성능은 강화 학습이 최적화 과정에서 중요한 역할을 한다는 것을 완전히 증명함
          + 만약 이 강화 학습이 다른 곳에서 더 나은 답을 제공하지 않고 벤치마크만 조작하는 것이라면, 우리는 그것을 어떻게 알아차릴 수 있을까 하는 의문이 제기됨
     * 이 모델을 조금 사용해본 결과, 영어 질문에 중국어로 답변하는 경향이 있는 것 같음
     * 그들의 대형 모델은 389b 파라미터였는데, 초대형 모델은 얼마나 큰지 궁금함
     * 요즘 너무 많은 모델들이 나오고 AI 분야에서 많은 발전이 이루어지고 있어 따라가기가 어려움
          + 실제로 획기적이거나 중요한 것이 무엇인지 확신할 수 없음
     * Mamba 기반 모델이 잘 작동하는 것을 보는 것이 흥미로움
     * 이러한 이름의 로마자 표기가 항상 혼란스러움
          + 문자와 음조가 제거되면 그냥 의미 없는 글자가 됨
          + ""Hunyuan"" 또는 중국어로 混元은 ""원시 혼돈"" 또는 ""원초적 통일""을 의미함
          + 이는 더 많은 중국 제품과 서비스가 시장에 출시되면서 기억하기 쉽게 도와줌
          + 서양 제품에서 그리스 신화의 인기가 있는 것과 유사함 (예: ""Apollo""라는 이름의 모든 제품)
     * Huggingface 데모에 연결하고 있다는 사실이 가중치를 공개할 것임을 암시하는지 궁금함
     * Kobe?
"
"https://news.hada.io/topic?id=19935","Show HN: 저의 iOS용 초견(Sight Reading) 앱이 출시 10주년이 되었어요 ","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Show HN: 저의 iOS용 초견(Sight Reading) 앱이 출시 10주년이 되었어요

     * Notes - Sight Reading Trainer는 음악 초견(악보를 보고 연주하기)를 마스터하기 위한 iOS 앱
     * 초보자와 경험 많은 음악가 모두에게 적합하며, 악기와 음악을 배우고자 하는 사람들에게 유용함
     * 피아노를 사용하여 노래를 조율하는 방법을 배울 수 있음
     * 무료이며 광고 없음. 인앱 결제가 있지만, 대부분의 기능에서 필요없음

        Hacker News 의견

     * 나는 대상 사용자는 아니지만 iOS 개발자로서 말하자면, 당신의 앱은 ASO(App Store Optimization) 의 꿈임
          + 멋진 로고
          + 명확하고 매력적인 스크린샷
          + 관련 키워드가 포함된 탄탄한 제목/부제목
          + 놀라운 리뷰와 평점
          + 정말 잘 만들어짐
     * 이 앱은 내 필요에 딱 맞음. 성인으로서 3년 전 피아노를 배우기 시작했는데, 가장 큰 어려움은 악보 읽기임. 연습하고 싶지만 게으른 편이라 도구를 찾으려 했으나 이 앱을 찾지 못했음
          + 구매 전에 작은 질문이 있음: 마이크 기능을 잠금 해제하려고 하는데, 앱이 마이크를 통해 도, 레, 미를 이해하는지 궁금함
          + 작업에 감사함
     * 멋짐! 나는 음악가는 아니지만, 시간이 지나도 초점을 잃지 않는 앱에 감명받음. 왜 Apple이 이런 종류의 앱을 위한 공간을 마련하지 않는지 궁금함; 최신 앱의 반대임
     * 감사합니다, 이 앱을 사랑함
     * 안녕하세요, Notequest를 사용해왔고 이 앱이 내 필요에 딱 맞음. 개선할 수 있는 부분이 있음
         1. 노트에 논리가 부족함. LLM이 더 나은 소리를 만들 수 있는 패턴을 생성해야 함. 예를 들어, 왼손은 보통 워킹 베이스/코드 진행 등이 있을 수 있음
               o 아이디어와 도움이 필요하면 (myhackernewsname_at_gmail_dot_com)으로 연락 가능함. 도와줄 의향이 있음
         2. 현재 게임은 가능한 빨리 노트를 누르는 것임. 대신 음악가는 적절한 타이밍에 노트를 누르는 연습이 필요함. 메트로놈 + 제 시간에 노트를 누르는 모드를 만들면 현재 버전보다 더 유용할 것임
     * 사실 이걸 찾고 있었음. 다운로드했고 곧 시도해볼 예정임 :)
     * 시도해보고 있으며, 사랑함! 질문 하나 해도 될까? 적어도 15년 동안 피아노를 치지 않았는데, 왜 C,D,E 등을 사용하고 있는지 궁금함. 도, 레, 미 등을 활성화할 수 있는 옵션을 찾았지만, 피아노 노트에만 적용되고 중간 화면의 ""노트""에는 적용되지 않음
          + 내가 뭔가 놓치고 있는 건가?
     * 정말 멋짐! 호기심에 이 앱 개발에 얼마나 걸렸는지, 과정이 어땠는지 궁금함
     * 감사합니다, 다운로드해서 시도해보고 즉시 구매했음 - 훌륭한 앱임! 수년간 피아노로 ""Für Elise""를 연주했지만, 악보 읽는 법을 잊어버렸고 다시 시작하는 방법을 몰랐음. Synthesia가 도움이 될 것이라 생각했지만 특정 부분에서 어려움을 겪었음. 반복과 점수 기반 학습이 많은 도움이 될 것임
     * 몇 년 동안 사용해왔으며, 인생 후반에 베이스 클레프를 접한 나에게 딱 맞는 앱임

   ASO의 꿈이라는 댓글이 인상적이네요.
"
"https://news.hada.io/topic?id=19892","기계 학습에서의 Pen and Paper 연습 (2022)","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    기계 학습에서의 Pen and Paper 연습 (2022)

컴퓨터 과학 > 머신러닝

     * 펜과 종이로 하는 머신러닝 연습 문제
          + Michael U. Gutmann이 작성한 이 문서는 주로 펜과 종이로 해결할 수 있는 머신러닝 연습 문제 모음임.
          + 다루는 주제는 선형대수, 최적화, 방향성 그래프 모델, 비방향성 그래프 모델, 그래프 모델의 표현력, 팩터 그래프와 메시지 전달, 숨겨진 마르코프 모델에 대한 추론, 모델 기반 학습(ICA 및 비정규화 모델 포함), 샘플링과 몬테카를로 적분, 변분 추론을 포함함.
     * 기타 정보
          + 관련 GitHub 페이지가 있음.
          + 이 문서는 arXiv에 제출된 것으로, 머신러닝(cs.LG) 및 통계적 머신러닝(stat.ML) 분야에 속함.
          + arXiv 식별자는 arXiv:2206.13446이며, DOI는 https://doi.org/10.48550/arXiv.2206.13446임.

        Hacker News 의견

     * 멋져 보임, 하지만 머신러닝을 공부할 때 가장 짜증나는 점 중 하나는 이론적으로 깊이 들어갈 수 있지만 실제와 어떻게 연결되는지 보이지 않는 것임. 예를 들어, 레이어의 뉴런 수를 어떻게 선택하는지, 몇 개의 레이어가 필요한지, 활성화 함수는 무엇인지, 신경망을 사용할지 다른 기술을 사용할지 등임. 누군가 이 부분을 설명해준다면 감사할 것임
     * 매우 깔끔함. Tom Yeh의 ""AI By Hand"" 연습문제를 떠올리게 함
     * 수학자들이 항상 선형대수와 행렬 이론을 머신러닝에 끼워 넣으려는 것이 재미있음. 잘 모르는 사람이라면 학자들이 LLM을 발명하고 그들과 상담해야 한다고 생각할 것임. 사실 학자들과 이론가들이 머신러닝을 저지하고, 계산 기술이 그들에게는 저급하다고 생각해서 여러 세대의 대학원생들이 상징적 증명을 하도록 강요했음
     * 깔끔해 보임. 유일한 비판은 질문 바로 뒤에 해답이 주어져 있어서 스스로 생각하기 전에 답을 읽게 된다는 점임
     * 정말 깔끔함. 머신러닝 분야에서 일하지만 수학 기초(특히 선형대수와 행렬/텐서 연산)에서 여전히 가짜 같은 느낌을 받음. 딥러닝 기초 기술에 중점을 둔 문제 세트에 대한 좋은 자료가 있는지 궁금함. 여러 교사의 관점에서 배우면 매일 조금씩 실습을 하면서 가장 잘 배움
     * 현재 ""유용한"" 머신러닝을 구축하는 실무자 중 누가 이 문제들을 해결할 수 있을까? 그들이 해결할 수 있어야 할까?
     * 해답이 완비된 아름다운 자료, 공유해줘서 고맙음. 다른 주제에 대한 이런 펜과 종이 연습문제가 있다면 관심이 있을 것임
     * arxiv는 연구 수준의 논문을 위한 곳이 아닌가? 여기에 이 자료가 호스팅된 것이 놀라움
     * 당시 논의됨: 머신러닝의 펜과 종이 연습문제 (2021) - June 2022 (55 comments)
"
"https://news.hada.io/topic?id=19937","바이러스가 알츠하이머를 유발할 수 있을까?","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        바이러스가 알츠하이머를 유발할 수 있을까?

     * 2024년 여름, 여러 연구팀이 흥미로운 결과 발표 : 대상포진 백신 접종자가 비접종자보다 치매 발생 확률이 낮음
          + 영국과 호주 의료 기록 분석 결과: 원래의 대상포진 백신(생바이러스 백신)으로 약 20%의 치매 진단 예방 가능
          + GSK와 영국 연구진의 연구: 더 효과적인 재조합 백신이 치매 예방에 더 큰 효과가 있을 가능성 시사

알츠하이머 원인에 대한 전통적 가설과 새로운 바이러스 가설

     * 기존 가설: 아밀로이드와 타우 단백질이 알츠하이머의 주요 원인
          + 이 단백질들이 뇌에 축적되어 플라크와 엉킴(tangle)을 형성 → 신경 기능 저하 유발
     * 새로운 가설: 바이러스 감염이 알츠하이머를 유발할 수 있음
          + 플라크와 엉킴은 실제로 바이러스 감염에 대한 신체의 방어 반응일 수 있음
          + 바이러스 제거로 알츠하이머 예방 또는 치료 가능성

HSV1(단순 포진 바이러스)와 알츠하이머의 관계

     * Ruth Itzhaki 교수(맨체스터 대학, 옥스퍼드 대학 방문 교수)의 연구
          + HSV1(입술 포진 유발 바이러스)은 전 세계 인구의 약 70%가 보유
          + 바이러스는 뇌 외부에서 휴면 상태로 존재하며, 재활성화 시 입술 포진 유발
          + 뇌에서 염증 유발 → 알츠하이머와 관련된 뇌 부위 손상 가능
          + 실험 결과: HSV1에 감염된 뇌세포에서 아밀로이드 수치가 급격히 증가
     * 수십 년간 과학계에서 외면 받음
          + 기존의 아밀로이드·타우 가설에 초점
          + 알츠하이머의 강한 유전적 요인 및 다운증후군 환자의 높은 발병률로 인해 회의적 시각

바이러스 가설에 힘이 실리는 이유

     * 아밀로이드·타우 단백질 감소 치료제의 실망스러운 결과
          + 수십 년간 수백억 달러가 투입되었지만 효과는 미미
     * 다른 신경 질환에서 병원체의 역할이 입증됨
          + 엡스타인-바 바이러스(EBV)와 다발성 경화증(MS)의 연관성 발견

AlzPI(알츠하이머 병원체 연구 이니셔티브)의 역할

     * 전 세계 25명의 과학자 및 기업가 모임 → 바이러스 감염이 알츠하이머 발병에 중요한 역할임을 증명 목표
     * 최근 연구에서 바이러스가 알츠하이머 관련 단백질 축적 유도 메커니즘 규명
     * 새로운 아이디어: 아밀로이드와 타우는 병원체에 대한 방어 수단일 수 있음
          + 아밀로이드와 타우 단백질 → 병원체에 달라붙어 확산 억제 가능
          + 과도한 단백질 생성 → 플라크 및 엉킴 형성 → 신경 손상

유전적 요인과 바이러스 가설의 연결

     * 다운증후군 환자의 높은 발병률 설명 가능
          + 다운증후군 환자는 아밀로이드 전구 단백질(amyloid precursor protein, APP) 생성량이 많음 → 플라크 형성 용이
          + 감염에 더 취약함
     * 1997년 연구 결과: ApoE4 유전형이 HSV1 보유 시 알츠하이머 발병 위험 증가
     * 2020년 프랑스 연구 결과: HSV1 재활성화가 ApoE4 보유자에서 알츠하이머 발병 위험 3배 증가

대상포진 바이러스와 HSV1 재활성화의 연관성

     * Tufts University 연구진(Professor Itzhaki 참여) 연구
          + 2022년 연구: 대상포진 바이러스가 HSV1 재활성화 및 플라크·엉킴 형성 유발 가능성 규명
          + 2024년 연구: 외상성 뇌 손상이 HSV1 재활성화 및 단백질 축적 유도 가능성 시사

바이러스 가설의 치료적 가능성

     * 현재 알츠하이머 치료제 → 아밀로이드 수치를 낮춰 진행 속도 완화
     * 바이러스가 원인이라면 예방 및 근본 치료 가능성
          + 백신 접종 및 항바이러스 치료제 활용 가능
          + 단순 포진 바이러스 치료제(발라시클로비르 등) 이미 시판 중
          + 대상포진 백신은 고령층에 이미 접종 중

항바이러스제와 치매 발생률 감소의 실제 사례

     * 대규모 의료 기록 분석 연구
          + 2018년 대만 연구: 포진 환자가 항바이러스제 복용 시 치매 위험 90% 감소
          + 다른 국가 연구: 항바이러스제 사용 시 치매 위험 25~50% 감소

항바이러스제의 효과를 검증하는 임상 시험

     * 콜롬비아 대학 주도 이중 맹검 무작위 임상 시험 진행 중
          + 발라시클로비르(HSV1 치료제)의 초기 알츠하이머 환자 인지 저하 완화 가능성 테스트
          + 2018~2024년 동안 120명 환자 모집 → 연구 결과 2025년 발표 예정
          + 기존 아밀로이드 가설 지지 과학자도 긍정적 결과 시 바이러스 가설 수용 가능성 시사
          + Pascal Geldsetzer 연구팀도 대상포진 백신 관련 임상 시험 준비 중

치매 치료의 새로운 가능성

     * 전 세계 약 3200만 명이 알츠하이머로 고통받고 있음
     * 항바이러스제가 일부 사례에서라도 진행 속도를 늦추거나 예방할 수 있다면 큰 영향 기대

        Hacker News 의견

     * Memantine은 알츠하이머 치료에 사용되는 항바이러스/뇌 기능 개선제임
          + Amantadine은 유사한 화합물로, 항바이러스 효과가 더 강하지만 NMDA 수용체에서는 덜 강력함
          + Amantadine이 알츠하이머 치료에 효과적일 수 있다는 의학적 가설이 있음
          + 러시아에서는 Bromantane이라는 유사한 약물이 정신 에너지 부스터로 판매되고 있음
     * 바이러스가 노화의 큰 원인일 수 있다는 의견이 있음
          + 40세에 노로바이러스와 독감에 걸린 후 10년은 더 늙은 것 같은 느낌을 받았음
          + 감염으로 인한 손상이 노화에 미치는 영향을 생각하게 됨
          + 백신을 다시 확인하고, 자녀가 성장한 후에는 더 나은 위생을 실천하고 싶음
     * Columbia University 연구진이 Valacyclovir가 초기 알츠하이머 환자의 인지 저하를 늦출 수 있는지 테스트 중임
          + 연구 규모가 작아 아쉬움이 있지만 결과가 기대됨
     * 알츠하이머에 대해 아직 모르는 것이 많음
          + 여러 질병이 같은 이름으로 묶여 있을 가능성이 있음
          + 수면의 질과 알츠하이머 사이에 강한 연관성이 있음
     * 최근 증가한 많은 질병들이 바이러스로 인해 발생할 수 있다는 의견이 있음
          + 인구 밀도 증가와 세계 여행 증가로 바이러스 압력이 증가했음
          + 바이러스가 심각한 질병을 유발할 수 있다는 사례가 있음
     * 알츠하이머가 단일 원인으로 발생하는 질병이라는 이해에 대해 경계해야 함
          + 바이러스가 알츠하이머를 유발할 수 있지만, 어느 정도까지 영향을 미치는지가 연구의 핵심임
     * Guardian의 기사에 따르면 뇌의 미생물군이 치매 예방에 도움을 줄 수 있음
          + 바이러스, 박테리아, 곰팡이가 뇌에 들어가 문제를 일으키는 경우가 흔함
     * ""알츠하이머 유사"" 증상이 COVID-19 이후에도 나타날 수 있음
          + 다른 연구도 있을 가능성이 있지만 찾기 어려움
     * 이론을 증명하기 위해 사망한 환자의 뇌 조직 샘플을 시퀀싱하는 것이 쉬울 수 있음
"
"https://news.hada.io/topic?id=19923",""Vibe Coding" vs 현실","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ""Vibe Coding"" vs 현실

     * 최근 Andrej Karpathy의 발언이 화제: ""Vibe에 몸을 맡기고, 기하급수적인 성장을 받아들이고, 코드가 존재한다는 사실 조차 잊어버리세요.""
     * ""Vibe Coding""은 명확한 계획이나 코드 작성 없이 AI 도구에 문제 해결을 위임하는 경향을 의미함
     * LLM(대형 언어 모델) 에이전트를 통해 자연어로 명령을 내리면 코드를 생성하고 수정할 수 있게 됨
          + 2022년: ChatGPT에서 코드 복사 및 수정 가능
          + 2023년: IDE와 통합된 Copilot에서 코드 리뷰 및 수정 가능
          + 2024~2025년: 프로젝트의 여러 파일을 수정하고 자체 테스트 및 수정 가능

""Vibe Coding""의 작동 방식

     * 기술 및 비기술 사용자 모두 LLM 기반 에이전트를 통해 프로젝트 설정 가능
     * 단순한 명령으로 웹사이트나 앱 생성 가능 (예: ""스키 리조트 웹사이트 만들기"")
     * 초기 설정 이후 자동 수정 및 테스트 가능
     * 예제:
          + Cursor, GitHub Copilot Agent Mode 등은 파일 수정 및 명령 실행 가능
          + 자동 수정 및 테스트 수행 → 일관성 부족으로 오류 발생 가능

에이전트의 자율성 문제

     * 에이전트는 자동으로 작업 수행 가능하지만 완전한 자율성은 아님
     * 사용자 승인 없이 실행되면 위험 발생 가능 (예: YOLO 모드에서 명령 실행)
     * 코드 품질 및 정확성 문제 발생 가능
     * 주요 문제:
          + 기존 코드 재사용 실패 → 동일한 컴포넌트 반복 생성
          + 클라이언트 측에서 서버 측 로직 실행 시도
          + 잘못된 코드 수정 후 오류 발생 → 수정 시 실패
          + 유닛 테스트 작성 실패 또는 코드 파괴 발생

현실적인 한계

     * Claude 3.7 Sonnet 등 모델은 훈련 데이터의 한계를 벗어나지 못함
     * 코드 기반에서 문맥을 잃으면 일관성 있는 수정 불가능
     * 코드 크기가 커지면 성능 저하 및 문맥 유지 불가능
     * LLM의 문맥 창 크기 초과 시 일관성 문제 발생
     * 구체적 문제 사례:
          + TypeScript 인터페이스 복제
          + 클라이언트에서 서버 로직 실행
          + 중복 컴포넌트 수정 실패
          + 유닛 테스트 작성 실패
          + 코드 리팩토링 후 오류 수정 실패

문제 해결 시도

     * Claude Plays Pokémon: 에이전트가 실시간 상호작용하며 게임 플레이
     * 메모리 유지 및 반복 오류 수정 시 실패
     * 장기적 기억 구축 실패 → 지속적인 오류 발생
     * 개선 가능성:
          + MCP(Model Context Protocol) 및 메모리 관리 개선 필요
          + 코드 수정 시 LLM이 이전 수정 내용을 정확히 반영해야 함
          + 도메인별 기억 및 작업 내역 보존 필요

결론

     * ""Vibe Coding""은 기능적인 개념을 구현하는 데 80%까지 도달할 수 있지만, 신뢰할 수 있고 안전한 제품을 만들기 위해서는 경험 있는 인간의 노력이 필요함
     * AI 에이전트는 숙련된 사람들이 독립적으로 더 많은 것을 창조할 수 있게 해주지만, 경험과 직관이 필요한 어려운 문제를 해결할 수 있는 사람들을 대체할 수는 없음.
     * 현재 수준에서는 ""Vibe Coding""이 실제로 유용한 제품으로 이어지기 어렵고, 숙련된 개발자의 도움이 필수적임
     * ""Vibe Coding""은 코드 작성의 보조 수단일 뿐, 완전한 대체 수단이 아님

   ""현재 수준"" 이라는 부분에 눈이 갑니다. 인간의 시간 개념으로 LLM을 보고 있는게 아닐까요?

   AI랑 코딩하면서 느끼는점은, AI에게 코드 일부만 주어도 맥락을 이해할 수 있게끔 단일책임원칙 + TDD 느낌의 단위 쪼개기를 하다보면 큰 맥락을 읽을 필요 없는, 부분의 맥락으로도 충분하게 잡아줘야하더라구요

   대충 만들고 나머지 디테일을 손보는 패턴이 참 좋습니다

   여러가지 시도를 하고 있지만 기억력의 한계는 분명 있습니다. PoC 수준으론 좋습니다. 빠르게 가능성/사용성 측면으론 좋습니다.

   문젠 더더욱 숙련자가 필요함.

   코딩에서 대부분의 시간을 보내는 것이 디버깅과 코드읽기 라고 볼때, 좀 과장이 심하다고 생각합니다. AI 만드는 사람들은 다들 이런 논조로 이야기 하지만, 적어도 현재 상황만 봐서는 그렇지 않은 것 같아요. 사람 손이 필요없는 상황에 이르면 굳이 코딩이 필요할까요? 그냥 API 설명을 넣어서 LLM 을 백엔드로 쓰는게 낫지.

   실제로 스키마설정해서 받아서 많이 그렇게 쓰기는 합니다.

   동감합니다. 초반엔 신비에 가까운 개발 속도를 보이지만, 규모가 커지고 파일이 많아 질수록 관리하는 책임자(여기서는 사람)이 이걸 효과적으로 관리하지 못하면, 덩치만 커지고 오류 투성이인 결과물만 받아보게 됩니다. 이미 손쓸 수 없는 지경까지 가면, 크래딧(윈드서프)이나, 리퀘스트(커서)만 낭비하게 됩니다. 점점 좋아지게 되겠지만, 지금은 AI코드를 100% 신뢰하면 안됩니다.

        Hacker News 의견

     * ""AI 과장 vs. 현실""의 큰 차이는 사람들이 흔히 말하는 생산성 수치에 있음. 예를 들어, YC 파트너들이 한 회사가 코딩 성능에서 ""100배 속도 향상""을 주장하는 것을 인용함. 이런 주장은 외부 관찰자에게 명백히 드러날 것이므로 자가 보고가 필요하지 않을 것임.
          + YC 여름 배치는 84일 동안 진행되며, 데모 데이로 끝남. 100배 속도 향상은 팀이 하루도 안 되는 시간에 데모 데이 수준의 기능을 가진 앱을 만드는 것과 같음. 만약 100배가 사실이라면, 파트너들은 새로운 배치가 ""고객과 아침을 먹고, 새로운 것을 배우고, 영감을 얻어 같은 날 앱을 다시 작성하고, 그 결과가 데모 데이 수준의 기능을 갖추고 있다""고 말할 것임. 그러나 그런 이야기는 없으므로 100배는 부정확함.
          + 10배 향상이라도 파트너들은 ""이번 배치에서는 사람들이 1주차에 데모 데이 수준의 앱을 프로덕션에 올린다""고 말할 것임. 파트너들은 팀이 얼마나 많은 일을 어느 기간에 완료하는지에 대한 큰 샘플 크기를 가지고 있음. 따라서 10배도 사실이 아님.
     * 현재 우리는 아웃소싱 열풍을 따라가고 있음. 모든 과장된 주장과 함께, 현실은 다름. LLM 코딩 에이전트에 대한 논의는 구별하기 어려움.
     * Go 커뮤니티가 컴퓨터가 인간 Go 플레이어를 이길 수 없다고 말하는 것과 같음. 이미 더 성능이 좋은 정렬을 찾는 모델의 예가 있음. 적절한 인센티브와 시간이 주어지면 컴퓨터가 우리를 이길 것임.
          + ""Vibe coding""은 아직 현실이 아님. 경험과 기술로 실수를 수정하고 안내해야 함. 그러나 개선의 궤적을 볼 수 있음.
     * 코딩 LLM에 대한 새로운 문제점 공유. 오프쇼어 개발자들이 팀에 완전히 통합되어 있음. 그러나 LLM 사용이 무분별하고 산발적이어서 제출된 풀 리퀘스트가 악몽이 됨.
          + LLM을 사용하여 코드를 작성하는 데 도움을 받지만, 매우 신중하게 사용함. 시간 절약은 있지만 품질 향상은 아님. 올바르게 요청하는 방법을 알아내는 데 걸리는 시간, 출력 검증 시간, 작은 버그 수정 시간이 이점을 상쇄함.
          + ""Vibe coding""을 하지 말고 직업을 잃지 않도록 주의해야 함.
     * ""Vibe Coding""은 개념의 80%를 구현할 수 있음. 그러나 신뢰할 수 있고 안전하며 가치 있는 것을 만들려면 경험 많은 인간이 필요함.
          + 80%는 최선의 경우 개념 증명임. 80%는 QA가 바에 들어가는 것과 같음.
     * 최근 Claude와 OpenAI o3-mini를 사용하여 Matlab 코드를 Python으로 변환하려 했으나 성능이 매우 나빴음. 거의 모든 중요한 줄에 오류가 있었음. 자동화가 필요한 작업이지만 실패함.
     * ""Vibe-TDDing""을 하면서 테스트가 없는 것보다 나음. 코딩과 테스트에 대한 이해가 있다면 LLM을 사용하여 부정적인 외부 효과를 줄일 수 있음.
     * SaaS를 구축하는 방법을 공유한 이후 이상한 일이 발생함. API 키 사용량이 최대치에 도달하고, 구독을 우회하며, DB에 랜덤한 것이 생성됨. 이것은 장난일 가능성이 있음.
     * 많은 엔지니어들이 AI 코딩 도구의 능력과 생산성을 과소평가하는 것을 보며 직업에 대한 안정감을 느낌. Cursor를 놓지 않을 것임.
          + AI 도구가 잘하는 것: 반복적인 코드 작성, 복잡한 DSA 작업, 단순하고 지루한 작업, 제한된 리팩토링
          + AI 도구가 잘 못하는 것: 제품/비즈니스를 코드에 매핑, 대규모 리팩토링
          + 코드 품질은 문제 아님. AI는 여전히 생산성 향상에 큰 도움이 됨.

   제가 AI로 취미활동에 제일 많이 이용하는게 웹게임 제작인데 동감합니다. 일정 이상 규모가 가면 어느 순간 AI가 집중도라고 해야 할 듯한 부분이 현저히 낮아지는 부분이 생기더라구요. 전 이걸 다음과 같은 방식으로 활용하는데, 게임내 전체 트리와 소스코드를 TOC를 포함한 하나의 파일로 합치고, 신규 스레드를 생성하면서 해당 파일을 업로드하고 작업을 이어갑니다. 그리고 질문을 할때는 항상 명확하게 현재 프로젝트의 명을 명시적으로 이야기 하면서 대답을 요구하죠. 그럼에도 불구하고 아직 불만족 스러운 부분들이 있지만.. 과거 현생에 바빠 엄두도 내지 못하던 취미생활을 상대적으로 짧은 시간으로 완성해나가고 있는 부분들은 너무 만족스럽습니다.
"
"https://news.hada.io/topic?id=19881","Show GN: AI로 번역한 앵귤러 공식 문서","                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Show GN: AI로 번역한 앵귤러 공식 문서

   안녕하세요! 최근 앵귤러 프로젝트에 합류하면서 한글 자료 부족으로 어려움을 겪었어요.
   그래서 오픈소스 AI 번역 프로젝트를 활용해 앵귤러 공식문서를 단 5시간 만에 한글화 후 배포까지 해보았답니다.
   현재는 대부분 AI로 초벌 번역만 진행한 상태입니다!

  번역 진행 상황

     * 300개 가량의 md 파일 번역 완료
     * HTML 파일 등 자동으로 번역되지 않은 파일을 추가로 번역 중
     * 코드 예제와 함께 핵심 개념을 한글로 이해할 수 있음
     * 영어 원문과 동일한 구조로 필요한 내용을 쉽게 찾을 수 있음

   사실 번역한 앵귤러 문서를 소개하기 위해 Show GN 카테고리를 이용할지, 번역 도구를 소개하기 위해 뉴스 카테고리를 이용할지 고민했어요.
   앵귤러를 이용하는 사람이 많진 않겠지만 혹시나 한글 자료를 찾는 분들에게 도움이 될 수 있을까 싶어 Show GN을 선택했습니다!

  사용한 도구

   ""ai-markdown-translator"" 라는 작은 프로젝트를 발견했는데 예상보다 훌륭한 결과물이 나왔어요.
   꽤 마음에 들어서 프로젝트에 기여하고자 저장소를 포크해 코드를 수정해보는 중이에요.

    장점

     * 마크다운 문서 번역에 특화된 오픈소스 프로젝트
     * 폴더 내 특정 확장자의 파일을 재귀적으로 번역 가능
     * npx ai-markdown-translator -i . -e md -l ""Korean"" --log 라는 명령어를 이용해 한 번에 번역
     * 문법 구조와 마크다운 포맷을 대부분 보존하며 번역
     * MD 컨텐츠를 기반으로 페이지를 만드는 기술 문서에 적합한 도구

    한계점

     * Signal을 '신호'로 번역하는 등 전문 용어의 직역이 아쉬움
     * 일부 파일 참조 경로가 잘못 변경되는 문제를 발견
     * 초벌 번역 수준으로 개선이 필요한 부분들이 있어요

  번역 및 배포 과정

    1. 앵귤러 공식 문서 저장소를 클론
    2. 명령어 실행 후 2시간 후 300개 가량의 파일 번역 완료
    3. 잘못된 파일 참조 경로 수정
    4. 기존 앵귤러 프로젝트의 Firebase 설정 참고하여 배포 진행

   아직 다듬어야 하는 부분이 많아 차차 검토하고 수정해야겠지만 투자한 시간에 비해 결과물이 꽤 괜찮았던 것 같아요.
   MD 형식으로 작성된 기술 문서를 번역하고 싶으신 분들께 테스트해보시길 추천드립니다!!

   긴 글 읽어주셔서 감사합니다! 좋은 하루 되세요!! ❤️‍🔥

   GitHub 저장소

   와! 앵귤러!

   ...! 앵귤러 사용하시나요?
   요즘 한국 사용자가 거의 없는 것 같던데 댓글 달아주시니 너무 반갑네요! ㅋㅋㅋㅋ

   리액트는 할 줄 모르고 앵귤러만 조금 할 줄 아는데 한국 커뮤니티에서 앵귤러 글을 보니 기쁘네요

   저는 리액트만 쓰다 앵귤러로 넘어오게 됐는데 반대네요 ㅋㅋㅋ
   언젠가 기회가 된다면 또 Angular 글 써보겠습니다,,,ㅎㅎ
"
